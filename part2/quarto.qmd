# Quarto

In [Your First R Project](../part1/first-project.qmd), you worked with a `.qmd` file—running code chunks interactively, viewing results in the plots pane, and rendering the document to HTML. This chapter explains Quarto's syntax and features in depth so you can write your own analysis documents from scratch.

Quarto is a scientific publishing system that lets you combine code, results, and narrative text in a single document. You write analysis scripts as `.qmd` files—plain text with embedded R or Python code—and Quarto renders them into polished HTML reports with your outputs automatically included.

In the Musser Lab, Quarto documents are the standard format for data analysis because they solve a fundamental problem: keeping your code, your results, and your explanation of those results in sync. When you render a `.qmd` file, Quarto executes the code fresh and weaves the outputs into the document, so the report always reflects the actual analysis.

## Why Quarto?

### Compared to Plain R Scripts

A plain `.R` script is just code. It can produce outputs, but there's no built-in way to document what the code does, why you made certain choices, or what the results mean. When you share a script, collaborators see the code but not your interpretation.

With Quarto:

- **Code and narrative live together** — explain what you're doing as you do it
- **Results are embedded** — figures and tables appear in the document
- **Output is shareable** — render to HTML that anyone can open in a browser

### Compared to R Markdown

If you've used R Markdown (`.Rmd`), Quarto will feel familiar. The core idea—mixing code, results, and narrative—is the same. Quarto is R Markdown's successor, developed by Posit (the company behind RStudio) as a unified system that works equally well with R, Python, Julia, and other languages.

| | R Markdown | Quarto |
|---|---|---|
| File extension | `.Rmd` | `.qmd` |
| Language support | R-centric (Python possible but awkward) | Multi-language by design |
| Chunk options | `{r, echo=FALSE}` | `#| echo: false` (YAML-style) |
| Output formats | Documents, some websites | Documents, websites, books, slides, dashboards |

You don't need to memorize the differences. If you know R Markdown, Quarto works similarly. If you're new to both, just learn Quarto—it's the modern standard.

### What Else Can Quarto Do?

While we primarily use Quarto for analysis scripts, it's a general-purpose publishing system. This book was built with Quarto. You can also create:

- **Websites** — project documentation, lab websites
- **Presentations** — slides rendered from code (RevealJS format)
- **Dashboards** — interactive displays of data

See the [Quarto documentation](https://quarto.org/docs/guide/) if you want to explore these formats.

## The Interactive Development Workflow

Before diving into syntax, understand how you'll actually work with Quarto documents. The workflow has two modes:

### Interactive Development

Most of your time is spent running code **interactively**—executing chunks one at a time, inspecting results, and iterating. This is exploratory work:

1. **Write a chunk** of code in your `.qmd` file
2. **Run it** with Cmd+Enter (macOS) or Ctrl+Enter (Windows)
3. **Inspect** the output in the Console, Variables pane, or Data Viewer
4. **Iterate** — modify the code, run again, check results
5. **Move on** to the next chunk when satisfied

During interactive development, you're using Positron like an enhanced REPL. The `.qmd` file is your scratch pad. Objects you create persist in your R or Python session, so you can build on previous chunks.

[TODO: screenshot of Positron with .qmd open, console showing output, Data Viewer with dataframe]

### Rendering

When the analysis is complete—or when you want to share it—you **render** the document:

```default
quarto render my_analysis.qmd
```

Rendering executes every code chunk in a **fresh session** (no leftover objects from interactive work) and produces a standalone HTML file. This catches errors you might miss interactively, like relying on an object you created manually but forgot to include in the script.

**The key insight**: Interactive mode is for development. Rendering is for validation and sharing. Always render before committing or sending a report to someone.

### A Typical Session

Here's what a working session looks like:

1. Open your project in Positron
2. Open or create a `.qmd` file
3. Write the setup chunk (libraries, paths)
4. Run it interactively to confirm packages load
5. Write a data-loading chunk, run it, inspect the data in Data Viewer
6. Write analysis chunks one at a time, running and checking each
7. When complete, render the full document
8. Fix any errors that appear during render (usually missing objects or packages)
9. Commit the `.qmd` file (and optionally the rendered HTML)

This interactive-then-render workflow is why Quarto documents are more reliable than scripts you only ever run interactively.

## Document Structure

A Quarto document has two parts:

1. **YAML header** — metadata and rendering options (between `---` markers at the top)
2. **Body** — Markdown text interspersed with code chunks

### Minimal Example

````markdown
---
title: "My Analysis"
format: html
---

## Introduction

This analysis examines the relationship between X and Y.

```{{r}}
library(tidyverse)
data <- read_csv("data/input.csv")
glimpse(data)
```

## Results

```{{r}}
ggplot(data, aes(x = x, y = y)) +
  geom_point()
```
````

When rendered, this produces an HTML file with the title, your text, and the code outputs (the `glimpse()` output and the plot) embedded.

## The YAML Header

The YAML header controls document metadata and rendering behavior. Here's the standard header for a lab analysis script:

```yaml
---
title: "Phosphoproteomics Volcano Plots"
subtitle: "Tryptamine treatment time course"
author: "Your Name"
date: today
status: development        # development | finalized | deprecated
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-overflow: wrap
    code-fold: false
    code-tools: true
    highlight-style: github
    theme: cosmo
    fontsize: 1rem
    linestretch: 1.5
    self-contained: true
execute:
  echo: true
  message: false
  warning: false
  cache: false
---
```

### Document Metadata

| Option | Purpose | Example |
|--------|---------|---------|
| `title` | Document title (appears at top) | `"My Analysis"` |
| `subtitle` | Secondary title | `"Brief description"` |
| `author` | Your name | `"Jane Doe"` |
| `date` | Date; use `today` for automatic | `today` |
| `status` | Script lifecycle stage (see [Project Organization](project-organization.qmd#script-lifecycle)) | `development` |

### Format Options

These go under `format: html:` and control the HTML output:

| Option | Purpose | Recommended |
|--------|---------|-------------|
| `toc` | Include table of contents | `true` |
| `toc-depth` | How many heading levels in TOC | `2` |
| `number-sections` | Number your headings | `true` |
| `code-overflow` | How to handle long code lines | `wrap` |
| `code-fold` | Collapse code blocks by default | `false` for analysis scripts |
| `code-tools` | Add show/hide all code button | `true` |
| `highlight-style` | Syntax highlighting theme | `github` |
| `theme` | Bootstrap theme for HTML | `cosmo` |
| `fontsize` | Base font size | `1rem` |
| `linestretch` | Line spacing multiplier | `1.5` |
| `self-contained` | Single HTML file (no external dependencies) | `true` |

### Execute Options

These go under `execute:` and control code execution:

| Option | Purpose | Recommended |
|--------|---------|-------------|
| `echo` | Show code in output | `true` for analysis scripts |
| `message` | Show package messages | `false` (R only) |
| `warning` | Show warnings | `false` |
| `cache` | Cache chunk results | `false` |

Setting `message: false` and `warning: false` globally keeps your rendered output clean. You can override these per-chunk when you need to see specific messages. We set `cache: false` explicitly to avoid subtle bugs from stale cached results.

## The Setup Chunk

Every analysis script should start with a setup chunk that loads packages, defines paths, sets options, and captures the git commit hash for provenance.

```r
#| label: setup
#| include: false

# ---- Libraries ----
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
})

# ---- Paths ----
dir_data <- here::here("data")
dir_out <- here::here("outs", "01_script_name")
dir.create(dir_out, recursive = TRUE, showWarnings = FALSE)

# ---- Options ----
options(stringsAsFactors = FALSE)
set.seed(42)

# ---- Provenance ----
git_hash <- system("git rev-parse --short HEAD", intern = TRUE)
cat("Rendered from commit:", git_hash, "\n")
```

### Key Patterns

**`#| include: false`** — The chunk runs but doesn't appear in the rendered output. Use this for setup code that readers don't need to see.

**`suppressPackageStartupMessages()`** — Prevents the startup messages that packages print when loaded. This keeps your console (and rendered output) clean.

**`here::here()`** — Builds file paths relative to the project root, not the script location. Essential for reproducibility. See [Working Directory and Paths](#working-directory-and-paths) below.

**`dir.create(..., showWarnings = FALSE)`** — Ensures output directories exist. The `showWarnings = FALSE` prevents errors if the directory already exists.

**`set.seed()`** — Makes random operations reproducible. Use a fixed seed when your analysis involves any randomness (sampling, clustering, etc.).

**`git_hash`** — Captures the current commit for provenance tracking. This is used later in `BUILD_INFO.txt` (see [Provenance Chunk](#provenance-chunk) below).

## Documenting Inputs

After the setup chunk, add an explicit inputs section that loads all dependencies. This makes it immediately clear what the script needs to run:

```r
#| label: inputs

# --- Inputs (from other scripts) ---
results <- readRDS(here("outs/03_differential/limma_results.rds"))

# --- Inputs (external data) ---
metadata <- read_csv(here("data/sample_metadata.csv"))
```

Separating inputs from analysis code makes dependencies self-documenting—reading the top of any script shows exactly what it depends on. You can also document outputs in the introduction text:

```markdown
# Volcano Plots

This script generates volcano plots for the phosphoproteomics time course.

**Inputs:**

- `outs/03_differential/limma_results.rds`
- `data/sample_metadata.csv`

**Outputs:**

- `outs/04_volcano_plots/volcano_*.pdf`
- `outs/04_volcano_plots/significant_hits.csv`
```

See the [Project Organization](project-organization.qmd) chapter for how this fits into the larger project structure.

## Code Chunks

Code chunks are fenced with triple backticks and a language identifier:

````markdown
```{{r}}
# R code here
```

```{{python}}
# Python code here
```
````

### Chunk Options

Use the `#|` syntax to set options for individual chunks:

```r
#| label: load-data
#| message: false
#| warning: false

data <- read_csv(here::here("data", "input.csv"))
```

The `label` option names the chunk. This is useful for:

- Debugging (error messages reference the chunk label)
- Cross-references (linking to figures)
- Caching (cached chunks are identified by label)

### Common Chunk Options

| Option | Purpose | Values |
|--------|---------|--------|
| `label` | Chunk identifier | `load-data`, `fig-volcano` |
| `echo` | Show this chunk's code | `true`, `false` |
| `eval` | Run this chunk | `true`, `false` |
| `include` | Include in output at all | `true`, `false` |
| `message` | Show messages | `true`, `false` |
| `warning` | Show warnings | `true`, `false` |
| `fig-cap` | Figure caption | `"My figure title"` |
| `fig-width` | Figure width (inches) | `6` |
| `fig-height` | Figure height (inches) | `4` |

### Chunk Patterns

**Hidden setup** — runs but doesn't appear in output:

```r
#| label: setup
#| include: false

library(tidyverse)
```

**Visible code with clean output** — shows code, hides messages:

```r
#| label: load-data
#| message: false
#| warning: false

data <- read_csv("data.csv")
```

**Figure with caption** — for publication-ready figures:

```r
#| label: fig-volcano
#| fig-cap: "Volcano plot showing differential expression"
#| fig-width: 6
#| fig-height: 4

ggplot(results, aes(x = logFC, y = -log10(pvalue))) +
  geom_point()
```

**Code shown but not run** — for demonstrating syntax:

```r
#| label: example-syntax
#| eval: false

# This code is displayed but not executed
hypothetical_function()
```

## Working with R

### Running Code

Select code in the editor and press **Cmd+Enter** (macOS) or **Ctrl+Enter** (Windows) to run it in the R console. For entire chunks, use **Cmd+Shift+Enter**.

When you run R code:

- Output appears in the Console
- Plots appear in the Plots pane (and can be viewed in Data Viewer for inspection)
- Objects are created in your R session (visible in Variables pane)

### The Data Viewer

Click any dataframe in the Variables pane to open it in Positron's Data Viewer. This is essential for exploratory work—you'll constantly check data after transformations to verify they worked correctly.

### renv Integration

If your project uses renv (and it should), the R console automatically activates it. You'll see:

```
- Project '/path/to/project' loaded. [renv 1.0.0]
```

This confirms you're using the project's package library, not your global library.

## Working with Python {#working-with-python}

Quarto `.qmd` is the standard format for Python data analysis in the lab, just as it is for R. Plain `.py` files are for standalone utilities, CLI tools, and library code—not for data analysis scripts. Everything described above (YAML headers, setup chunks, inputs, provenance) applies to Python QMD too.

### Running Code

The same shortcuts work for Python: **Cmd+Enter** to run the current line or selection.

For Python chunks to execute during render, you need `ipykernel` installed in your conda environment:

```default
conda install ipykernel
```

### Selecting the Interpreter

Ensure Positron is using the correct conda environment:

1. Open Command Palette (Cmd/Ctrl+Shift+P)
2. Type "Python: Select Interpreter"
3. Choose your project's conda environment

### Rendering Python QMD

::: {.callout-important}
## Activate Conda Before Rendering

Python QMD files require the conda environment to be active when you render. Without this, Quarto uses the wrong Python or can't find your packages:

```default
source ~/miniconda3/etc/profile.d/conda.sh && conda activate my-project && quarto render scripts/02_analysis.qmd
```

This is the #1 Python QMD gotcha. If `quarto render` fails with `ModuleNotFoundError`, check that your conda environment is active.
:::

### Python YAML Header

The Python YAML header is the same as R, with two differences: add `jupyter: python3` and drop `message: false` (which is R-specific):

```yaml
---
title: "Script Title"
subtitle: "Brief description"
author: "Your Name"
date: today
status: development
jupyter: python3
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-overflow: wrap
    code-fold: false
    code-tools: true
    highlight-style: github
    theme: cosmo
    fontsize: 1rem
    linestretch: 1.5
    self-contained: true
execute:
  echo: true
  warning: false
  cache: false
---
```

### Python Setup Chunk

```python
#| label: setup

import subprocess
import sys
import random
from pathlib import Path
from datetime import datetime

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

PROJECT_ROOT = Path(subprocess.check_output(
    ["git", "rev-parse", "--show-toplevel"]
).decode().strip())
sys.path.insert(0, str(PROJECT_ROOT / "python"))
# from helpers import ...  # if needed

# ---- Options ----
random.seed(42)
np.random.seed(42)
pd.set_option("display.max_columns", None)
sns.set_theme(style="whitegrid")

# ---- Paths ----
out_dir = PROJECT_ROOT / "outs/XX_script_name"
out_dir.mkdir(parents=True, exist_ok=True)

git_hash = subprocess.check_output(
    ["git", "rev-parse", "--short", "HEAD"]
).decode().strip()
print(f"Rendered from commit: {git_hash}")
```

Key differences from R:

- **`PROJECT_ROOT`** replaces `here::here()` — found via `git rev-parse --show-toplevel`
- **Helper loading** uses `sys.path.insert()` instead of `source()`
- **Two random seeds** — `random.seed(42)` for Python stdlib, `np.random.seed(42)` for NumPy

### Python Figure Saving

Save figures to `outs/` AND display inline:

```python
#| label: fig-example
#| fig-cap: "Description of figure"

fig, ax = plt.subplots(figsize=(6, 4))
# ... plotting code ...
plt.tight_layout()

# Save to outs/ AND display inline
fig.savefig(out_dir / "figure_name.pdf", dpi=300, bbox_inches="tight")
fig.savefig(out_dir / "figure_name.png", dpi=300, bbox_inches="tight")
plt.show()
```

### Python Provenance Chunk

```python
#| label: build-info

(out_dir / "BUILD_INFO.txt").write_text(
    f"script: XX_script_name.qmd\n"
    f"commit: {git_hash}\n"
    f"date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
)

import session_info
session_info.show()
```

::: {.callout-note}
`session_info` must be installed in your conda environment: `pip install session-info`. Include it in every data science environment.
:::

### Language Mixing

Do not mix R and Python chunks in a single `.qmd`. Each script uses one language. Scripts communicate through files in `outs/`, not shared memory. If an R script produces data that a Python script needs, save it as Parquet (see [Project Organization](project-organization.qmd#output-files)).

### R vs Python Quick Reference

| Convention | R | Python |
|------------|---|--------|
| Project root | `here::here()` | `PROJECT_ROOT` (from git) |
| Read CSV | `read_csv(here("data/file.csv"))` | `pd.read_csv(PROJECT_ROOT / "data/file.csv")` |
| Read TSV | `read_tsv(here("data/file.tsv"))` | `pd.read_csv(PROJECT_ROOT / "data/file.tsv", sep="\t")` |
| Read Parquet | `arrow::read_parquet(here(...))` | `pd.read_parquet(PROJECT_ROOT / ...)` |
| Save figure | `ggsave(file.path(dir_out, "fig.pdf"))` | `fig.savefig(out_dir / "fig.pdf")` |
| Random seed | `set.seed(42)` | `random.seed(42)` + `np.random.seed(42)` |
| Session info | `sessionInfo()` | `session_info.show()` |
| Chunk label | `{r label-name}` or `#| label:` | `#| label:` only |
| Helper loading | `source(here("R/helpers.R"))` | `sys.path.insert(0, str(PROJECT_ROOT / "python"))` |

## Saving Outputs

Don't rely on the Plots pane or copy-paste. Save figures and tables to files explicitly:

```r
#| label: fig-volcano
#| fig-cap: "Volcano plot showing differential phosphorylation"

p <- ggplot(results, aes(x = logFC, y = -log10(adj.P.Val))) +
  geom_point() +
  theme_minimal()

# Display in rendered document
print(p)

# Save to output folder
ggsave(
  file.path(dir_out, "volcano_plot.pdf"),
  plot = p,
  width = 6,
  height = 4
)
```

This approach:

- Embeds the figure in the rendered HTML (via `print(p)`)
- Saves a high-quality PDF for publication or further use
- Makes the output traceable (the file exists in `outs/`)

For tables:

```r
# Save results table
write_csv(significant_hits, file.path(dir_out, "significant_hits.csv"))
```

## Working Directory and Paths

When Quarto renders a `.qmd`, the working directory is the folder containing the `.qmd` file—not the project root. This can cause path confusion.

```
project/
├── scripts/
│   └── 01_analysis.qmd    ← Working directory during render
├── data/
│   └── input.csv
└── outs/
```

From `scripts/01_analysis.qmd`, a relative path to the data would be `../data/input.csv`. But this breaks if you move the script or run it from a different location.

### The Solution: `here::here()`

The `here` package finds the project root (by looking for `.git`, `.Rproj`, etc.) and builds paths from there:

```r
# Always works, regardless of working directory
data <- read_csv(here::here("data", "input.csv"))

# Instead of fragile relative paths
data <- read_csv("../data/input.csv")  # Don't do this
```

Use `here::here()` for all file paths in your scripts. It makes your code portable and reproducible.

## Rendering

### From the Terminal

```default
# Render an R document
quarto render scripts/01_analysis.qmd

# Render a Python document (conda must be active!)
source ~/miniconda3/etc/profile.d/conda.sh && conda activate my-project && quarto render scripts/02_plots.qmd

# Render all .qmd files in a directory
quarto render scripts/
```

### From Positron

- Click the **Render** button in the editor toolbar
- Or use **Cmd+Shift+K** (macOS) / **Ctrl+Shift+K** (Windows)

### Preview Mode

For live feedback during development, use preview mode:

```default
quarto preview scripts/01_analysis.qmd
```

This opens a browser window that automatically refreshes when you save changes. Useful for tuning formatting, but remember that preview still renders in a fresh session—it's not the same as interactive execution.

## Best Practices

### Render Before Committing

Always render the full document before committing to Git. This catches:

- Missing packages (installed interactively but not in lockfile)
- Missing objects (created interactively but not in the script)
- Order dependencies (chunks that depend on earlier chunks you modified)

### Self-Contained Scripts

Every `.qmd` should run successfully from a fresh R session. Don't assume objects exist from previous interactive work. If render fails, your script isn't self-contained.

### Clear Section Structure

Organize your script with clear headings:

```markdown
# Introduction
# Setup
# Load Data
# Analysis
# Results
# Summary
```

This makes the script navigable (via Positron's Outline panel) and the rendered document readable.

### Validation Chunks

For complex analyses, add validation chunks that verify data integrity:

```r
#| label: validate-data
#| include: false

# Check required columns exist
required_cols <- c("sample_id", "condition", "value")
missing_cols <- setdiff(required_cols, names(data))
if (length(missing_cols) > 0) {
  stop("Missing required columns: ", paste(missing_cols, collapse = ", "))
}

# Check for expected conditions
stopifnot("No data loaded" = nrow(data) > 0)
```

These chunks catch problems early and provide clear error messages.

### Provenance Chunk {#provenance-chunk}

End every script with a chunk that writes `BUILD_INFO.txt` and prints session information:

```r
#| label: build-info

writeLines(
  c(
    paste("script:", "01_script_name.qmd"),
    paste("commit:", git_hash),
    paste("date:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"))
  ),
  file.path(dir_out, "BUILD_INFO.txt")
)

sessionInfo()
```

This records:

- **BUILD_INFO.txt** — which script, commit, and timestamp produced the outputs (answers "when was this last regenerated?")
- **sessionInfo()** — R version, package versions, and platform in the rendered HTML

## Common Issues

::: {.callout-warning title="Claude Code"}
Claude Code can debug render failures, especially the common case where code works interactively but fails during rendering.

> When I run `quarto render analysis.qmd`, I get this error: [paste error]. The code runs fine interactively in the console. What's going wrong?

Claude will trace the error to its cause—typically a missing object that existed in your interactive session but isn't created in the script, or a path that resolves differently during rendering.
:::

### "Object not found" During Render

Code that works interactively may fail during render if you rely on objects not created in the script.

**Cause**: You created an object manually in the console, then used it in a chunk without creating it in the script.

**Fix**: Ensure all objects are created within the `.qmd`. Render frequently to catch this early.

### Figures Not Appearing

If a plot doesn't show up in the rendered output:

```r
p <- ggplot(data, aes(x, y)) + geom_point()
print(p)  # Required inside loops or complex chunks
```

The explicit `print()` is needed when the plot is the result of an assignment or is inside a loop/function.

### Package Messages Cluttering Output

Set `message: false` and `warning: false` in the `execute:` block:

```yaml
execute:
  message: false
  warning: false
```

Or per-chunk for specific chunks.

### Output File Is Huge

If your HTML is very large:

- **Embedded images**: Use `self-contained: false` to keep images in a separate `_files` folder
- **High resolution**: Add `fig-dpi: 150` to reduce figure resolution
- **SVG format**: Use `fig-format: png` instead of SVG for complex plots

### Chunk Takes Forever

For long-running chunks during development, consider:

```r
#| cache: true
```

This caches the chunk's results. Subsequent renders skip execution if the code hasn't changed. Use sparingly—caching can cause subtle bugs if dependencies change.

## Quick Reference

### Typical YAML Header (R)

```yaml
---
title: "Analysis Title"
subtitle: "Project context"
author: "Your Name"
date: today
status: development
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-overflow: wrap
    code-fold: false
    code-tools: true
    highlight-style: github
    theme: cosmo
    fontsize: 1rem
    linestretch: 1.5
    self-contained: true
execute:
  echo: true
  message: false
  warning: false
  cache: false
---
```

### Typical YAML Header (Python)

```yaml
---
title: "Analysis Title"
subtitle: "Project context"
author: "Your Name"
date: today
status: development
jupyter: python3
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-overflow: wrap
    code-fold: false
    code-tools: true
    highlight-style: github
    theme: cosmo
    fontsize: 1rem
    linestretch: 1.5
    self-contained: true
execute:
  echo: true
  warning: false
  cache: false
---
```

### R Setup Chunk Template

```r
#| label: setup
#| include: false

# ---- Libraries ----
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
})

# ---- Paths ----
dir_data <- here::here("data")
dir_out <- here::here("outs", "01_script_name")
dir.create(dir_out, recursive = TRUE, showWarnings = FALSE)

# ---- Options ----
options(stringsAsFactors = FALSE)
set.seed(42)

# ---- Provenance ----
git_hash <- system("git rev-parse --short HEAD", intern = TRUE)
cat("Rendered from commit:", git_hash, "\n")
```

### Python Setup Chunk Template

```python
#| label: setup

import subprocess, sys, random
from pathlib import Path
from datetime import datetime

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

PROJECT_ROOT = Path(subprocess.check_output(
    ["git", "rev-parse", "--show-toplevel"]
).decode().strip())
sys.path.insert(0, str(PROJECT_ROOT / "python"))

random.seed(42)
np.random.seed(42)
pd.set_option("display.max_columns", None)
sns.set_theme(style="whitegrid")

out_dir = PROJECT_ROOT / "outs/XX_script_name"
out_dir.mkdir(parents=True, exist_ok=True)

git_hash = subprocess.check_output(
    ["git", "rev-parse", "--short", "HEAD"]
).decode().strip()
print(f"Rendered from commit: {git_hash}")
```

### Chunk Options Reference

| Option | Purpose | Values |
|--------|---------|--------|
| `label` | Chunk name | Any string |
| `echo` | Show code | `true` / `false` |
| `eval` | Run code | `true` / `false` |
| `include` | Include in output | `true` / `false` |
| `message` | Show messages | `true` / `false` |
| `warning` | Show warnings | `true` / `false` |
| `error` | Continue on error | `true` / `false` |
| `cache` | Cache results | `true` / `false` |
| `fig-cap` | Figure caption | String |
| `fig-width` | Width in inches | Number |
| `fig-height` | Height in inches | Number |
| `fig-dpi` | Resolution | Number (default 72) |
| `fig-format` | Output format | `png` / `svg` / `pdf` |
| `tbl-cap` | Table caption | String |

### Quarto Commands

| Command | Purpose |
|---------|---------|
| `quarto render file.qmd` | Render to HTML |
| `quarto render file.qmd --to pdf` | Render to PDF |
| `quarto preview file.qmd` | Live preview in browser |
| `quarto render directory/` | Render all .qmd in directory |
| `quarto check` | Verify Quarto installation |

### Keyboard Shortcuts (Positron)

| Action | macOS | Windows |
|--------|-------|---------|
| Run line/selection | Cmd+Enter | Ctrl+Enter |
| Run chunk | Cmd+Shift+Enter | Ctrl+Shift+Enter |
| Render document | Cmd+Shift+K | Ctrl+Shift+K |
| Insert R chunk | Cmd+Option+I | Ctrl+Alt+I |