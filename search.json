[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Analysis in the Musser Lab",
    "section": "",
    "text": "Welcome\nThis guide teaches reproducible, collaborative data analysis workflows for the Musser Lab. Most lab projects use both R and Python: R is often best for statistical analysis, plotting, and many important legacy packages used for RNA sequencing and proteomic analysis (e.g. Seurat, DESeq2, and limma); Python is often best for automating analysis pipelines (including in bash), manipulating files, working with sequences and strings, and a growing number of RNAseq data analysis libraries (e.g. Scanpy, metacell) and plotting libraries (e.g. Matplotlib). The goal of this guide is to help you set up a standard workflow for creating computational projects that are well-managed, documented, collaborative, and reproducible.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#who-this-guide-is-for",
    "href": "index.html#who-this-guide-is-for",
    "title": "Data Analysis in the Musser Lab",
    "section": "Who This Guide Is For",
    "text": "Who This Guide Is For\nThis guide is for lab members who have some experience writing code — maybe you’ve used R in RStudio, written Python scripts, or worked through a data analysis tutorial. You should be comfortable with basics like variables, functions, and reading error messages, but you don’t need to be an expert. You also don’t need any prior experience with the specific tools we’ll use (Positron, conda, renv, Git) — we’ll walk you through all of those.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Data Analysis in the Musser Lab",
    "section": "How to Use This Book",
    "text": "How to Use This Book\nStart with Part 1: Quick Start. This is the hands-on introduction. You’ll install a few tools, then work through a real single-cell RNA-seq analysis in Positron — learning the IDE, Quarto documents, and interactive coding along the way. This is where every new lab member should begin.\nParts 2–4 are reference material that you’ll use as you need it:\n\nPart 2: Core Tools — Deeper coverage of each tool in the lab stack: Positron, project organization, Quarto, renv, conda, and Git/GitHub. Come here when you need to understand how something works or troubleshoot it.\nPart 3: Claude Code — How to use AI-assisted coding to accelerate your work. Covers setup, project configuration, and working effectively with Claude Code.\nPart 4: Workflows — Practical guides for common tasks: setting up a new project, collaborating with others, ensuring reproducibility, and troubleshooting.\n\n\n\n\n\n\n\nImportantWork in Progress\n\n\n\nParts 2, 3, and 4 are still being written. Some chapters are complete, others are drafts or placeholders. Part 1 is ready to use now.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#by-the-end-of-your-first-project",
    "href": "index.html#by-the-end-of-your-first-project",
    "title": "Data Analysis in the Musser Lab",
    "section": "By the End of Your First Project",
    "text": "By the End of Your First Project\nAfter working through Part 1, you should be able to:\n\nOpen a project folder in Positron and navigate the IDE (file explorer, console, environment pane, plots pane)\nRun R code interactively in a Quarto document (.qmd) and see results in real time\nPerform a basic single-cell RNA-seq analysis — from loading a count matrix to generating a UMAP\nRender a Quarto document into a self-contained HTML report\nUse renv to manage R package dependencies for a project\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nThroughout this guide, you’ll see orange boxes like this one. Each shows how Claude Code — an AI coding assistant — can help with that chapter’s topic. Each box has an example prompt and a brief explanation of what Claude Code will do.\nThese aren’t magic incantations — they’re examples of how to ask for help effectively. The key is being specific: include the error message, the file name, or what you’re trying to accomplish. Claude Code works best when you give it context.\nYou’ll install Claude Code in the Installation chapter and can start using these prompts right away.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#our-goal",
    "href": "index.html#our-goal",
    "title": "Data Analysis in the Musser Lab",
    "section": "Our Goal",
    "text": "Our Goal\nWe want every lab member to feel confident doing computational work — not just running scripts someone else wrote, but understanding and building their own analyses. The tools in this guide are chosen to make that easier: modern editors that help you explore data interactively, environment managers that keep your projects organized, version control that lets you share code and collaborate without fear of breaking things, and AI assistants like Claude Code that can help you write, debug, and learn faster. Everything we do is oriented around one principle: your analyses should be easy to reproduce and share with others in the lab and beyond.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "part1/intro.html",
    "href": "part1/intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What We’re Going to Do\nIn Part 1, you’re going to install a few tools and then run a real single-cell RNA-seq analysis, including loading a count matrix, filtering and normalizing the data, clustering cells, and generating a UMAP visualization. You’ll do all of this interactively in Positron, an IDE we use to organize coding projects, write and run code, and interact with AI assistants. At the end you will have set up a basic project, created and run some preliminary analysis, and generated a Quarto document that doubles as both script and shareable report.\nAlong the way, you’ll learn to use the essential features of Positron that are used every day: the file explorer for navigating your project, the console for running code interactively, the environment pane for inspecting your data, the plots pane for viewing figures, and the terminal for running commands.\nBy the end, you’ll have a working project with a rendered HTML report that you could share with anyone in the lab. That’s the starting point for every analysis you’ll do here.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "part1/intro.html#how-we-work-in-the-lab",
    "href": "part1/intro.html#how-we-work-in-the-lab",
    "title": "1  Introduction",
    "section": "1.2 How We Work in the Lab",
    "text": "1.2 How We Work in the Lab\nMost analysis in the Musser Lab is written in Quarto documents (.qmd files). A Quarto document is both a script, containing code chunks you can run interactively, as well as a report, which includes annotations that help readers (and yourself!) remember and understand what the code is doing. In addition to running code interactively, you can also render the Quarto document to produce a clean HTML (or PDF) document with your results, figures, and narrative included. This means your analysis and your documentation are always in sync, and there’s no separate step of copying figures into a report or updating numbers by hand.\nOur projects typically use both R and Python, though usually one language per script. R is used for statistical analysis, plotting, and the many well-established bioinformatics packages (Seurat, DESeq2, limma). Python was classically used for manipulating text files, working with sequence data, and running pipelines that manipulated files in bash. Increasingly, many modern single-cell and biological data science tools are being developed in Python. R remains essential for plenty of analyses, so lab members will need to be competent in both. Fortunately, Positron handles both languages equally well, so you can switch between them as needed.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "part1/intro.html#the-tools",
    "href": "part1/intro.html#the-tools",
    "title": "1  Introduction",
    "section": "1.3 The Tools",
    "text": "1.3 The Tools\nHere’s a quick overview of the tools you’ll encounter in this guide and how they fit together. You don’t need to understand all of this now — you’ll learn each tool as you need it.\n┌───────────────────────────────────────────────────┐\n│                      Positron                     │\n│          (where you write and run code)           │\n│                                                   │\n│   ┌───────────┐  ┌───────────┐  ┌─────────────┐   │\n│   │   Conda   │  │   renv    │  │ Claude Code │   │\n│   │  (Python  │  │    (R     │  │ (AI coding  │   │\n│   │ packages) │  │ packages) │  │  assistant) │   │\n│   └───────────┘  └───────────┘  └─────────────┘   │\n│                                                   │\n│   ┌───────────────────────────────────────────┐   │\n│   │               Git / GitHub                │   │\n│   │   (version control and collaboration)     │   │\n│   └───────────────────────────────────────────┘   │\n└───────────────────────────────────────────────────┘\nPositron is your home base — the application where you write code, explore data, view plots, and manage your project files. It’s built by the makers of RStudio but designed for both R and Python.\nConda and renv are environment managers. They keep track of which packages (and which versions) each project uses, so your analysis works the same way on any computer. Conda handles Python; renv handles R. You’ll set up renv in your first project and learn conda later in Part 2.\nGit and GitHub let you track changes to your code over time and share it with collaborators. Think of Git as an unlimited undo history for your project, and GitHub as the place where that history lives online. You’ll learn these in Part 2.\nClaude Code is an AI coding assistant that integrates into Positron. It can help you write code, debug errors, explain unfamiliar functions, and plan analyses. You’ll install it in the next chapter and see it in action throughout the guide.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "part1/intro.html#what-youll-learn-in-part-1",
    "href": "part1/intro.html#what-youll-learn-in-part-1",
    "title": "1  Introduction",
    "section": "1.4 What You’ll Learn in Part 1",
    "text": "1.4 What You’ll Learn in Part 1\nAfter working through the next two chapters, you will have:\n\nInstalled Positron, R, Quarto, and Claude Code\nCreated a project with a proper folder structure\nRun a complete single-cell analysis interactively in Positron, learning the IDE along the way\nRendered your analysis into a self-contained HTML report\nUsed renv to manage your R packages\n\nThat’s enough to start working on real lab projects. Parts 2–4 will deepen your understanding of each tool and introduce version control, collaboration workflows, and more advanced techniques — but you can come back to those as you need them.\nLet’s start by installing the tools.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "part1/installation.html",
    "href": "part1/installation.html",
    "title": "2  Installation",
    "section": "",
    "text": "2.1 1. Positron\nThis chapter walks you through installing the tools you need for your first project. We’ll install more tools (Git, conda) later when you need them in Part 2.\nSeveral steps below require running commands in a terminal (also called a command line). On macOS, open the built-in Terminal app (search for “Terminal” in Spotlight). On Windows, open PowerShell from the Start menu. You’ll type or paste commands there and press Enter to run them.\nPositron is a data science IDE (Integrated Development Environment) built by the makers of RStudio. It combines the best features of RStudio, like an integrated data viewer, variable explorer, and plot pane, with the modern editing experience of VS Code. Unlike RStudio, Positron treats both R and Python equally, making it ideal for working in both languages. It’s also highly moddable, with access to the full set of VS Code extensions, including Claude Code.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#positron",
    "href": "part1/installation.html#positron",
    "title": "2  Installation",
    "section": "",
    "text": "2.1.1 macOS\n\nDownload Positron from https://positron.posit.co\nOpen the .dmg file and drag Positron to your Applications folder\nOpen Positron from Applications\n\n\n\n2.1.2 Windows\n\nDownload Positron from https://positron.posit.co\nRun the installer (.exe file)\nFollow the installation prompts\nLaunch Positron from the Start menu\n\n\n\n\n\n\n\nTipFirst Launch\n\n\n\nWhen you first open Positron, it may ask to install recommended extensions. Accept these defaults. You may also see a message in the Source Control panel (left sidebar) about Git not being installed — just ignore this for now. We’ll install Git later in Part 2.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#r-using-rig",
    "href": "part1/installation.html#r-using-rig",
    "title": "2  Installation",
    "section": "2.2 2. R (using rig)",
    "text": "2.2 2. R (using rig)\nWe install R using rig (R Installation Manager) rather than downloading directly from CRAN. Rig makes it easy to install R, switch between R versions, and keep R updated, all from the command line. Most importantly, it installs new R versions without overwriting or deleting previous versions, a common problem encountered when installing precompiled packages from the main R website. This is especially useful when you want to install the newest version of R to use with a new project while still maintaining older versions associated with older projects.\n\n\n\n\n\n\nNoteAlready have R?\n\n\n\nIf you already have R installed, you can skip rig for now — any recent version of R (4.0+) will work for this tutorial. We still recommend installing rig for future projects, because it makes managing multiple R versions painless, but it’s not required to get started.\n\n\n\n2.2.1 macOS\n\nDownload the latest rig installer from https://github.com/r-lib/rig/releases\n\nChoose the .pkg file (e.g., rig-macos-arm64.pkg for Apple Silicon or rig-macos-x86_64.pkg for Intel Macs)\n\nDouble-click the .pkg file and follow the installation prompts\n\nThen open a terminal and install the latest R version:\nrig add release\nThis installs the current stable release of R (4.5.x as of this writing). You want at least R 4.4 or newer — Positron works best with recent R versions, and newer Seurat releases require R 4.4+.\nAfter the install finishes, close and reopen your terminal, then verify the installation:\nR --version\n\n\n\n\n\n\nTiprig Commands\n\n\n\n\nrig list — See installed R versions\nrig add release — Install latest stable R\nrig add devel — Install development version\nrig default &lt;version&gt; — Set default R version\n\n\n\n\n\n2.2.2 Windows\n\nDownload the rig installer from https://github.com/r-lib/rig/releases\n\nChoose rig-windows-latest.exe\n\nRun the installer\nOpen a new PowerShell window (this is important — a fresh window picks up the new installation) and install R:\n\nrig add release\nThis installs the current stable release (4.5.x as of this writing). You want at least R 4.4 or newer.\n\nClose and reopen PowerShell, then verify:\n\nR --version\n\n\n2.2.3 Why rig?\n\nEasy updates: rig add release always gets the latest version\nMultiple versions: Install R 4.3 and R 4.4 side by side for testing\nConsistent: Same commands on macOS and Windows\n\nYou’ll learn more about managing R versions in the rig & renv chapter.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#quarto",
    "href": "part1/installation.html#quarto",
    "title": "2  Installation",
    "section": "2.3 3. Quarto",
    "text": "2.3 3. Quarto\nQuarto is a scientific publishing system that lets you combine code, results, and narrative text in a single document. You write in Markdown with embedded R or Python code chunks, and Quarto renders it to HTML, PDF, Word, or other formats—with your code output automatically included. If you’ve used R Markdown, Quarto is its successor—same core idea, but with more features and equal support for Python. This is the modern approach to reproducible research: your analysis and your report are the same document, so results stay in sync with the code that produced them. In fact, this book was built with Quarto!\n\n2.3.1 macOS\nIf you have Homebrew (a popular macOS package manager), you can install Quarto from the terminal:\nbrew install quarto\nIf you don’t have Homebrew, download the installer from https://quarto.org/docs/get-started/ instead.\nAfter installing, close and reopen your terminal, then verify:\nquarto --version\n\n\n2.3.2 Windows\nDownload and run the installer from https://quarto.org/docs/get-started/\nAfter installing, close and reopen PowerShell, then verify:\nquarto --version",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#claude-code",
    "href": "part1/installation.html#claude-code",
    "title": "2  Installation",
    "section": "2.4 4. Claude Code",
    "text": "2.4 4. Claude Code\nClaude Code is an AI coding assistant that runs in your terminal or integrates directly into Positron. Unlike chat-based AI tools, Claude Code can read and write files in your project, run commands, and help you build and debug code interactively. It understands context from your entire codebase, making it useful for writing code, explaining unfamiliar code, debugging errors, and planning larger projects. Think of it as a knowledgeable collaborator who’s always available.\n\n2.4.1 Prerequisites\nYou need Node.js 18+ installed. In your terminal:\nmacOS (using Homebrew):\nbrew install node\nWindows: Download and install from https://nodejs.org (choose the LTS version). After installing, close and reopen PowerShell. If you get a “running scripts is disabled” error in the next step, see the fix below.\n\n\n2.4.2 Install Claude Code\nIn your terminal, run:\nnpm install -g @anthropic-ai/claude-code\n\n\n2.4.3 Authenticate\nRun Claude Code once to set up authentication:\nclaude\nClaude Code will ask how you want to authenticate. You’ll see several options — make sure you choose Use OAuth (Anthropic account), not “Use an API key.” The API key option connects to a separate pay-per-use billing system, which is not what you want. OAuth connects to your existing Claude Pro subscription at no extra cost.\nThis will open a browser window where you log in with your Anthropic account — the same email and password you use for claude.ai. Once you approve the connection in the browser, Claude Code is ready to use in the terminal. If you accidentally chose the API key option, run claude logout and then claude again to pick OAuth.\n\n\n\n\n\n\nNoteAnthropic Account\n\n\n\nYou need a Claude Pro or Max subscription to use Claude Code. All lab members have personal subscriptions — if yours isn’t set up yet, ask Jake.\n\n\n\n\n2.4.4 Install the Positron Extension\nClaude Code integrates directly into Positron as an extension:\n\nOpen Positron\nGo to the Extensions view (Cmd+Shift+X on macOS, Ctrl+Shift+X on Windows)\nSearch for “Claude Code”\nClick Install\n\nYou’ll see a Claude Code panel in Positron’s sidebar. You can use it right alongside your code editor, console, and plots pane.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#verification-checklist",
    "href": "part1/installation.html#verification-checklist",
    "title": "2  Installation",
    "section": "2.5 Verification Checklist",
    "text": "2.5 Verification Checklist\nOpen a fresh terminal window and run these commands to verify everything is installed:\nR --version\nquarto --version\nclaude --version\nAll commands should return version numbers without errors. Open Positron and confirm it launches.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can help troubleshoot installation problems by checking your paths, versions, and configuration.\n\nI just installed R and Quarto. Here’s what I get when I run the version commands: [paste your output]. Does this look right, or is something misconfigured?\n\nClaude will check that paths are correct, versions are compatible, and flag common installation issues like missing PATH entries or conflicting installations.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#troubleshooting",
    "href": "part1/installation.html#troubleshooting",
    "title": "2  Installation",
    "section": "2.6 Troubleshooting",
    "text": "2.6 Troubleshooting\nIf you run into problems, check the solutions below before moving on. See Troubleshooting for additional common issues.\n\n2.6.1 “Command not found” errors\nIf any command fails with “command not found” (macOS) or “is not recognized” (Windows), try opening a new terminal window. Newly installed tools often aren’t available until you start a fresh terminal session.\n\n\n2.6.2 Windows: “Running scripts is disabled on this system”\nIf you see this error when running npm install on Windows:\nnpm : File C:\\Program Files\\nodejs\\npm.ps1 cannot be loaded because running\nscripts is disabled on this system.\nWindows PowerShell blocks scripts by default. You need to change the execution policy:\n\nOpen PowerShell as Administrator — search for “PowerShell” in the Start menu, right-click it, and select Run as administrator\nRun this command:\n\nSet-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned\n\nType Y and press Enter to confirm\n\nThis allows locally created scripts (like npm) to run while still requiring downloaded scripts to be signed. After this, close the administrator PowerShell and open a regular PowerShell window to continue the installation.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/installation.html#what-about-git-conda-and-github",
    "href": "part1/installation.html#what-about-git-conda-and-github",
    "title": "2  Installation",
    "section": "2.7 What About Git, Conda, and GitHub?",
    "text": "2.7 What About Git, Conda, and GitHub?\nYou’ll install these later when you need them:\n\nConda (Python environments) — installed in the Conda chapter\nGit (version control) — installed in the Git & GitHub chapter\nGitHub account — set up in the Setting Up a Lab Project walkthrough\n\nFor now, you have everything you need. Let’s build your first project.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Installation</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html",
    "href": "part1/first-project.html",
    "title": "3  Your First R Project",
    "section": "",
    "text": "3.1 Create a Project Folder\nIn this chapter, you’ll do a real single-cell RNA-seq analysis—from raw count data to identified cell types. Along the way, you’ll learn how to use Positron’s key features: the file explorer, console, environment pane, plots pane, and interactive code execution. By the end, you’ll render the analysis into a shareable HTML report.\nWe’ll work with a single-cell RNA-seq dataset from the freshwater sponge Spongilla lacustris, one of the organisms studied in the Musser Lab. The dataset contains about 10,000 cells across 4 samples. Don’t worry about understanding every biological detail—focus on learning how Positron works and getting comfortable running R code interactively. We’ll teach some biology along the way too.\nFirst, create a folder for this project and open it in Positron.\nPositron now treats this folder as your workspace. Everything you do—running code, browsing files, managing packages—happens relative to this folder.\nTake a moment to look around the Positron interface:",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#create-a-project-folder",
    "href": "part1/first-project.html#create-a-project-folder",
    "title": "3  Your First R Project",
    "section": "",
    "text": "Open Positron\nGo to File → Open Folder\nNavigate to where you want to keep projects (e.g., ~/Documents)\nClick New Folder, name it my-first-analysis, then open it\n\n\n\n\nFile Explorer (left sidebar): Shows files and folders in your project. Right now it’s empty.\nConsole (bottom panel): Where your R session will run. You may need to start one—click “Start R Session” in the status bar at the bottom if you don’t see an R prompt.\nEnvironment pane (right panel, or bottom panel next to Console): Will show R objects as you create them. Look for the “Variables” tab.\nPlots pane: Will appear when you make your first plot.\n\n\n\n\nPositron with an empty project open",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#install-packages-with-renv",
    "href": "part1/first-project.html#install-packages-with-renv",
    "title": "3  Your First R Project",
    "section": "3.2 Install Packages with renv",
    "text": "3.2 Install Packages with renv\nBefore we can analyze data, we need to install some R packages. We’ll use renv to manage packages for this project—renv gives each project its own package library, so installing or updating packages here won’t affect your other projects.\nIn the R console, type (or paste) and press Enter:\ninstall.packages(\"renv\")\nrenv::init()\nWhen renv::init() finishes, it will ask you to restart R. Do this—in Positron, you can restart by clicking the power icon in the Console toolbar, or pressing Cmd+Shift+0 (Ctrl+Shift+0 on Windows). Restarting is necessary because renv modifies your .Rprofile to activate itself when R starts, and that only takes effect after a restart.\nAfter restarting, look at the file explorer: you should now see renv/ and renv.lock appear. The console should also show a message like “renv activated” confirming it’s working.\nThe lock file (renv.lock) is a snapshot of every package installed in your project, including exact version numbers. This is what makes your analysis reproducible—a collaborator (or future you) can run renv::restore() on another machine to install the exact same package versions. You’ll learn more about renv in the renv chapter.\nNow install the packages we need. We use renv::install() rather than install.packages() because it understands how to install packages from multiple sources—CRAN, Bioconductor, and GitHub:\nrenv::install(c(\"Seurat\", \"leidenbase\", \"ggplot2\", \"patchwork\", \"dplyr\", \"here\"))\nThis takes a few minutes—Seurat has many dependencies. The leidenbase package is needed for the Leiden clustering algorithm we’ll use later. Watch the console output as packages download and compile. When it’s done, save the state:\nrenv::snapshot()\n\n\n\n\n\n\nNoterenv::install() and Bioconductor\n\n\n\nrenv::install() is the standard way to install packages in an renv project. For CRAN packages, just use the package name: renv::install(\"Seurat\"). For Bioconductor packages (common in genomics—DESeq2, SingleCellExperiment, etc.), prefix with bioc:::\nrenv::install(\"bioc::DESeq2\")\nAfter installing, always run renv::snapshot() to record the new packages in your lock file.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#get-the-data-and-analysis-script",
    "href": "part1/first-project.html#get-the-data-and-analysis-script",
    "title": "3  Your First R Project",
    "section": "3.3 Get the Data and Analysis Script",
    "text": "3.3 Get the Data and Analysis Script\nWe need two things: the Spongilla count matrix and the analysis script you’ll run through. Both are in the book’s GitHub repository.\n\n3.3.1 Download from GitHub\nThe example data and scripts live in the examples/ folder of the lab-compute repository. The repository’s README has a description of what’s available — you need two things from it:\n\nThe Spongilla count matrix — in examples/data/spongilla_counts/ (three files)\nThe analysis script — examples/scripts/01_seurat_basics.qmd\n\nThe easiest way to get them is to download the whole repository as a ZIP file:\n\nGo to github.com/MusserLab/lab-compute\nClick the green Code button, then Download ZIP\nUnzip the downloaded file — you’ll find an examples/ folder inside\n\nNow create the project folders and copy the files in. Open a terminal in your project folder (in Positron: Terminal → New Terminal, or Cmd+` / Ctrl+`).\nmacOS:\nmkdir -p data scripts outs\ncp -r ~/Downloads/lab-compute-main/examples/data/spongilla_counts data/\ncp ~/Downloads/lab-compute-main/examples/scripts/01_seurat_basics.qmd scripts/\nWindows PowerShell:\nmkdir data, scripts, outs\nCopy-Item -Recurse ~\\Downloads\\lab-compute-main\\examples\\data\\spongilla_counts data\\\nCopy-Item ~\\Downloads\\lab-compute-main\\examples\\scripts\\01_seurat_basics.qmd scripts\\\nOr do it by hand: create data/, scripts/, and outs/ folders in Positron’s File Explorer (right-click → New Folder), then drag the files from the unzipped download into the right places.\n\n\n\n\n\n\nTipThe outs/ folder\n\n\n\nThe outs/ folder is empty for now — you’ll use it later when rendering the analysis to HTML. In the lab we keep script outputs separate from source code so things stay organized.\n\n\n\n\n3.3.2 What you should have\nYour project should now look like this:\nmy-first-analysis/\n├── data/\n│   └── spongilla_counts/\n│       ├── barcodes.tsv.gz        # One barcode per cell\n│       ├── features.tsv.gz        # One row per gene\n│       └── matrix.mtx.gz          # The sparse count matrix\n├── scripts/\n│   └── 01_seurat_basics.qmd      # The analysis you'll run\n├── outs/                          # Will hold script outputs\n├── renv/\n├── renv.lock\n└── .Rprofile\nThe three files in spongilla_counts/ are the standard 10X Genomics format—the same format you’ll get when analyzing your own single-cell data from a sequencing core. The barcodes file has one entry per cell, the features file lists every gene, and the matrix file stores the actual counts in a compressed sparse format (most gene-cell combinations are zero, so this saves a lot of space).\nLook at the file explorer now. You can click into folders to browse their contents. Click into data/spongilla_counts/ to see the three files.\n\n\n\nFile explorer showing the project structure",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#open-the-analysis-script",
    "href": "part1/first-project.html#open-the-analysis-script",
    "title": "3  Your First R Project",
    "section": "3.4 Open the Analysis Script",
    "text": "3.4 Open the Analysis Script\nOpen scripts/01_seurat_basics.qmd by clicking on it in the file explorer.\nThis is a Quarto document (.qmd)—the format we use for analyses in the lab. If you’ve used RMarkdown before, Quarto is its successor: it has the same idea of mixing code and narrative, but with more features and equal support for both R and Python. When you render a .qmd, all the code runs and the results are woven into an HTML report.\n\n\n\nThe QMD file open in the editor\n\n\nLook at the structure of the file. There are three kinds of content:\nThe YAML header is the block between --- marks at the top. It controls metadata—title, author, date—and rendering options like output format and whether to show code. You’ll see comments (lines starting with #) explaining what each option does. The YAML header is the first thing Quarto reads when rendering.\nMarkdown text is the written explanation between code chunks. Markdown is a lightweight formatting language: **bold** for bold, *italic* for italic, ## for section headings, and [link text](url) for hyperlinks. The Quarto document itself has a brief Markdown introduction at the top—read through it to get oriented.\nCode chunks are blocks starting with ```{r} and ending with ```. Each chunk has options on lines starting with #|. The most important is #| label: which gives the chunk a name. Other options control things like figure captions (#| fig-cap:) and figure dimensions. The first chunk in the script has comments explaining common chunk options.\nWe’re going to run through this script chunk by chunk, interactively. This is how you’ll develop analyses in the lab—running code, inspecting results, and iterating before rendering the final report.\n\n\n\n\n\n\nTipCmd+Enter: Your Most-Used Shortcut\n\n\n\nCmd+Enter (Ctrl+Enter on Windows) runs the current line or selection in the R console. Cmd+Shift+Enter runs the entire code chunk. You’ll use these constantly during interactive development.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-1-load-libraries",
    "href": "part1/first-project.html#step-1-load-libraries",
    "title": "3  Your First R Project",
    "section": "3.5 Step 1: Load Libraries",
    "text": "3.5 Step 1: Load Libraries\nFind the first code chunk (labeled setup) and place your cursor inside it. Press Cmd+Shift+Enter to run the entire chunk.\nlibrary(Seurat)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(dplyr)\nlibrary(here)\nWatch the console at the bottom—you’ll see library loading messages appear there. The code runs in the console, not in the document. This is interactive execution: you’re exploring and developing, running code chunk by chunk, checking results as you go.\n\n\n\nConsole showing library loading messages",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-2-load-the-count-matrix",
    "href": "part1/first-project.html#step-2-load-the-count-matrix",
    "title": "3  Your First R Project",
    "section": "3.6 Step 2: Load the Count Matrix",
    "text": "3.6 Step 2: Load the Count Matrix\nRun the next chunk (load-data). This loads the 10X count matrix and creates a Seurat object—the central data structure for single-cell analysis in R. It stores the count matrix, cell metadata, dimensionality reductions, and clustering results all in one container.\ncounts &lt;- Read10X(data.dir = here(\"data/spongilla_counts\"))\nsponge &lt;- CreateSeuratObject(counts = counts, project = \"spongilla\")\nsponge\nTwo things to notice:\n\nThe console prints a summary of the Seurat object: the number of genes (features) and cells (samples) in the dataset.\nThe environment pane (Variables tab) now shows two objects: counts (a sparse matrix) and sponge (a Seurat object). You can see the object type and size at a glance.\n\n\n\n\nEnvironment pane showing the counts and sponge objects\n\n\nNow let’s inspect the cell metadata. Run the peek-metadata chunk—it uses head() to print the first few rows of the metadata table to the console. That’s useful for a quick look, and it’s what we use in the script because head() works when the document is rendered to HTML later.\nBut for interactive exploration, try typing this directly in the console:\nView(sponge@meta.data)\nThis opens Positron’s data viewer—a spreadsheet-style view of the metadata, with one row per cell. View() only works interactively (it opens a GUI pane), which is why the script uses head() instead. You’ll see three columns:\n\norig.ident — which sample the cell came from\nnCount_RNA — total UMI counts per cell (how much RNA was captured)\nnFeature_RNA — number of distinct genes detected per cell\n\nNotice two useful features of the data viewer:\n\nColumn histograms: Each numeric column shows a small histogram at the top, giving you a quick summary of the distribution. You can immediately see the range and shape of nCount_RNA and nFeature_RNA without making a plot.\nFiltering: Click on a column header to filter rows. For example, you could filter nFeature_RNA to only show cells with more than 1,000 detected genes. This is useful for quickly exploring subsets of your data.\n\n\n\n\nData Viewer showing Seurat metadata with column histograms",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-3-quality-control",
    "href": "part1/first-project.html#step-3-quality-control",
    "title": "3  Your First R Project",
    "section": "3.7 Step 3: Quality Control",
    "text": "3.7 Step 3: Quality Control\nRun the next chunk (fig-qc-violin). This creates violin plots of two key QC metrics:\nVlnPlot(sponge, features = c(\"nFeature_RNA\", \"nCount_RNA\"), ncol = 2)\nYour first plot appears in the Plots pane! The violin plots show the distribution of genes and UMI counts across all cells. You can resize the Plots pane by dragging its border, and use the navigation arrows to flip between plots as you make more.\n\n\n\nQC violin plots in the Plots pane\n\n\nHere’s what to look for in these plots:\nnCount_RNA (total UMI counts) varies naturally by cell type. Large cells or transcriptionally active cells capture more RNA, so higher counts don’t necessarily mean better quality. On the other hand, very high counts can indicate doublets—droplets that accidentally captured two cells during the 10X run, giving them roughly double the expected RNA content. Very low counts suggest empty droplets or dead cells.\nnFeature_RNA (genes detected) gives a sense of library complexity. A cell with very few detected genes may not have been captured well. Differences between samples are normal and can reflect both biology and technical variation.\nThis dataset has already been quality-filtered, so the distributions should look clean.\n\n\n\n\n\n\nTipPop Out the Plots Pane\n\n\n\nIf you want a larger view of a plot, you can pop the Plots pane out into a separate window. Click the pop-out icon in the top-right corner of the Plots pane. This is especially useful for complex plots where you want to see fine detail.\n\n\n\n\n\n\n\n\nNoteQC Filtering in Practice\n\n\n\nWith raw, unfiltered data, you’d typically remove obvious junk cells—those with extremely low gene counts or extremely high counts that suggest doublets. But in practice, many experienced analysts set only very lenient thresholds at this stage, or none at all. The reason is that clustering itself is a powerful QC tool: cells with low-quality profiles often group together into their own “junk clusters” that you can remove later, after seeing how cells actually behave. This is more nuanced than applying hard cutoffs upfront, because some cells with low RNA counts are perfectly real (they’re just small or quiescent cells), and hard thresholds would throw them out.\nPrograms like DoubletFinder can also identify likely doublets computationally, which is more principled than a simple nCount_RNA threshold.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-4-normalize-and-find-variable-features",
    "href": "part1/first-project.html#step-4-normalize-and-find-variable-features",
    "title": "3  Your First R Project",
    "section": "3.8 Step 4: Normalize and Find Variable Features",
    "text": "3.8 Step 4: Normalize and Find Variable Features\nRun the normalize chunk. This does two things.\n\n3.8.1 Normalization\nNormalizeData() adjusts for differences in sequencing depth between cells. It divides each cell’s gene counts by the cell’s total UMI count to get relative expression levels, then applies a log transformation. The log transformation addresses heteroscedasticity: without it, highly expressed genes would have much higher variance than lowly expressed genes, dominating downstream analyses.\nA word of caution: it’s often stated that differences in total RNA per cell are purely technical artifacts of sequencing depth. That can be true when comparing closely related cell types. But in whole-organism datasets like this one—where cells range from tiny pinacocytes to large, transcriptionally active archaeocytes—differences in total RNA abundance are genuinely biological. Normalization can flatten out real biology in these cases. This step is a useful default, but not a biological law.\nNot all methods even require this step. Casey Dunn and colleagues have developed approaches that work directly in count space, avoiding the assumptions baked into log-normalization. As you gain experience, it’s worth understanding what normalization does and when alternatives might be more appropriate.\nsponge &lt;- NormalizeData(sponge)\nsponge &lt;- FindVariableFeatures(sponge, selection.method = \"vst\", nfeatures = 2000)\n\n\n3.8.2 Variable features\nFindVariableFeatures() identifies the 2,000 genes whose expression varies most across cells. The idea is that genes expressed at similar levels in every cell don’t have much to say about the structure of the data—they won’t help distinguish cell types. By focusing on the most variable genes, the downstream analysis is more efficient and less noisy.\nThis is a reasonable heuristic, but it’s not the only approach. Methods like SAM (Self-Assembling Manifolds) take a different tack: they use all genes but weight them by how informative they are for finding structure, rather than discarding genes outright. The “select top 2,000 variable features” convention is one way to do this, not the only way.\nNow run the fig-variable-features chunk to visualize the results:\ntop10 &lt;- head(VariableFeatures(sponge), 10)\n\nplot1 &lt;- VariableFeaturePlot(sponge)\nplot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE)\nplot2\nA new plot appears in the Plots pane showing genes ranked by variability. The labeled points are the top 10 most variable genes. Use the navigation arrows in the Plots pane to flip between this plot and the earlier violin plot.\n\n\n\nVariable features plot with top genes labeled",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-5-scale-data-and-run-pca",
    "href": "part1/first-project.html#step-5-scale-data-and-run-pca",
    "title": "3  Your First R Project",
    "section": "3.9 Step 5: Scale Data and Run PCA",
    "text": "3.9 Step 5: Scale Data and Run PCA\nRun the scale-pca chunk:\nsponge &lt;- ScaleData(sponge)\nsponge &lt;- RunPCA(sponge)\nScaling shifts each gene to have mean 0 and variance 1. Together with the log normalization from the previous step, this ensures that both lowly and highly expressed genes contribute equally to the analysis. PCA (Principal Component Analysis) then reduces the data from thousands of genes down to a smaller number of dimensions (principal components) that capture the main axes of variation.\n\n\n\n\n\n\nNoteA Note on Methods\n\n\n\nScaling followed by PCA is the standard Seurat workflow and a reasonable starting point for most datasets. Other approaches exist—for example, SAM (Self-Assembling Manifolds) skips the variable feature selection and PCA steps entirely and can work well, particularly for complex datasets. The Seurat pipeline is one well-established starting point, but it’s worth knowing that alternatives exist and may be better suited to your particular data.\n\n\nNow run the fig-elbow chunk to see the elbow plot:\nElbowPlot(sponge, ndims = 50)\nThe elbow plot shows how much variation each PC explains. We need to choose how many PCs to use for clustering. The “elbow”—where the curve flattens—gives a rough guide, but in practice we often include more PCs than the elbow alone might suggest. The reason: later PCs can capture variation from rare cell types that would be missed with too few dimensions. Using too few PCs has a real cost—clusters that should be separate may merge together, and you’ll miss biology. We’ll use 40 PCs for this dataset, which is deliberately generous.\n\n\n\nElbow plot in the Plots pane",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-6-cluster-cells",
    "href": "part1/first-project.html#step-6-cluster-cells",
    "title": "3  Your First R Project",
    "section": "3.10 Step 6: Cluster Cells",
    "text": "3.10 Step 6: Cluster Cells\nRun the cluster chunk. This is the most computationally intensive step—it takes a moment.\nsponge &lt;- FindNeighbors(sponge, dims = 1:40)\nsponge &lt;- FindClusters(sponge, resolution = 2, algorithm = 4)\nsponge &lt;- RunUMAP(sponge, dims = 1:40)\nThree things happen here:\n\nFindNeighbors builds a graph connecting cells with similar expression profiles (using the first 40 PCs).\nFindClusters uses the Leiden algorithm to find communities of similar cells in that graph.\nRunUMAP projects the high-dimensional relationships into two dimensions for visualization.\n\nWhen it finishes, check the environment pane—the sponge object now contains clustering results and UMAP coordinates. Run View(sponge@meta.data) again to see a new seurat_clusters column in the metadata.\n\n\n\n\n\n\nNoteClustering Parameters\n\n\n\n\ndims = 1:40 — uses the first 40 PCs. We deliberately include more than the elbow suggests to catch rare cell types.\nresolution = 2 — higher values produce more clusters. The right resolution depends on how many cell types you expect and how finely you want to split them.\nalgorithm = 4 — Leiden algorithm, which generally produces more robust clusters than the default Louvain (algorithm = 1).",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-7-visualize-with-umap",
    "href": "part1/first-project.html#step-7-visualize-with-umap",
    "title": "3  Your First R Project",
    "section": "3.11 Step 7: Visualize with UMAP",
    "text": "3.11 Step 7: Visualize with UMAP\nRun the fig-umap chunk:\nDimPlot(sponge, reduction = \"umap\", label = TRUE) + NoLegend()\nThe UMAP is one of many ways to look at single-cell data. Each dot is a cell, colored by cluster, and cells that are close together have similar gene expression. It’s a useful 2D summary of high-dimensional relationships, but it’s important not to over-interpret distances or shapes—UMAP is a visualization tool, not an analysis endpoint. The real work is figuring out what each cluster is, which we’ll do next.\n\n\n\nUMAP with cluster labels",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-8-explore-gene-expression",
    "href": "part1/first-project.html#step-8-explore-gene-expression",
    "title": "3  Your First R Project",
    "section": "3.12 Step 8: Explore Gene Expression",
    "text": "3.12 Step 8: Explore Gene Expression\nRun the fig-features chunk:\nFeaturePlot(sponge, features = c(\"Eef1a1 A\", \"Pcna\"))\nThis overlays gene expression onto the UMAP—each cell is colored by how strongly it expresses that gene. Eef1a1 is an elongation factor that marks archaeocytes (the stem cell-like cells of sponges), and Pcna is a proliferation marker (it labels cells that are actively dividing). Notice how expression is concentrated in specific clusters, not spread uniformly. This is what makes these genes useful as markers for identifying cell types.\n\n\n\nFeaturePlot of Eef1a1 A and Pcna",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#step-9-identify-cell-types",
    "href": "part1/first-project.html#step-9-identify-cell-types",
    "title": "3  Your First R Project",
    "section": "3.13 Step 9: Identify Cell Types",
    "text": "3.13 Step 9: Identify Cell Types\nNow the interesting part: figuring out what each cluster actually is. There are two complementary approaches, and you’ll typically use both.\n\n3.13.1 Approach 1: Unbiased differential expression\nWe can ask which genes are most enriched in a given cluster compared to all other cells. This is unbiased—we let the data tell us what’s distinctive about a cluster without assuming anything in advance.\nRun the de-cluster1 chunk to find markers for the largest cluster (cluster 1):\nmarkers_c1 &lt;- FindMarkers(sponge, ident.1 = 1, min.pct = 0.25)\nhead(markers_c1, 20)\nThe output shows genes ranked by statistical significance, with columns for log fold-change, detection rates, and adjusted p-values. Scroll through the top genes and look for patterns—are there gene families that keep coming up?\nNow run the fig-dotplot-c1 chunk to visualize these markers across all clusters:\ntop_genes &lt;- rownames(head(markers_c1, 15))\nDotPlot(sponge, features = top_genes, scale = F, cols = \"RdBu\") + RotatedAxis() + coord_flip()\nIn the dot plot, dot size shows what fraction of cells in each cluster express the gene, and dot color shows average expression level. Look for genes that are strongly expressed in cluster 1 but absent or low in most other clusters.\n\n\n\nDot plot of top markers for cluster 1\n\n\nYou’ll see ribosomal genes (names starting with Rpl or Rps) dominating the top markers. This signature—high ribosomal gene expression indicating active protein synthesis—is characteristic of archaeocytes. Archaeocytes are the stem cell-like cells of sponges, and similar transcriptional profiles mark stem cells in many invertebrates.\n\n\n3.13.2 Approach 2: Candidate genes\nThe complementary strategy is to take genes you already know something about and look at where they’re expressed. This is the candidate gene approach.\nPiwi genes are highly conserved markers of stem cells and germline across animals. If archaeocytes are truly stem cell-like, they should express Piwi. Run the find-piwi chunk to search for it:\ngrep(\"iwi\", rownames(sponge), value = TRUE, ignore.case = TRUE)\nThis is a useful trick—when you don’t know the exact gene name in a dataset, grep() lets you search by partial match. You should see Piwil2 and Piwil1/3/4 in the results. Now run the fig-piwi chunk to see where Piwil2 is expressed:\np1 &lt;- VlnPlot(sponge, features = \"Piwil2\", pt.size = 0.1)\np2 &lt;- FeaturePlot(sponge, features = \"Piwil2\")\np1 + p2\nThe VlnPlot shows which clusters express Piwil2 most strongly. The FeaturePlot shows where those cells sit on the UMAP. If Piwil2 expression is concentrated in the same cluster that showed the ribosomal signature in the DE analysis, that’s convergent evidence: two independent approaches pointing to the same biological identity.\n\n\n\nPiwi expression — VlnPlot and FeaturePlot\n\n\nThis two-pronged strategy—unbiased differential expression to discover what’s distinctive, plus candidate genes to confirm identity—is a standard approach for annotating clusters in single-cell data.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#render-the-document",
    "href": "part1/first-project.html#render-the-document",
    "title": "3  Your First R Project",
    "section": "3.14 Render the Document",
    "text": "3.14 Render the Document\nSo far you’ve been running code interactively—chunk by chunk, with results appearing in the console, environment pane, and plots pane. This is how you develop and explore.\nNow let’s render the document. Rendering runs every code chunk in a fresh R session from top to bottom, and produces a polished HTML report. This is important because:\n\nIt proves the analysis is reproducible—it runs start to finish without relying on objects you created interactively\nIt catches errors you might miss during interactive development (like relying on a variable you defined in the console but forgot to include in the script)\nIt produces a shareable document with all code, results, and narrative together\n\nOpen the terminal (Cmd+` or Ctrl+`) and run:\nquarto render scripts/01_seurat_basics.qmd\nmkdir -p outs/01_seurat_basics\nmv scripts/01_seurat_basics.html outs/01_seurat_basics/\nThe first command renders the document—Quarto re-executes all your R code from scratch. Then we move the HTML output into the outs/ folder, following the lab convention of keeping script outputs separate from source code. In Part 2, you’ll learn about additional conventions for this folder—like BUILD_INFO.txt files that track which code version produced each output—but for now, just getting the output into the right place is enough. When it finishes, open outs/01_seurat_basics/01_seurat_basics.html in your browser to see the full analysis as a formatted report—code, plots, and your written explanations all together.\n\n\n\nThe rendered HTML report in a browser\n\n\n\n\n\n\n\n\nTipInteractive vs. Rendering\n\n\n\nDuring development, work interactively—run chunks, inspect objects, iterate. When you’re satisfied, render to confirm everything runs cleanly and to produce the final report. If rendering fails, the error messages tell you where the problem is.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#what-youve-learned",
    "href": "part1/first-project.html#what-youve-learned",
    "title": "3  Your First R Project",
    "section": "3.15 What You’ve Learned",
    "text": "3.15 What You’ve Learned\nYou’ve now used all of Positron’s key features:\n\n\n\n\n\n\n\nFeature\nWhat you used it for\n\n\n\n\nFile Explorer\nBrowsing project files, seeing data and output structure\n\n\nConsole\nRunning R code interactively, seeing output and messages\n\n\nEnvironment pane\nInspecting R objects—their types, sizes, and contents\n\n\nData Viewer\nExamining cell metadata with filtering and column histograms\n\n\nPlots pane\nViewing violin plots, UMAP, feature plots, dot plots (with pop-out)\n\n\nTerminal\nRunning quarto render to produce the HTML report\n\n\n\nAnd you’ve run a single-cell analysis from start to finish:\n\nLoaded a 10X count matrix into a Seurat object\nInspected QC metrics to check data quality across samples\nNormalized and identified highly variable genes\nScaled, ran PCA, and chose dimensions with an elbow plot\nClustered cells with the Leiden algorithm\nVisualized clusters on a UMAP and explored gene expression\nIdentified cell types using both unbiased differential expression and candidate gene markers\n\nThis is the starting point for single-cell analysis in the lab. The tools and workflow you’ve practiced here—interactive development in Positron, Quarto for reproducible reports, Seurat for analysis—are what you’ll use for your own projects.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#try-claude-code",
    "href": "part1/first-project.html#try-claude-code",
    "title": "3  Your First R Project",
    "section": "3.16 Try Claude Code",
    "text": "3.16 Try Claude Code\nYou installed Claude Code in the previous chapter. Now that you have a real project with real data, try it out. Open the Claude Code panel in Positron’s sidebar (or run claude in the terminal).\nSponges don’t have canonical muscles, but the flat epithelial cells covering the sponge surface—pinacocytes—have been described to express muscle-related genes like myosins. Let’s explore this with Claude Code:\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can read your project files, understand your analysis, and write R code in context.\n\nI’m analyzing Spongilla single-cell data with Seurat. Can you find all myosin genes in the dataset (search for “Myh” and “Myl” in the gene names) and make FeaturePlots and VlnPlots for any that show interesting expression patterns? The Seurat object is called sponge.\n\nClaude will search the gene names in your Seurat object, identify the myosin genes present, check their expression patterns, and create plots of the ones that show cluster-specific expression—all without you needing to write the R code yourself.\n\n\nTry the prompts in these orange boxes as you encounter them throughout the book—Claude Code works best when you give it specific context about what you’re working on.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part1/first-project.html#whats-next",
    "href": "part1/first-project.html#whats-next",
    "title": "3  Your First R Project",
    "section": "3.17 What’s Next",
    "text": "3.17 What’s Next\n\nPart 2 dives deeper into each tool: the Positron chapter covers more features and keyboard shortcuts, the Quarto chapter covers document syntax and options, and the Project Organization chapter explains the lab’s conventions for structuring projects.\nThe Workflows section shows how to set up a full lab project with Git, conda, proper folder structure, and GitHub—the production infrastructure you’ll use for real analyses.",
    "crumbs": [
      "Quick Start",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Your First R Project</span>"
    ]
  },
  {
    "objectID": "part2/positron.html",
    "href": "part2/positron.html",
    "title": "4  Positron",
    "section": "",
    "text": "4.1 Why Positron?\nIn Your First R Project, you used Positron to run a single-cell analysis — writing code in the editor, executing it in the console, inspecting objects in the Variables pane, and viewing plots as they appeared. You got things working, but you were probably focused on the biology and the R code, not on Positron itself. This chapter fills in the gaps: what all those panels actually are, how to manage multiple sessions, what to do when something disappears, and the habits that make daily work smoother.\nPositron is your home base. It’s where you write code, explore data, run analyses, and manage your project — all in one window. Built by Posit (the company behind RStudio) on top of VS Code, Positron combines the familiarity of RStudio with the power and extensibility of a modern code editor. If you’ve used VS Code before, Positron will feel very familiar — it adds data science features (console, variables, data viewer, plots) on top of the VS Code foundation.\nIf you’re coming from RStudio, Positron will feel familiar: there’s an R console, a variable explorer, a data viewer, and a file browser. But Positron adds capabilities that matter for modern data science workflows.\nFirst-class support for both R and Python. Most lab projects use both languages. In RStudio, Python support is an afterthought. In Positron, both languages are treated equally — you can have R and Python sessions running side by side, each with its own console and environment viewer. In practice, we usually write one language per script (.qmd file), and Positron handles switching between them seamlessly.\nA superior Data Viewer. Click any dataframe in the Variables pane and it opens in a fast, interactive viewer. You can sort columns, filter rows, and search for values. For large datasets, it handles millions of rows smoothly. The Data Viewer is central to exploratory analysis — you’ll use it constantly.\nThe VS Code extension ecosystem. Positron inherits thousands of extensions: linters, formatters, Git tools, AI coding assistants. Unlike RStudio, which exists in its own world, Positron connects you to the broader developer tooling ecosystem.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#why-positron",
    "href": "part2/positron.html#why-positron",
    "title": "4  Positron",
    "section": "",
    "text": "4.1.1 RStudio → Positron Translation\nIf you’re coming from RStudio, here are the key conceptual shifts:\n\n\n\n\n\n\n\n\nRStudio concept\nPositron concept\nWhat changes?\n\n\n\n\n“Project” (.Rproj)\nOpen Folder / Workspace\nThe folder is the unit of work; you open it as a workspace.\n\n\nR console\nR console\nStill an R process, but integrated with a broader editor/terminal model.\n\n\nPython integration\nPython interpreter + (sometimes) kernel\nYou must be explicit about which Python environment is used for scripts/notebooks.\n\n\nR package library\nrenv\nPackages are pinned per project; do not rely on global R libraries.\n\n\n“Environment pane”\nvariable viewers + terminal + notebooks\nDifferent UI, same goals.\n\n\n\n[TODO: screenshot of Positron interface with labeled panes]",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#the-bottom-panel-console-terminal-and-variables",
    "href": "part2/positron.html#the-bottom-panel-console-terminal-and-variables",
    "title": "4  Positron",
    "section": "4.2 The Bottom Panel: Console, Terminal, and Variables",
    "text": "4.2 The Bottom Panel: Console, Terminal, and Variables\nThe bottom of the Positron window is where most of the interactive work happens. It contains tabs for your language consoles, system terminals, and the Variables pane. Understanding what each of these is — and when to use which — saves a lot of confusion.\n\n4.2.1 Console vs Terminal\nThese are the two most important tabs in the bottom panel, and they do fundamentally different things.\nThe Console is your R or Python session. When you press Cmd+Enter (macOS) or Ctrl+Enter (Windows) to run code from the editor, it executes here. This is where you see R output, error messages, and package loading messages. In Your First R Project, every time you ran a code chunk, the results appeared in the Console.\nThe Terminal is a system shell — the same thing as Terminal.app on macOS or PowerShell on Windows, but built into Positron. It opens automatically at the top level of your project folder, so you’re always in the right place to run commands. You use it for bash or shell commands: running git, activating conda environments, rendering Quarto documents, or anything else you’d normally do at a command line. Some of these tasks can also be done through Positron’s GUI (like Git through the Source Control panel), but the terminal is always available as a fallback.\nThe key distinction: R and Python code goes in the Console. Shell commands go in the Terminal. If Claude Code tells you to run conda activate my-project, that goes in the Terminal. If it tells you to run library(Seurat), that goes in the Console. Mixing them up is a common source of confusing errors — you’ll get “command not found” if you type a shell command into the R console, or a syntax error if you type R code into the terminal.\n\n\n\n\n\n\nNoteWindows Users: Terminal Differences\n\n\n\nOn macOS, the integrated terminal runs a Unix shell (zsh or bash). On Windows, it runs PowerShell by default. Most commands in this book work the same way, but a few common differences trip people up:\n\nDirectory listing: ls works in both, but PowerShell’s ls is an alias for Get-ChildItem and behaves slightly differently\nFile paths: Use backslashes (\\) in PowerShell, or forward slashes (/) which also work in most contexts\nConda activation: If conda activate doesn’t work, you may need to run conda init powershell first and restart (see the Conda chapter)\n\nWhen in doubt, commands shown in this book with default code blocks work on both platforms unless otherwise noted.\n\n\n[TODO: screenshot showing Console and Terminal tabs in the bottom panel]\n\n\n4.2.2 Managing Multiple Sessions\nAs you work, the bottom panel accumulates tabs. You might have an R console, a Python console, and two or three terminals open at once. Each appears as a labeled tab — “R”, “Python”, “Terminal”, “zsh”, and so on. Click a tab to switch to that session.\nThe + button in the bottom panel creates new terminals. Language consoles appear when you start a session — either by running code in a .qmd file or by clicking “Start R Session” (or “Start Python Session”) in the status bar.\nYou can have multiple R sessions open at the same time. This is occasionally useful — for example, if you want to keep one session with a large dataset loaded while experimenting in another. But be careful: whichever console is currently visible is where Cmd+Enter sends your code. If you have two R sessions and you’re looking at the wrong one, your code runs in a session that might not have the objects you expect. When something seems inexplicably broken, check which console tab is active.\n[TODO: screenshot showing multiple tabs in the bottom panel — R console, Terminal, etc.]\n\n\n4.2.3 The Variables Pane\nThe Variables pane shows every object in your current R or Python session — dataframes with their row and column counts, vectors, lists, models, and other objects. You used this constantly in Your First R Project to keep track of what was in memory.\nClick any dataframe to open it in the Data Viewer (more on that below). For other objects, you can expand them to see their contents. The Variables pane updates in real time as you create, modify, or remove objects.\nWhen you switch between R and Python consoles, the Variables pane switches too — it always shows the objects for whichever console is currently active.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#the-data-viewer",
    "href": "part2/positron.html#the-data-viewer",
    "title": "4  Positron",
    "section": "4.3 The Data Viewer",
    "text": "4.3 The Data Viewer\nThe Data Viewer is one of Positron’s standout features and something you’ll use every day. In Your First R Project, you opened it with View(sponge@meta.data) to inspect cell metadata in a spreadsheet-like view. Here’s what it can do.\nThere are two ways to open the Data Viewer. You can click any dataframe in the Variables pane — this is what you did in Your First R Project with View(sponge@meta.data). You can also click a data file (like .csv or .tsv) directly in the File Explorer, and Positron will open it in the Data Viewer rather than as a text file. This is a quick way to peek at data files without loading them into R or Python first.\nOnce open, the Data Viewer shows your data in a fast, interactive table where you can:\n\nSort by clicking column headers\nFilter rows using the filter bar — type conditions to narrow down the data\nSearch for specific values across the table\nSee distributions via the small column histograms at the top of each numeric column\n\nDuring exploratory analysis, you’ll have the Data Viewer open constantly — checking data after each transformation, looking for unexpected values, verifying that joins worked correctly.\n\n\n\n\n\n\nTipSeurat Objects\n\n\n\nYou can’t view a Seurat object directly in the Data Viewer — it’s a complex nested structure, not a simple dataframe. To inspect the metadata, use View(sponge@meta.data) in the console. This opens just the metadata table, which is what you usually want to see.\n\n\n[TODO: screenshot of Data Viewer with filtering active and column histograms visible]",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#navigating-your-project",
    "href": "part2/positron.html#navigating-your-project",
    "title": "4  Positron",
    "section": "4.4 Navigating Your Project",
    "text": "4.4 Navigating Your Project\n\n4.4.1 The File Explorer and Outline\nThe File Explorer in the left sidebar shows all files and folders in your project — specifically, the top-level folder you opened as your workspace. It only shows what’s inside that folder, which keeps things focused on your project. Click files to open them (data files like .csv and .tsv open in the Data Viewer; code files open in the editor). To create new files or folders, click the new file or new folder icons (the small buttons with a + symbol) at the top of the Explorer panel, or right-click for more options (rename, delete, etc.).\nBelow the file list (or in a separate section of the sidebar), the Outline panel shows the structure of the current document. For .qmd files, it lists headings and code chunks. For R or Python scripts, it shows function definitions. Click any item to jump directly to that section. When your analysis scripts get longer — and they will — the Outline becomes essential for navigating without endless scrolling.\n[TODO: screenshot showing the Outline panel for a .qmd file with headings and code chunks]\n\n\n4.4.2 Opening Files Quickly\nOnce your project has more than a few files, clicking through the File Explorer gets slow. Press Cmd+P (macOS) or Ctrl+P (Windows) to open the Quick Open bar — start typing part of a filename and Positron shows matching files. Hit Enter to open one. This is much faster than navigating through folders, especially when you know the filename you want.\n\n\n4.4.3 Working with Multiple Files\nFiles open as tabs in the editor area. You can have many files open at once and switch between them by clicking tabs.\nFor side-by-side viewing, drag a tab to the right edge of the editor — it splits the view so you can see two files at once. This is useful when you’re reading one script’s outputs while writing code that depends on them, or comparing two versions of an analysis.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#search",
    "href": "part2/positron.html#search",
    "title": "4  Positron",
    "section": "4.5 Search",
    "text": "4.5 Search\nPress Cmd+Shift+F (macOS) or Ctrl+Shift+F (Windows) to open project-wide search. Type a term and Positron searches every file in your project, showing results grouped by file with the matching lines highlighted.\nThis is useful for finding where a function is defined, locating every use of a variable name, or searching for a specific value across your project. Click the .* button next to the search bar to enable regular expressions for more powerful pattern matching.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#the-command-palette",
    "href": "part2/positron.html#the-command-palette",
    "title": "4  Positron",
    "section": "4.6 The Command Palette",
    "text": "4.6 The Command Palette\nThe Command Palette is Positron’s universal command search. Open it with Cmd+Shift+P (macOS) or Ctrl+Shift+P (Windows), then start typing what you want to do. It searches through every available command — from switching R versions to changing color themes to toggling panels.\nYou’ll most often encounter the Command Palette when Claude Code tells you to use it. For example, Claude might say “open the Command Palette and type ‘Python: Select Interpreter’ to choose your conda environment.” Rather than memorizing where every setting lives in menus, you type what you’re looking for and the Command Palette finds it.\nIt’s also how you discover features you didn’t know existed. Not sure if Positron can do something? Open the Command Palette and start typing — you might be surprised.\n[TODO: screenshot of the Command Palette with a search term entered]",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#the-status-bar",
    "href": "part2/positron.html#the-status-bar",
    "title": "4  Positron",
    "section": "4.7 The Status Bar",
    "text": "4.7 The Status Bar\nThe status bar runs along the very bottom of the Positron window. It’s easy to overlook, but it contains useful information at a glance:\n\nActive R version (e.g., “R 4.4.2”) — click to change\nPython interpreter (e.g., “Python 3.11 (my-project)”) — click to change\nCurrent Git branch (e.g., “main”)\nLine and column number for your cursor position\n\nWhen something isn’t working — code behaves unexpectedly, packages seem missing, or a render fails — check the status bar first. It often reveals the problem immediately: you’re running the wrong R version, or your Python is pointing at the base conda environment instead of your project environment.\n[TODO: screenshot of the status bar, annotated to show R version, Python interpreter, Git branch, and line/column]",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#essential-keyboard-shortcuts",
    "href": "part2/positron.html#essential-keyboard-shortcuts",
    "title": "4  Positron",
    "section": "4.8 Essential Keyboard Shortcuts",
    "text": "4.8 Essential Keyboard Shortcuts\nYou don’t need many shortcuts to be productive. These are the ones that matter:\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nRun current line/selection\nCmd+Enter\nCtrl+Enter\n\n\nRun current chunk\nCmd+Shift+Enter\nCtrl+Shift+Enter\n\n\nOpen Command Palette\nCmd+Shift+P\nCtrl+Shift+P\n\n\nQuick file open\nCmd+P\nCtrl+P\n\n\nToggle terminal\nCmd+| Ctrl+\n\n\n\nSave file\nCmd+S\nCtrl+S\n\n\n\nThe most important is Cmd+Enter (or Ctrl+Enter) — you’ll use it constantly to run code. The Command Palette (Cmd+Shift+P) is how you access any command in Positron; if you’re not sure how to do something, open the Command Palette and start typing.\n\n\n\n\n\n\nTipJust These Shortcuts\n\n\n\nSome people learn dozens of keyboard shortcuts. That’s fine, but not necessary. The shortcuts above cover 90% of what you need. Add more only if you find yourself doing something repeatedly.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#working-with-r",
    "href": "part2/positron.html#working-with-r",
    "title": "4  Positron",
    "section": "4.9 Working with R",
    "text": "4.9 Working with R\n\n4.9.1 Starting and Restarting R\nAn R session starts automatically when you run R code from a .qmd file or click “Start R Session” in the status bar. If the project has renv set up, you’ll see a message like Project loaded. [renv 1.0.0] confirming that project-specific packages are active.\nRestarting R is something you’ll do regularly. Click the power icon (↻) in the Console toolbar, or press Cmd+Shift+0 (macOS) / Ctrl+Shift+0 (Windows). This kills the current R process and starts a fresh one.\nWhy would you restart? During interactive development, your R session accumulates objects — dataframes, models, intermediate results. Some of these might not be created by your script; you might have defined them manually in the console while experimenting. Over time, the environment gets cluttered and it becomes hard to tell what’s in your script versus what you created on the fly. Restarting gives you a clean slate.\nThis is also how you test whether your script is self-contained. After restarting, run your script from the top: if everything executes cleanly, your script has all the code it needs. If it fails — usually with “object not found” errors — you know something was missing from the script. This is the same test that rendering performs (rendering always starts from a fresh session), but restarting lets you catch problems interactively before you wait for a full render.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can help diagnose the common “works interactively, fails on render” problem by checking what’s in your script versus what’s in your session.\n\nMy .qmd renders fine when I run chunks interactively, but quarto render fails with “object ‘filtered_data’ not found”. I think I have all the code in the script. Can you check what’s missing?\n\nClaude will read your script, trace where filtered_data should be created, and identify the gap — often a line you ran in the console but forgot to include in a chunk.\n\n\n\n\n4.9.2 Setting the R Version\nIf you have multiple R versions installed (via rig), you can choose which one Positron uses for a project:\n\nOpen the Command Palette (Cmd+Shift+P / Ctrl+Shift+P)\nType “R: Select R Binary”\nChoose the version you want\n\nThis usually only needs to be done once per project — Positron remembers your choice and uses it every time you open the project. If you later use the Musser Lab’s /new-project skill in Claude Code (covered in Part 3), it sets the R version automatically when scaffolding a new project.\nSee the R: rig & renv chapter for more on managing R versions and packages.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#working-with-python",
    "href": "part2/positron.html#working-with-python",
    "title": "4  Positron",
    "section": "4.10 Working with Python",
    "text": "4.10 Working with Python\n\n4.10.1 Selecting an Interpreter\nWhen you first open a project that uses Python, you need to tell Positron which conda environment to use:\n\nOpen the Command Palette (Cmd+Shift+P / Ctrl+Shift+P)\nType “Python: Select Interpreter”\nChoose your project’s conda environment from the list\n\nLike R, this only needs to be done once per project — Positron remembers your choice. If you later use the Musser Lab’s /new-project skill in Claude Code (covered in Part 3), it configures this automatically.\nSee the Conda chapter for how to create and manage Python environments.\n\n\n\n\n\n\nNoteEnvironment Not Showing?\n\n\n\nIf you just created a new conda environment, you may need to restart Positron for it to detect the new environment. This is a common gotcha — restart and try again.\n\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can troubleshoot Positron configuration issues like missing interpreters, environment detection, and extension problems.\n\nPositron isn’t finding my conda environment “my-project”. When I open the interpreter selector, it’s not in the list. I created it with conda create -n my-project python=3.11 and it shows up when I run conda env list in the terminal. What should I check?\n\nClaude will check your conda installation path, Positron’s Python discovery settings, and suggest fixes — typically a configuration change or a Positron reload.\n\n\n\n\n4.10.2 Automatic Environment Switching\nOne of Positron’s strengths: when you switch between projects, environments switch automatically. If Project A uses conda-env-a and Project B uses conda-env-b, opening each project activates the correct environment without manual intervention.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#source-control-basics",
    "href": "part2/positron.html#source-control-basics",
    "title": "4  Positron",
    "section": "4.11 Source Control Basics",
    "text": "4.11 Source Control Basics\nUnderstanding Git basics in Positron is important, even if you later use Claude Code for most commits. The Source Control panel (click the branch icon in the left sidebar, or Cmd+Shift+G / Ctrl+Shift+G) shows which files have changed since your last commit.\nThe basic workflow:\n\nMake changes to your files\nOpen Source Control panel — review changed files (click a file to see the diff)\nStage files by clicking the + icon next to each file\nType a commit message in the text box\nClick the checkmark to commit\nPush to GitHub via the three-dot menu (⋯) → Push\n\n\n\n\n\n\n\nNoteClaude Code and Git\n\n\n\nOnce you’re comfortable with Git basics, you may use Claude Code to handle commits. The /done command commits your work and can publish Quarto books. But understanding what’s happening in the Source Control panel helps you verify that commits are correct and troubleshoot when things go wrong.\n\n\nSee the Git & GitHub chapter for a full introduction to version control.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#when-things-go-wrong",
    "href": "part2/positron.html#when-things-go-wrong",
    "title": "4  Positron",
    "section": "4.12 When Things Go Wrong",
    "text": "4.12 When Things Go Wrong\nThings will go wrong — a panel will disappear, an interpreter won’t load, or Positron will behave strangely. Here’s how to fix the most common problems.\n\n4.12.1 A Panel Disappeared\nYou accidentally closed the Console, Terminal, or Variables pane and can’t find it. This happens to everyone. Go to the View menu at the top and look for the panel you need — View → Terminal, View → Console, etc. You can also use the Command Palette: type the name of the panel you’re looking for.\n\n\n4.12.2 Console Won’t Start\nThe R or Python console fails to launch, shows errors, or hangs. Check the Output panel (View → Output) and select “R” or “Python” from the dropdown — this shows diagnostic messages that often explain the actual error. Also check the status bar to verify the interpreter path is correct. If all else fails, restart Positron.\n\n\n4.12.3 Wrong Interpreter Running\nCode runs but uses unexpected package versions or the wrong Python/R. Check the status bar at the bottom — it shows which R and Python are active. If it’s wrong, use the Command Palette to reselect (R: Select R Binary or Python: Select Interpreter).\n\n\n4.12.4 Everything Feels Broken\nWhen Positron is behaving strangely and you’re not sure why, restart it. Close Positron completely and reopen your project. This fixes most transient issues — stuck processes, stale caches, panels that won’t respond.\nIf problems persist after a restart, check .positron/settings.json in your project folder for stale interpreter paths that might be pointing to environments or R versions that no longer exist.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code is good at diagnosing Positron issues because it can check your settings, environment paths, and installed packages all at once.\n\nPositron is acting weird — my R console started but it says packages are missing that I already installed. The status bar shows R 4.4.2 and renv is active. What should I check?\n\nClaude will check your renv status, verify the library path, and identify whether packages need to be restored or if there’s a version mismatch.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#extensions",
    "href": "part2/positron.html#extensions",
    "title": "4  Positron",
    "section": "4.13 Extensions",
    "text": "4.13 Extensions\nPositron comes with most of what you need built in. A few extensions are worth adding:\n\nQuarto — for .qmd file support (syntax highlighting, render button, preview). May already be installed.\nJupyter — for Python notebook support, which Quarto uses when rendering Python .qmd files.\nClaude Code — the AI coding assistant, if you’re using it.\n\nInstall extensions through the Extensions panel (Cmd+Shift+X / Ctrl+Shift+X), search for the name, and click Install.\n\n\n\n\n\n\nTipStart Minimal\n\n\n\nDon’t install a dozen extensions on day one. Start with the essentials above and add more only when you encounter a specific need. Too many extensions can slow things down and add complexity.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/positron.html#project-settings",
    "href": "part2/positron.html#project-settings",
    "title": "4  Positron",
    "section": "4.14 Project Settings",
    "text": "4.14 Project Settings\nPositron stores project-specific settings in a .positron/ folder inside your project. When you select an R version or Python interpreter through the Command Palette, Positron remembers that choice here. The folder is hidden by default (the . prefix hides it in most file browsers), and you normally won’t need to look at it — Positron manages it for you through the Command Palette.\nYou generally don’t need to think about this. The Command Palette handles most configuration, and Claude Code can adjust settings for you when needed. If something goes wrong with interpreter detection — Positron suddenly uses the wrong R version or Python environment — checking inside .positron/ for stale settings is a reasonable troubleshooting step. You can also safely delete the folder; Positron will recreate it next time you select an interpreter.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Positron</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html",
    "href": "part2/project-organization.html",
    "title": "5  Project Organization",
    "section": "",
    "text": "5.1 The Two Rules\nImagine opening a project you haven’t touched in six months. Or inheriting a colleague’s analysis when they leave the lab. You need to figure out: Where’s the raw data? Which script produces which output? What’s the current version of the analysis? Is that CSV file something I downloaded, or something a script generated?\nA well-organized project answers these questions through its structure alone. You shouldn’t need to read code or ask someone—the folder layout and naming conventions should tell you what’s what. This chapter describes the conventions we use in the lab to make that possible. Every rule exists for a practical reason, and once you’ve internalized them, setting up a new project takes minutes.\nIn Your First R Project, you created a project with data/, scripts/, and outs/ folders. This chapter explains that structure formally and covers how it scales as projects grow.\nEvery analysis project has two types of files, and the entire organizational system follows from keeping them separate:\nThis separation is the foundation. When you know that everything in data/ came from outside and everything in outs/ was generated by code, you can always trace where a file came from and how to recreate it.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#the-two-rules",
    "href": "part2/project-organization.html#the-two-rules",
    "title": "5  Project Organization",
    "section": "",
    "text": "Inputs are sacred. Data that comes from outside the project—sequencing results, collaborator files, public datasets—goes in data/ and is never modified by your scripts. If you need a cleaned version, your script reads the original, transforms it, and saves the result as an output.\nOutputs are disposable. Everything your scripts produce—processed data, figures, tables, rendered reports—goes in outs/ and can always be regenerated by rerunning the script that created it.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#anatomy-of-a-lab-project",
    "href": "part2/project-organization.html#anatomy-of-a-lab-project",
    "title": "5  Project Organization",
    "section": "5.2 Anatomy of a Lab Project",
    "text": "5.2 Anatomy of a Lab Project\nHere’s what a typical lab project looks like:\nmy-project/\n├── .claude/              # Claude Code project config\n│   └── CLAUDE.md\n├── data/                 # External inputs — scripts never write here\n├── scripts/              # Quarto analysis scripts (.qmd)\n│   └── exploratory/      # One-off analyses\n├── outs/                 # All generated outputs\n├── R/                    # Shared R helper functions\n├── python/               # Shared Python helper functions\n├── environment.yml       # Conda environment\n├── renv.lock             # R package versions\n├── .gitignore\n└── README.md\nIf you’re using Claude Code (covered in Part 3), the /new-project command scaffolds this entire structure for you — creating directories, initializing Git, setting up conda and renv, and generating a .claude/CLAUDE.md with your project’s conventions. But it’s worth understanding what each piece does.\nThe .claude/ directory holds project-level configuration for Claude Code, including a CLAUDE.md file that describes the project’s purpose, environment, and conventions. As a project matures, you may also add planning documents here to track multi-session work. You’ll learn more about this in the Claude Code chapters.\nNot every project needs every directory. An R-only project won’t have python/ or environment.yml. A Python-only project won’t have R/ or renv.lock. The /new-project command asks about your languages and creates only what’s needed.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#data-directory",
    "href": "part2/project-organization.html#data-directory",
    "title": "5  Project Organization",
    "section": "5.3 data/ — Your Inputs Are Sacred",
    "text": "5.3 data/ — Your Inputs Are Sacred\nThe data/ folder holds files that come from outside the project—things your scripts read but never write to:\ndata/\n├── counts_matrix.csv          # From the sequencing core\n├── sample_metadata.xlsx       # From a collaborator\n├── reference_genome.fasta     # Downloaded from NCBI\n└── README.md                  # Documents where each file came from\nThis includes raw sequencing data from core facilities, spreadsheets from collaborators, downloaded public datasets, annotation files from databases, and metadata you received or compiled by hand.\nThe critical rule is that scripts never write to data/. If your code produces a file, it belongs in outs/, not here. This rule means you can always trust that files in data/ are the original, unmodified inputs—you never have to wonder whether something in data/ was accidentally overwritten by a script.\nDocument where each file came from. A data/README.md is the simplest approach—note the source, date received, and any relevant details for each file. Six months from now, you’ll be grateful you wrote down which version of the genome annotation you downloaded, or which email attachment that metadata spreadsheet came from.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#scripts-directory",
    "href": "part2/project-organization.html#scripts-directory",
    "title": "5  Project Organization",
    "section": "5.4 scripts/ — Numbered Analysis Scripts",
    "text": "5.4 scripts/ — Numbered Analysis Scripts\nAll analysis scripts live in scripts/, numbered to show their logical flow:\nscripts/\n├── 01_import_qc.qmd\n├── 02_normalize.qmd\n├── 03_differential.qmd\n├── 04_volcano_plots.qmd\n├── 05_heatmaps.qmd\n└── exploratory/\n\n5.4.1 Why .qmd Files?\nIn the lab, all data analysis scripts are Quarto documents (.qmd), not plain .R or .py scripts. Quarto lets you combine code, results, and narrative explanation in a single file—so your analysis documents what it does and why as it runs. When you render a .qmd file, it produces an HTML report with your figures, tables, and text woven together.\nUse .py files only for standalone utilities, CLI tools, or library code in python/. Use .R files only for helper functions in R/. The analysis itself—the thing that reads data, transforms it, produces results—is always a .qmd. The Quarto chapter covers the syntax and workflow in detail.\nEach script uses one language—either R or Python, never both in the same file. When R and Python scripts need to exchange data, they communicate through files in outs/, not shared memory.\n\n\n5.4.2 Why Numbers?\nThe two-digit prefix (01_, 02_, …, 10_, 11_) serves a simple purpose: when you run ls or look at the file explorer, scripts appear in the order of your analysis pipeline. Script 01 imports and cleans the data. Script 02 normalizes it. Script 03 runs differential analysis. A new lab member can glance at the file list and understand the analysis flow.\nThe numbers indicate logical order, not strict dependencies. Script 05 might read outputs from scripts 01 and 03 directly—the numbering just helps you understand the overall structure at a glance. Dependencies are encoded by the file paths each script reads, not by the numbers.\nWhen you add a new script, assign the next available number. If you archive or delete a script, don’t renumber the remaining ones—leave gaps. This avoids confusion with any downstream references or documentation that mention the old numbers.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#outs-directory",
    "href": "part2/project-organization.html#outs-directory",
    "title": "5  Project Organization",
    "section": "5.5 outs/ — Provenance Through Structure",
    "text": "5.5 outs/ — Provenance Through Structure\nHere’s the convention that makes everything traceable: every script gets a matching output folder. Script 01_import_qc.qmd writes all its outputs to outs/01_import_qc/:\nouts/\n├── 01_import_qc/\n│   ├── filtered_counts.rds\n│   ├── qc_summary.csv\n│   ├── 01_import_qc.html      # Rendered report\n│   └── BUILD_INFO.txt\n├── 02_normalize/\n│   ├── normalized_counts.rds\n│   ├── 02_normalize.html\n│   └── BUILD_INFO.txt\n└── 03_differential/\n    ├── limma_results.rds\n    ├── significant_hits.csv\n    ├── 03_differential.html\n    └── BUILD_INFO.txt\nThis structure encodes provenance automatically. When you see a file in outs/03_differential/, you know exactly which script created it—no need to search or guess. The rendered HTML report sits alongside the data outputs, keeping scripts/ clean and making it easy to view results.\nOutput ownership is strict: a script writes only to its own output folder, never to another script’s. If script 05 needs a modified version of something script 01 produced, it reads script 01’s output and saves its own version in outs/05_whatever/.\n\n5.5.1 BUILD_INFO.txt\nEvery numbered script writes a BUILD_INFO.txt to its output folder as its last action:\nscript: 03_differential.qmd\ncommit: a1b2c3d\ndate: 2026-02-14 15:30:00\nThis answers a question that comes up constantly: “When was this output last regenerated, and from what version of the code?” If downstream plots look wrong, you can check the upstream folder’s BUILD_INFO.txt to see whether it was generated from current code or something stale. The Quarto chapter has the R and Python code to generate this automatically.\n\n\n5.5.2 Setting Up Output Paths\nIn your setup chunk, define paths that match this structure:\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\nlibrary(here)\n\n# This script's output folder\ndir_out &lt;- here::here(\"outs\", \"03_differential\")\ndir.create(dir_out, recursive = TRUE, showWarnings = FALSE)\n\n# Input paths\npath_normalized &lt;- here::here(\"outs\", \"02_normalize\", \"normalized_counts.rds\")\npath_metadata &lt;- here::here(\"data\", \"sample_metadata.csv\")\nThen save all outputs to dir_out:\n# Save results\nsaveRDS(results, file.path(dir_out, \"limma_results.rds\"))\nwrite_csv(significant, file.path(dir_out, \"significant_hits.csv\"))\n\n# Save figures\nggsave(file.path(dir_out, \"volcano_plot.pdf\"), p, width = 6, height = 4)",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#dependencies",
    "href": "part2/project-organization.html#dependencies",
    "title": "5  Project Organization",
    "section": "5.6 How Scripts Connect",
    "text": "5.6 How Scripts Connect\nScripts read from two places: data/ (external inputs) and outs/ (outputs from other scripts). Dependencies between scripts are self-documenting through file paths—group all input reads at the top of each script, with comments distinguishing external data from other scripts’ outputs:\n#| label: inputs\n\n# --- Inputs (from other scripts) ---\nnormalized &lt;- readRDS(here(\"outs/02_normalize/normalized_counts.rds\"))\n\n# --- Inputs (external data) ---\nmetadata &lt;- read_csv(here(\"data/sample_metadata.csv\"))\nannotations &lt;- read_tsv(here(\"data/gene_annotations.tsv\"))\nReading the top of any script shows exactly what it depends on and where those files come from. No separate manifest or pipeline specification needed—the dependencies are right there in the code.\nDependencies don’t have to be strictly linear. A plotting script might read from the original data, from an early QC script, and from a later differential analysis. Here’s what that looks like as a dependency diagram:\n\n\n\n\n\nflowchart LR\n    data[\"data/*\"] --&gt; s01[\"01_import_qc\"]\n    s01 --&gt; s02[\"02_normalize\"]\n    s02 --&gt; s03[\"03_differential\"]\n    s03 --&gt; s04[\"04_volcano_plots\"]\n\n    s02 --&gt; s05[\"05_heatmaps\"]\n    s03 --&gt; s05\n    data --&gt; s05\n\n\n\n\n\n\nBecause dependencies are encoded as file paths, you can trace them with a simple search:\n# Find which script produces a file\ngrep -r \"limma_results.rds\" scripts/\n\n# Find all scripts that depend on script 02's outputs\ngrep -r \"outs/02_normalize\" scripts/",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#exploratory",
    "href": "part2/project-organization.html#exploratory",
    "title": "5  Project Organization",
    "section": "5.7 The Exploratory Directory",
    "text": "5.7 The Exploratory Directory\nNot everything you write is part of the main analysis pipeline. Sometimes you need to test an idea, try a new visualization, or run a quick sanity check. That’s what scripts/exploratory/ is for:\nscripts/\n├── 01_import_qc.qmd\n├── 02_normalize.qmd\n├── exploratory/\n│   ├── test_umap_parameters.qmd\n│   └── compare_normalization.qmd\nExploratory scripts follow relaxed rules:\n\nNo number prefixes or BUILD_INFO.txt required\nNo other script depends on them—this is the critical rule. Exploratory scripts can read from any outs/ folder, but nothing outside of exploratory/ reads from exploratory outputs. This is a one-way dependency.\nCan be cleaned out periodically without breaking anything in the main pipeline\nGood candidates for promotion—if an exploratory analysis proves valuable, promote it to a numbered script in the main directory\n\nThe one-way dependency rule is what makes the exploratory directory safe to experiment in. You can write, modify, or delete anything in there without worrying about breaking the analysis pipeline.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#project-layout",
    "href": "part2/project-organization.html#project-layout",
    "title": "5  Project Organization",
    "section": "5.8 Growing a Project: Flat vs. Sectioned",
    "text": "5.8 Growing a Project: Flat vs. Sectioned\nThe structure shown above is a flat layout—all scripts in one directory, one numbering sequence. This works well for small to medium projects with a single analytical thread and fewer than about ten scripts.\nWhen a project grows to include multiple distinct analyses—say, phosphoproteomics and transcriptomics from the same experiment—a flat layout gets unwieldy. That’s when you switch to a sectioned layout, where scripts, data, and outputs are organized into subdirectories by analytical thread:\nproject/\n├── scripts/\n│   ├── phosphoproteomics/\n│   │   ├── 01_import_qc.qmd\n│   │   ├── 02_normalize.qmd\n│   │   └── 03_differential.qmd\n│   ├── transcriptomics/\n│   │   ├── 01_import.qmd\n│   │   └── 02_pca.qmd\n│   ├── combined/\n│   │   └── 01_integration.qmd\n│   └── exploratory/\n├── data/\n│   ├── phosphoproteomics/\n│   └── transcriptomics/\n└── outs/\n    ├── phosphoproteomics/\n    │   ├── 01_import_qc/\n    │   ├── 02_normalize/\n    │   └── 03_differential/\n    ├── transcriptomics/\n    │   ├── 01_import/\n    │   └── 02_pca/\n    └── combined/\n        └── 01_integration/\nA few things to notice:\n\nNumbering restarts at 01_ in each section. Each analytical thread has its own sequence.\nData and outs mirror the section structure. scripts/phosphoproteomics/ has a corresponding data/phosphoproteomics/ and outs/phosphoproteomics/.\nShared data that multiple sections use can live at the top level of data/ (e.g., data/gene_annotations/).\nCross-section scripts like combined/01_integration.qmd can read from any section’s outs/ folder.\n\nUse semantic names for sections—names that describe what the analysis is about (phosphoproteomics, transcriptomics, figures) rather than generic labels. A new lab member should be able to look at the directory names and understand the project’s scope.\n\n5.8.1 Alternative: Prefixes\nFor projects with just two or three analytical threads and only a few scripts each, subdirectories can be overkill. You can use prefixes instead:\nscripts/\n├── phospho_01_qc.qmd\n├── phospho_02_normalize.qmd\n├── trans_01_import.qmd\n└── combined_01_integration.qmd\nOutput folders mirror the naming: outs/phospho_01_qc/, outs/trans_01_import/, etc. Either approach works—the key is that outputs always mirror the script organization so provenance is clear.\n\n\n5.8.2 When to Switch\nStart flat. Switch to sectioned when you find yourself with more than about ten scripts or two distinct analytical threads competing for number slots. You don’t need to plan for sectioning from the start—restructuring a flat project into sections is straightforward because each script’s output folder moves with it.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#script-lifecycle",
    "href": "part2/project-organization.html#script-lifecycle",
    "title": "5  Project Organization",
    "section": "5.9 Script Lifecycle",
    "text": "5.9 Script Lifecycle\nAs an analysis evolves, scripts move through stages. Track this with a status field in the YAML frontmatter of each .qmd file:\n---\ntitle: \"Differential Expression\"\nstatus: development\n---\n\n\n\n\n\n\n\n\nStatus\nMeaning\nLocation\n\n\n\n\ndevelopment\nIn active development; outputs may change\nscripts/\n\n\nfinalized\nOutputs are publication-ready; modify only with deliberate re-validation\nscripts/\n\n\ndeprecated\nSuperseded by a newer script; kept for reference\nscripts/old/\n\n\n\nMost scripts spend their life in development. When the results are solid and heading toward a paper, mark them finalized. This signals to collaborators (and to yourself) that changes should be deliberate—if you rerun a finalized script, you should check that the outputs still match what went into the manuscript.\nWhen a script is superseded, move it to scripts/old/ and add a deprecated_by field pointing to its replacement:\n---\ntitle: \"Old Heatmaps\"\nstatus: deprecated\ndeprecated_by: 06_improved_heatmaps.qmd\n---\nThis makes it clear which script replaced it, while Git preserves the full history. Don’t just delete old scripts if someone might want to reference them—the old/ directory keeps them visible without cluttering the main listing.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#housekeeping",
    "href": "part2/project-organization.html#housekeeping",
    "title": "5  Project Organization",
    "section": "5.10 Keeping Things Clean",
    "text": "5.10 Keeping Things Clean\n\n5.10.1 Naming Conventions\nGood file names are lowercase, descriptive, and use underscores:\n\nScripts: 01_import_qc.qmd, not 01_Analysis.qmd or 01 import qc.qmd\nOutput files: normalized_counts.rds, not data.rds or output.csv\nMultiple similar files: Use a consistent pattern like volcano_3min.pdf, volcano_15min.pdf\n\nAvoid spaces (they cause problems in terminal commands), generic names (results.csv, figure1.pdf), and date prefixes on every file—let Git track versions instead.\n\n\n5.10.2 Cross-Language Data\nWhen data produced by an R script needs to be read by a Python script (or vice versa), use Parquet format. CSV files lose type information — a column of integers might be read back as strings, or dates might be misinterpreted. Parquet avoids this by storing column types alongside the data, so what you save is exactly what you read back. Parquet files are also smaller and faster to read than CSV in both languages.\nIn R, Parquet support comes from the arrow package. Install it with renv::install(\"arrow\") if you haven’t already:\n# R: save as Parquet\narrow::write_parquet(results, file.path(dir_out, \"results.parquet\"))\n\n# R: read Parquet\nresults &lt;- arrow::read_parquet(here(\"outs/01_analysis/results.parquet\"))\n# Python: save as Parquet\nresults.to_parquet(out_dir / \"results.parquet\")\n\n# Python: read Parquet\nresults = pd.read_parquet(PROJECT_ROOT / \"outs/01_analysis/results.parquet\")\nWithin a single language, use native formats—.rds for R objects, .pkl for Python objects. Parquet is specifically for data that crosses the language boundary.\n\n\n5.10.3 Helper Functions\nWhen you find yourself copying the same function between scripts, move it to a shared location:\nProject-level helpers live in R/ and python/ at the project root:\n# In any script, load project helpers with:\nsource(here(\"R/gene_helpers.R\"))\n# In any script, load project helpers with:\nimport sys\nsys.path.insert(0, str(PROJECT_ROOT / \"python\"))  # tell Python where to find your modules\nfrom gene_helpers import normalize_name\nPython doesn’t automatically know to look in your project’s python/ folder for modules — sys.path.insert adds that folder to the list of places Python searches when you import something. The R equivalent (source()) is simpler because it takes a direct file path.\nFix functions in place and let Git track the history—don’t version function names (make_gene_short_v2).\nCross-project helpers go in ~/lib/R/ and ~/lib/python/. When a project-level function proves useful across two or more projects, promote it to your personal library. This keeps project repositories clean while making reusable code accessible everywhere.\n\n\n5.10.4 Version Control\nYour .gitignore should generally include:\n\nouts/ — generated outputs can be regenerated from code\n*_files/ and .quarto/ — Quarto rendering artifacts\nrenv/library/ and renv/staging/ — renv installs packages from the lock file\n.DS_Store, .vscode/, .positron/ — OS and IDE files\n.env, *.pem, credentials.json — secrets\n\nWhether to commit data/ depends on file sizes. Small data files (a few MB) can be committed so the project is self-contained. Large files should be gitignored, with a data/README.md documenting where to get them. The Git & GitHub chapter covers version control in detail, and Appendix C has a complete .gitignore template.\n\n\n5.10.5 Handling Old Versions\nThe preferred approach is to use Git—delete old files and recover them from history if needed. For deprecated scripts you want to keep visible, use scripts/old/ with the deprecated status as described in Script Lifecycle. Only add dates to output subdirectories when you genuinely need multiple versions to coexist, like comparing runs with different parameters:\nouts/03_differential/\n├── 2025-01-15_strict_threshold/\n└── 2025-01-20_relaxed_threshold/",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/project-organization.html#complete-example",
    "href": "part2/project-organization.html#complete-example",
    "title": "5  Project Organization",
    "section": "5.11 A Complete Example",
    "text": "5.11 A Complete Example\nHere’s a well-organized phosphoproteomics project—the kind of structure you’d end up with after a few months of analysis:\ntryptamine_phospho/\n├── .claude/\n│   ├── CLAUDE.md\n│   └── PHOSPHO_PLAN.md         # Planning doc tracking analysis progress\n├── R/\n│   └── gene_helpers.R\n├── data/\n│   ├── README.md               # Documents where each file came from\n│   ├── raw_counts.csv          # From mass spec core\n│   ├── sample_metadata.csv     # Experimental design\n│   └── gene_annotations.tsv    # Downloaded from UniProt\n├── scripts/\n│   ├── 01_import_qc.qmd       # status: finalized\n│   ├── 02_normalize.qmd       # status: finalized\n│   ├── 03_differential.qmd    # status: finalized\n│   ├── 04_volcano_plots.qmd   # status: development\n│   ├── 05_heatmaps.qmd        # status: development\n│   ├── exploratory/\n│   │   └── test_new_clustering.qmd\n│   └── old/\n│       └── 04_volcano_v1.qmd  # status: deprecated, replaced by 04\n├── outs/\n│   ├── 01_import_qc/\n│   │   ├── filtered_counts.rds\n│   │   └── BUILD_INFO.txt\n│   ├── 02_normalize/\n│   │   ├── normalized_counts.rds\n│   │   └── BUILD_INFO.txt\n│   ├── 03_differential/\n│   │   ├── limma_results.rds\n│   │   ├── significant_hits.csv\n│   │   └── BUILD_INFO.txt\n│   ├── 04_volcano_plots/\n│   │   ├── volcano_3min.pdf\n│   │   └── volcano_15min.pdf\n│   └── 05_heatmaps/\n│       └── heatmap_all_clusters.pdf\n├── environment.yml\n├── renv.lock\n├── .gitignore\n└── README.md\nFrom this structure, anyone can understand the project without reading a single line of code:\n\nWhere did the data come from? Check data/README.md.\nWhat’s the analysis pipeline? Read the numbered scripts in order.\nWhich script produced limma_results.rds? It’s in outs/03_differential/, so script 03 made it.\nIs the analysis finalized? Check the status field—scripts 01–03 are finalized, 04–05 are still in development.\nWhat code version produced these outputs? Check BUILD_INFO.txt in each output folder.\nHow do I reproduce everything? Set up the environment (environment.yml + renv.lock), then run the scripts in order.\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can scaffold this entire structure for you and help maintain it as your project grows.\n\nI’m starting a new project analyzing RNA-seq data from three conditions with two time points. I’ll use R for the analysis. Can you set up the project?\n\nClaude will run /new-project to create the directory structure, initialize Git, set up renv, create a .claude/CLAUDE.md, and push to GitHub—all configured for your specific analysis.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Project Organization</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html",
    "href": "part2/quarto.html",
    "title": "6  Quarto",
    "section": "",
    "text": "6.1 Why Quarto?\nIn Your First R Project, you worked with a .qmd file—running code chunks interactively, viewing results in the plots pane, and rendering the document to HTML. This chapter explains Quarto’s syntax and features in depth so you can write your own analysis documents from scratch.\nQuarto is a scientific publishing system that lets you combine code, results, and narrative text in a single document. You write analysis scripts as .qmd files—plain text with embedded R or Python code—and Quarto renders them into polished HTML reports with your outputs automatically included.\nIn the Musser Lab, Quarto documents are the standard format for data analysis because they solve a fundamental problem: keeping your code, your results, and your explanation of those results in sync. When you render a .qmd file, Quarto executes the code fresh and weaves the outputs into the document, so the report always reflects the actual analysis.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#why-quarto",
    "href": "part2/quarto.html#why-quarto",
    "title": "6  Quarto",
    "section": "",
    "text": "6.1.1 Compared to Plain Scripts\nA plain .R or .py script is just code. It can produce outputs, but there’s no built-in way to document what the code does, why you made certain choices, or what the results mean. When you share a script, collaborators see the code but not your interpretation. Comments help, but they’re limited—you can’t embed figures, formatted tables, or section headings in a comment.\nWith Quarto:\n\nCode and narrative live together — explain what you’re doing as you do it\nResults are embedded — figures and tables appear in the document\nOutput is shareable — render to HTML that anyone can open in a browser\n\n\n\n6.1.2 Compared to Jupyter Notebooks\nIf you’ve used Jupyter notebooks (.ipynb), you might wonder why we use Quarto instead. Jupyter is a great tool for interactive exploration, but .qmd files have several advantages for reproducible analysis:\nPlain text, not JSON. Jupyter notebooks are stored as JSON with embedded output cells, making them difficult to version control with Git. A small code change can produce a massive diff because the output cells change too. Quarto documents are plain text—diffs show exactly what you changed, and merge conflicts are easy to resolve.\nFresh-session rendering. When you run cells in a Jupyter notebook, results depend on the order you executed them and what’s lingering in memory. It’s easy to have a notebook that “works” only because you ran cell 5 before cell 3 during development. Quarto renders in a fresh session every time, catching hidden dependencies that Jupyter lets slip through.\nPositron integration. In Positron, you get the best of both worlds—interactive execution with Cmd+Enter (like Jupyter) plus a persistent console, Variables pane, and Data Viewer alongside your document. You don’t lose the interactive workflow; you gain reproducibility on top of it.\nOne format, both languages. Quarto treats R and Python as equal citizens. The same .qmd format, chunk options, and rendering pipeline work for both. No need to learn separate tools for each language.\nIf you’re coming from Jupyter, the transition is straightforward: your code goes in fenced chunks instead of cells, your markdown goes between chunks instead of in markdown cells, and you render the whole document instead of running cells individually. The interactive development experience in Positron feels very similar to Jupyter—you just get reproducibility as a bonus.\n\n\n6.1.3 Compared to R Markdown\nIf you’ve used R Markdown (.Rmd), Quarto will feel familiar. The core idea—mixing code, results, and narrative—is the same. Quarto is R Markdown’s successor, developed by Posit (the company behind RStudio) as a unified system that works equally well with R, Python, Julia, and other languages.\n\n\n\n\n\n\n\n\n\nR Markdown\nQuarto\n\n\n\n\nFile extension\n.Rmd\n.qmd\n\n\nLanguage support\nR-centric (Python possible but awkward)\nMulti-language by design\n\n\nChunk options\n{r, echo=FALSE}\n#| echo: false (YAML-style)\n\n\nOutput formats\nDocuments, some websites\nDocuments, websites, books, slides, dashboards\n\n\n\nYou don’t need to memorize the differences. If you know R Markdown, Quarto works similarly. If you’re new to both, just learn Quarto—it’s the modern standard.\n\n\n6.1.4 What Else Can Quarto Do?\nWhile we primarily use Quarto for analysis scripts, it’s a general-purpose publishing system. This book was built with Quarto. You can also create:\n\nWebsites — project documentation, lab websites\nPresentations — slides rendered from code (RevealJS format)\nDashboards — interactive displays of data\n\nSee the Quarto documentation if you want to explore these formats.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#the-interactive-development-workflow",
    "href": "part2/quarto.html#the-interactive-development-workflow",
    "title": "6  Quarto",
    "section": "6.2 The Interactive Development Workflow",
    "text": "6.2 The Interactive Development Workflow\nBefore diving into syntax, understand how you’ll actually work with Quarto documents. There are two modes, and you’ll spend most of your time in the first one.\nInteractive development is where the real work happens. You write a chunk of code in your .qmd file, run it with Cmd+Enter (macOS) or Ctrl+Enter (Windows), inspect the output in the Console or Data Viewer, tweak it, run again. Objects you create persist in your R or Python session, so you can build on previous chunks. This feels just like working in a Jupyter notebook or an R console—the .qmd file is your scratch pad, and Positron is your workbench.\n[TODO: screenshot of Positron with .qmd open, console showing output, Data Viewer with dataframe]\nRendering is for validation and sharing. When the analysis is complete—or when you want to check that everything works end-to-end—you render the document:\nquarto render my_analysis.qmd\nRendering executes every code chunk in a fresh session (no leftover objects from interactive work) and produces a standalone HTML file. This catches errors you might miss interactively, like relying on an object you created manually but forgot to include in the script.\nA typical session looks like this: you open your project in Positron, create or open a .qmd file, and start writing chunks—setup first (libraries, paths), then data loading, then analysis. You run each chunk interactively, checking results as you go. When the analysis feels complete, you render the whole document. If rendering fails (usually a missing object or package), you fix it and render again. Once it succeeds, you commit the .qmd file.\nThe key insight: interactive mode is for development, rendering is for validation. Always render before committing or sending a report to someone.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#writing-a-quarto-document",
    "href": "part2/quarto.html#writing-a-quarto-document",
    "title": "6  Quarto",
    "section": "6.3 Writing a Quarto Document",
    "text": "6.3 Writing a Quarto Document\nA Quarto document has two parts: a YAML header (metadata and rendering options, between --- markers at the top) and a body (Markdown text interspersed with code chunks).\n\n6.3.1 Creating a New Document\nTo start a new Quarto document in Positron, go to the File Explorer in the left sidebar, right-click inside your scripts/ folder, and select New File. Name it with a .qmd extension (like 01_analysis.qmd). Positron recognizes the extension and gives you Quarto syntax highlighting and the Render button in the toolbar. Start by pasting in the YAML header and setup chunk from the templates below, then begin adding your own sections and code chunks.\n\n\n6.3.2 Document Structure\nHere’s a minimal example:\n---\ntitle: \"My Analysis\"\nformat: html\n---\n\n## Introduction\n\nThis analysis examines the relationship between X and Y.\n\n```{r}\nlibrary(tidyverse)\ndata &lt;- read_csv(\"data/input.csv\")\nglimpse(data)\n```\n\n## Results\n\n```{r}\nggplot(data, aes(x = x, y = y)) +\n  geom_point()\n```\nWhen rendered, this produces an HTML file with the title, your text, and the code outputs (the glimpse() output and the plot) embedded. For Python, the only difference is the chunk fence—use ```{python} instead of ```{r}.\n\n\n6.3.3 The YAML Header\nThe YAML header controls document metadata and rendering behavior. Here’s what a typical lab analysis header looks like:\n\nRPython\n\n\n---\ntitle: \"Phosphoproteomics Volcano Plots\"\nsubtitle: \"Tryptamine treatment time course\"\nauthor: \"Your Name\"\ndate: today\nstatus: development\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    code-overflow: wrap\n    code-fold: false\n    code-tools: true\n    highlight-style: github\n    theme: cosmo\n    fontsize: 1rem\n    linestretch: 1.5\n    self-contained: true\nexecute:\n  echo: true\n  message: false\n  warning: false\n  cache: false\n---\n\n\n---\ntitle: \"Phosphoproteomics Volcano Plots\"\nsubtitle: \"Tryptamine treatment time course\"\nauthor: \"Your Name\"\ndate: today\nstatus: development\njupyter: python3\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    code-overflow: wrap\n    code-fold: false\n    code-tools: true\n    highlight-style: github\n    theme: cosmo\n    fontsize: 1rem\n    linestretch: 1.5\n    self-contained: true\nexecute:\n  echo: true\n  warning: false\n  cache: false\n---\n\n\n\nThe two headers are nearly identical. Python adds jupyter: python3 (which tells Quarto to use the Jupyter kernel for execution) and drops message: false (which is R-specific—R packages print startup messages, Python packages generally don’t).\nHere’s what the key options do:\n\nstatus tracks the script’s lifecycle stage (development, finalized, deprecated)—see Project Organization\ntoc: true adds a table of contents, making long analyses navigable\nself-contained: true bundles everything into a single HTML file you can email or share\ncode-tools: true adds a button to show/hide all code at once\necho: true shows your code in the output—important for analysis scripts where the code is part of the documentation\nmessage: false / warning: false keeps rendered output clean by suppressing package messages and warnings\n\nFor the full list of YAML options, see the Quick Reference tables at the end of this chapter. For a copy-paste template you can use to start new scripts, see Appendix C.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can generate a complete YAML header and setup chunk tailored to your analysis.\n\nI’m starting a new R analysis script for differential expression using DESeq2. Set up a QMD with the standard lab header and a setup chunk that loads DESeq2, tidyverse, and here.\n\nClaude will create a .qmd file with the full YAML header, setup chunk with library loading, output directory creation, and provenance tracking—all following the lab conventions described in this chapter.\n\n\n\n\n6.3.4 The Setup Chunk\nEvery analysis script should start with a setup chunk that loads packages, defines paths, sets options, and captures the git commit hash for provenance tracking.\n\nRPython\n\n\n#| label: setup\n#| include: false\n\n# ---- Libraries ----\nsuppressPackageStartupMessages({\n  library(tidyverse)\n  library(here)\n})\n\n# ---- Paths ----\ndir_data &lt;- here::here(\"data\")\ndir_out &lt;- here::here(\"outs\", \"01_script_name\")\ndir.create(dir_out, recursive = TRUE, showWarnings = FALSE)\n\n# ---- Options ----\noptions(stringsAsFactors = FALSE)\nset.seed(42)\n\n# ---- Provenance ----\ngit_hash &lt;- system(\"git rev-parse --short HEAD\", intern = TRUE)\ncat(\"Rendered from commit:\", git_hash, \"\\n\")\n\n\n#| label: setup\n\n# Standard library modules (built into Python)\nimport subprocess, sys, random\nfrom pathlib import Path\nfrom datetime import datetime\n\n# Third-party packages (installed via conda)\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# ---- Project Root ----\n# Find the project root by asking Git where the repository starts.\n# This lets us build reliable file paths regardless of where the script lives.\nPROJECT_ROOT = Path(subprocess.check_output(\n    [\"git\", \"rev-parse\", \"--show-toplevel\"]\n).decode().strip())\n# Add the project's python/ folder so we can import our own helper modules\nsys.path.insert(0, str(PROJECT_ROOT / \"python\"))\n\n# ---- Options ----\nrandom.seed(42)\nnp.random.seed(42)\npd.set_option(\"display.max_columns\", None)\nsns.set_theme(style=\"whitegrid\")\n\n# ---- Paths ----\nout_dir = PROJECT_ROOT / \"outs/01_script_name\"\nout_dir.mkdir(parents=True, exist_ok=True)\n\n# ---- Provenance ----\ngit_hash = subprocess.check_output(\n    [\"git\", \"rev-parse\", \"--short\", \"HEAD\"]\n).decode().strip()\nprint(f\"Rendered from commit: {git_hash}\")\n\n\n\n\n\n\n\n\n\nNoteThese Templates Require Git\n\n\n\nThe provenance section uses git rev-parse to capture the current commit hash, and the Python version uses it to find the project root. These commands only work if your project is a Git repository. If you haven’t set up Git yet (covered in the Git & GitHub chapter), you can comment out the provenance lines for now and add them back later when your project is under version control.\n\n\nBoth versions follow the same pattern: libraries, paths, options, provenance. The key differences:\n\n#| include: false (R only) — hides the setup chunk from the rendered output. Python setup chunks typically stay visible because the import list serves as documentation.\nsuppressPackageStartupMessages() (R) — prevents the noisy startup messages that R packages print when loaded.\nhere::here() (R) vs PROJECT_ROOT (Python) — both build file paths relative to the project root, not the script location. The R version uses the here package; the Python version finds the root via git rev-parse. See Working Directory and Paths.\nset.seed(42) — makes random operations reproducible. Python needs two seeds (random.seed for stdlib, np.random.seed for NumPy).\n\n\n\n6.3.5 Code Chunks\nCode chunks are fenced with triple backticks and a language identifier:\n```{r}\n# R code here\n```\n\n```{python}\n# Python code here\n```\nUse the #| syntax to set options for individual chunks:\n#| label: load-data\n#| message: false\n\ndata &lt;- read_csv(here::here(\"data\", \"input.csv\"))\nThe label option names the chunk. This is useful for debugging (error messages reference the chunk label), cross-references (linking to figures), and caching.\nHere are the chunk patterns you’ll use most often:\nHidden setup — runs but doesn’t appear in output:\n#| label: setup\n#| include: false\n\nlibrary(tidyverse)\nVisible code with clean output — shows code, hides messages:\n#| label: load-data\n#| message: false\n#| warning: false\n\ndata &lt;- read_csv(\"data.csv\")\nFigure with caption — for publication-ready figures:\n#| label: fig-volcano\n#| fig-cap: \"Volcano plot showing differential expression\"\n#| fig-width: 6\n#| fig-height: 4\n\nggplot(results, aes(x = logFC, y = -log10(pvalue))) +\n  geom_point()\nCode shown but not run — for demonstrating syntax:\n#| label: example-syntax\n#| eval: false\n\n# This code is displayed but not executed\nhypothetical_function()\nFor the full table of chunk options, see the Quick Reference at the end of this chapter.\n\n\n6.3.6 Documenting Inputs and Outputs\nAfter the setup chunk, add an explicit inputs section that loads all dependencies. This makes it immediately clear what the script needs to run:\n\nRPython\n\n\n#| label: inputs\n\n# --- Inputs (from other scripts) ---\nresults &lt;- readRDS(here(\"outs/03_differential/limma_results.rds\"))\n\n# --- Inputs (external data) ---\nmetadata &lt;- read_csv(here(\"data/sample_metadata.csv\"))\n\n\n#| label: inputs\n\n# --- Inputs (from other scripts) ---\nresults = pd.read_parquet(PROJECT_ROOT / \"outs/03_differential/deseq_results.parquet\")\n\n# --- Inputs (external data) ---\nmetadata = pd.read_csv(PROJECT_ROOT / \"data/sample_metadata.csv\")\n\n\n\nSeparating inputs from analysis code makes dependencies self-documenting—reading the top of any script shows exactly what it depends on. You can also document inputs and outputs in the introduction text:\n# Volcano Plots\n\nThis script generates volcano plots for the phosphoproteomics time course.\n\n**Inputs:**\n\n- `outs/03_differential/limma_results.rds`\n- `data/sample_metadata.csv`\n\n**Outputs:**\n\n- `outs/04_volcano_plots/volcano_*.pdf`\n- `outs/04_volcano_plots/significant_hits.csv`\nSee the Project Organization chapter for how this fits into the larger project structure.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#saving-outputs",
    "href": "part2/quarto.html#saving-outputs",
    "title": "6  Quarto",
    "section": "6.4 Saving Outputs",
    "text": "6.4 Saving Outputs\nDon’t rely on the Plots pane or copy-paste. Save figures and tables to files explicitly:\n\nRPython\n\n\n#| label: fig-volcano\n#| fig-cap: \"Volcano plot showing differential phosphorylation\"\n\np &lt;- ggplot(results, aes(x = logFC, y = -log10(adj.P.Val))) +\n  geom_point() +\n  theme_minimal()\n\n# Display in rendered document\nprint(p)\n\n# Save to output folder\nggsave(\n  file.path(dir_out, \"volcano_plot.pdf\"),\n  plot = p,\n  width = 6,\n  height = 4\n)\nFor tables:\nwrite_csv(significant_hits, file.path(dir_out, \"significant_hits.csv\"))\n\n\n#| label: fig-volcano\n#| fig-cap: \"Volcano plot showing differential phosphorylation\"\n\nfig, ax = plt.subplots(figsize=(6, 4))\nax.scatter(results[\"logFC\"], -np.log10(results[\"adj_pval\"]))\nax.set_xlabel(\"log2 Fold Change\")\nax.set_ylabel(\"-log10 Adjusted P-value\")\nplt.tight_layout()\n\n# Save to output folder AND display inline\nfig.savefig(out_dir / \"volcano_plot.pdf\", dpi=300, bbox_inches=\"tight\")\nfig.savefig(out_dir / \"volcano_plot.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\nFor tables:\nsignificant_hits.to_csv(out_dir / \"significant_hits.csv\", index=False)\n\n\n\nThis approach embeds the figure in the rendered HTML, saves a high-quality copy for publication or further use, and makes the output traceable (the file exists in outs/).",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#working-directory-and-paths",
    "href": "part2/quarto.html#working-directory-and-paths",
    "title": "6  Quarto",
    "section": "6.5 Working Directory and Paths",
    "text": "6.5 Working Directory and Paths\nWhen Quarto renders a .qmd, the working directory is the folder containing the .qmd file—not the project root. This can cause path confusion.\nproject/\n├── scripts/\n│   └── 01_analysis.qmd    ← Working directory during render\n├── data/\n│   └── input.csv\n└── outs/\nFrom scripts/01_analysis.qmd, a relative path to the data would be ../data/input.csv. But this breaks if you move the script or run it from a different location.\n\nR: here::here()Python: PROJECT_ROOT\n\n\nThe here package finds the project root (by looking for .git, .Rproj, etc.) and builds paths from there:\n# Always works, regardless of working directory\ndata &lt;- read_csv(here::here(\"data\", \"input.csv\"))\n\n# Instead of fragile relative paths\ndata &lt;- read_csv(\"../data/input.csv\")  # Don't do this\n\n\nPython doesn’t have a direct equivalent of here, so the setup chunk finds the project root via Git:\nPROJECT_ROOT = Path(subprocess.check_output(\n    [\"git\", \"rev-parse\", \"--show-toplevel\"]\n).decode().strip())\n\n# Always works, regardless of working directory\ndata = pd.read_csv(PROJECT_ROOT / \"data/input.csv\")\n\n# Instead of fragile relative paths\ndata = pd.read_csv(\"../data/input.csv\")  # Don't do this\n\n\n\nUse project-root-relative paths for all file operations in your scripts. It makes your code portable and reproducible.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#rendering",
    "href": "part2/quarto.html#rendering",
    "title": "6  Quarto",
    "section": "6.6 Rendering",
    "text": "6.6 Rendering\n\n6.6.1 From the Terminal\n\nRPython\n\n\nquarto render scripts/01_analysis.qmd\n\n\nPython QMD files require the conda environment to be active when you render. If you haven’t set up conda yet, the Conda chapter walks through installation and environment creation — come back to this section after that.\nsource ~/miniconda3/etc/profile.d/conda.sh && conda activate my-project && quarto render scripts/02_plots.qmd\nIf quarto render fails with ModuleNotFoundError, check that your conda environment is active. This is the number one Python QMD gotcha.\n\n\n\nTo render all .qmd files in a directory:\nquarto render scripts/\n\n\n6.6.2 From Positron\nClick the Render button in the editor toolbar, or use Cmd+Shift+K (macOS) / Ctrl+Shift+K (Windows).\n\n\n6.6.3 Preview Mode\nFor live feedback during development, use preview mode:\nquarto preview scripts/01_analysis.qmd\nThis opens a browser window that automatically refreshes when you save changes. Useful for tuning formatting, but remember that preview still renders in a fresh session—it’s not the same as interactive execution.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#best-practices",
    "href": "part2/quarto.html#best-practices",
    "title": "6  Quarto",
    "section": "6.7 Best Practices",
    "text": "6.7 Best Practices\n\n6.7.1 Render Before Committing\nAlways render the full document before committing to Git. This catches missing packages (installed interactively but not in your lockfile), missing objects (created interactively but not in the script), and order dependencies (chunks that depend on earlier chunks you modified).\n\n\n6.7.2 Self-Contained Scripts\nEvery .qmd should run successfully from a fresh R or Python session. Don’t assume objects exist from previous interactive work. If render fails, your script isn’t self-contained.\n\n\n6.7.3 Clear Section Structure\nOrganize your script with clear headings:\n# Introduction\n# Setup\n# Load Data\n# Analysis\n# Results\n# Summary\nThis makes the script navigable (via Positron’s Outline panel) and the rendered document readable.\n\n\n6.7.4 Validation Chunks\nFor complex analyses, add validation chunks that verify data integrity:\n#| label: validate-data\n#| include: false\n\n# Check required columns exist\nrequired_cols &lt;- c(\"sample_id\", \"condition\", \"value\")\nmissing_cols &lt;- setdiff(required_cols, names(data))\nif (length(missing_cols) &gt; 0) {\n  stop(\"Missing required columns: \", paste(missing_cols, collapse = \", \"))\n}\n\nstopifnot(\"No data loaded\" = nrow(data) &gt; 0)\nThese chunks catch problems early and provide clear error messages.\n\n\n6.7.5 Provenance Chunk\nEnd every script with a chunk that writes BUILD_INFO.txt and prints session information. This records which script, commit, and timestamp produced the outputs—answering “when was this last regenerated?”\n\nRPython\n\n\n#| label: build-info\n\nwriteLines(\n  c(\n    paste(\"script:\", \"01_script_name.qmd\"),\n    paste(\"commit:\", git_hash),\n    paste(\"date:\", format(Sys.time(), \"%Y-%m-%d %H:%M:%S\"))\n  ),\n  file.path(dir_out, \"BUILD_INFO.txt\")\n)\n\nsessionInfo()\n\n\n#| label: build-info\n\n(out_dir / \"BUILD_INFO.txt\").write_text(\n    f\"script: 01_script_name.qmd\\n\"\n    f\"commit: {git_hash}\\n\"\n    f\"date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n)\n\nimport session_info\nsession_info.show()",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#common-issues",
    "href": "part2/quarto.html#common-issues",
    "title": "6  Quarto",
    "section": "6.8 Common Issues",
    "text": "6.8 Common Issues\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can debug render failures, especially the common case where code works interactively but fails during rendering.\n\nWhen I run quarto render analysis.qmd, I get this error: [paste error]. The code runs fine interactively in the console. What’s going wrong?\n\nClaude will trace the error to its cause—typically a missing object that existed in your interactive session but isn’t created in the script, or a path that resolves differently during rendering.\n\n\n\n6.8.1 “Object not found” During Render\nCode that works interactively may fail during render if you rely on objects not created in the script. You created an object manually in the console, then used it in a chunk without creating it in the script. Ensure all objects are created within the .qmd and render frequently to catch this early.\n\n\n6.8.2 Figures Not Appearing\nIf a plot doesn’t show up in the rendered output, add an explicit print():\np &lt;- ggplot(data, aes(x, y)) + geom_point()\nprint(p)  # Required inside loops or complex chunks\nThe explicit print() is needed when the plot is the result of an assignment or is inside a loop/function.\n\n\n6.8.3 Package Messages Cluttering Output\nSet message: false and warning: false in the YAML execute: block to suppress them globally, or per-chunk for specific chunks.\n\n\n6.8.4 Output File Is Huge\nIf your HTML is very large:\n\nEmbedded images: Use self-contained: false to keep images in a separate _files folder\nHigh resolution: Add fig-dpi: 150 to reduce figure resolution\nSVG format: Use fig-format: png instead of SVG for complex plots\n\n\n\n6.8.5 Chunk Takes Forever\nFor long-running chunks during development, consider #| cache: true. This caches the chunk’s results—subsequent renders skip execution if the code hasn’t changed. Use sparingly, as caching can cause subtle bugs if dependencies change.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#quick-reference",
    "href": "part2/quarto.html#quick-reference",
    "title": "6  Quarto",
    "section": "6.9 Quick Reference",
    "text": "6.9 Quick Reference\n\n6.9.1 YAML Options\n\n6.9.1.1 Document Metadata\n\n\n\nOption\nPurpose\nExample\n\n\n\n\ntitle\nDocument title (appears at top)\n\"My Analysis\"\n\n\nsubtitle\nSecondary title\n\"Brief description\"\n\n\nauthor\nYour name\n\"Jane Doe\"\n\n\ndate\nDate; use today for automatic\ntoday\n\n\nstatus\nScript lifecycle stage\ndevelopment\n\n\njupyter\nJupyter kernel (Python only)\npython3\n\n\n\n\n\n6.9.1.2 Format Options (under format: html:)\n\n\n\nOption\nPurpose\nRecommended\n\n\n\n\ntoc\nInclude table of contents\ntrue\n\n\ntoc-depth\nHow many heading levels in TOC\n2\n\n\nnumber-sections\nNumber your headings\ntrue\n\n\ncode-overflow\nHow to handle long code lines\nwrap\n\n\ncode-fold\nCollapse code blocks by default\nfalse\n\n\ncode-tools\nAdd show/hide all code button\ntrue\n\n\nhighlight-style\nSyntax highlighting theme\ngithub\n\n\ntheme\nBootstrap theme for HTML\ncosmo\n\n\nfontsize\nBase font size\n1rem\n\n\nlinestretch\nLine spacing multiplier\n1.5\n\n\nself-contained\nSingle HTML file\ntrue\n\n\n\n\n\n6.9.1.3 Execute Options (under execute:)\n\n\n\nOption\nPurpose\nRecommended\n\n\n\n\necho\nShow code in output\ntrue\n\n\nmessage\nShow package messages (R only)\nfalse\n\n\nwarning\nShow warnings\nfalse\n\n\ncache\nCache chunk results\nfalse\n\n\n\n\n\n\n6.9.2 Chunk Options\n\n\n\nOption\nPurpose\nValues\n\n\n\n\nlabel\nChunk name\nAny string\n\n\necho\nShow code\ntrue / false\n\n\neval\nRun code\ntrue / false\n\n\ninclude\nInclude in output\ntrue / false\n\n\nmessage\nShow messages\ntrue / false\n\n\nwarning\nShow warnings\ntrue / false\n\n\nerror\nContinue on error\ntrue / false\n\n\ncache\nCache results\ntrue / false\n\n\nfig-cap\nFigure caption\nString\n\n\nfig-width\nWidth in inches\nNumber\n\n\nfig-height\nHeight in inches\nNumber\n\n\nfig-dpi\nResolution\nNumber (default 72)\n\n\nfig-format\nOutput format\npng / svg / pdf\n\n\ntbl-cap\nTable caption\nString\n\n\n\n\n\n6.9.3 R vs Python Comparison\n\n\n\n\n\n\n\n\nConvention\nR\nPython\n\n\n\n\nProject root\nhere::here()\nPROJECT_ROOT (from git)\n\n\nRead CSV\nread_csv(here(\"data/file.csv\"))\npd.read_csv(PROJECT_ROOT / \"data/file.csv\")\n\n\nRead TSV\nread_tsv(here(\"data/file.tsv\"))\npd.read_csv(PROJECT_ROOT / \"data/file.tsv\", sep=\"\\t\")\n\n\nRead Parquet\narrow::read_parquet(here(...))\npd.read_parquet(PROJECT_ROOT / ...)\n\n\nSave figure\nggsave(file.path(dir_out, \"fig.pdf\"))\nfig.savefig(out_dir / \"fig.pdf\")\n\n\nRandom seed\nset.seed(42)\nrandom.seed(42) + np.random.seed(42)\n\n\nSession info\nsessionInfo()\nsession_info.show()\n\n\nChunk label\n{r label-name} or #| label:\n#| label: only\n\n\nHelper loading\nsource(here(\"R/helpers.R\"))\nsys.path.insert(0, str(PROJECT_ROOT / \"python\"))\n\n\n\n\n\n6.9.4 Quarto Commands\n\n\n\nCommand\nPurpose\n\n\n\n\nquarto render file.qmd\nRender to HTML\n\n\nquarto render file.qmd --to pdf\nRender to PDF\n\n\nquarto preview file.qmd\nLive preview in browser\n\n\nquarto render directory/\nRender all .qmd in directory\n\n\nquarto check\nVerify Quarto installation\n\n\n\n\n\n6.9.5 Keyboard Shortcuts (Positron)\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nRun line/selection\nCmd+Enter\nCtrl+Enter\n\n\nRun chunk\nCmd+Shift+Enter\nCtrl+Shift+Enter\n\n\nRender document\nCmd+Shift+K\nCtrl+Shift+K\n\n\nInsert R chunk\nCmd+Option+I\nCtrl+Alt+I\n\n\n\nFor complete, copy-paste-ready templates (YAML headers, setup chunks, provenance chunks for both R and Python), see Appendix C.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/quarto.html#python-specific-notes",
    "href": "part2/quarto.html#python-specific-notes",
    "title": "6  Quarto",
    "section": "6.10 Python-Specific Notes",
    "text": "6.10 Python-Specific Notes\nThis section collects the Python-specific details that don’t fit neatly into the tabsets above. If you haven’t set up conda yet, read the Conda chapter first — these notes will make more sense after that.\nConda must be active for rendering. This is the number one Python QMD gotcha. Unlike R (which finds packages via renv automatically), Python QMD files require the conda environment to be active when you render. If quarto render fails with ModuleNotFoundError, activate your environment first.\nInstall ipykernel. Quarto uses Jupyter kernels to execute Python code. Your conda environment needs ipykernel installed (conda install ipykernel) or rendering will fail.\nInstall session-info. For the provenance chunk to work, install session-info in your conda environment: pip install session-info. Note the dash in the install name vs. the underscore in the import (import session_info) — this is a common Python convention where package install names use dashes but module names use underscores.\nDon’t mix languages. Do not mix R and Python chunks in a single .qmd. Each script uses one language. Scripts communicate through files in outs/, not shared memory. If an R script produces data that a Python script needs, save it as Parquet (see Project Organization).\nSelecting the interpreter. Ensure Positron is using the correct conda environment: open the Command Palette (Cmd/Ctrl+Shift+P), type “Python: Select Interpreter”, and choose your project’s environment.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto</span>"
    ]
  },
  {
    "objectID": "part2/renv.html",
    "href": "part2/renv.html",
    "title": "7  R: rig & renv",
    "section": "",
    "text": "7.1 rig: Managing R Versions\nIn Your First R Project, you ran renv::init(), installed Seurat and half a dozen other packages, and ran renv::snapshot() to lock everything down. It worked — but what actually happened? Where did those packages go? What is renv.lock recording? And why did the installation chapter have you install R with something called “rig” instead of downloading it from the R website?\nThis chapter answers those questions. Managing R effectively requires two things: controlling which version of R you’re running, and controlling which packages are installed for each project. We use rig for the first and renv for the second. Together, they give each project a self-contained, reproducible R setup — the same idea as conda environments for Python, but with R’s own tools.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#rig-managing-r-versions",
    "href": "part2/renv.html#rig-managing-r-versions",
    "title": "7  R: rig & renv",
    "section": "",
    "text": "7.1.1 Why You’d Need More Than One\nImagine this: you built your Spongilla analysis six months ago with R 4.4. Now you’re starting a new project, and R 4.5 is out with nice improvements. Should you update?\nIf you just download R 4.5 from the R website, it overwrites R 4.4. Your new project runs fine, but when you go back to the Spongilla analysis, subtle things might break. Packages that worked under R 4.4 might behave differently under R 4.5. Worse, if you’re using Bioconductor packages for genomics work, each Bioconductor release is tied to a specific R version — upgrading R can silently change which Bioconductor packages you get, potentially altering your results.\nThis is the problem rig solves. When you run rig add release, it installs the new R version alongside the old one, not replacing it. You can have R 4.3, R 4.4, and R 4.5 all installed at the same time, and switch between them depending on which project you’re working on.\n[TODO: screenshot of terminal showing rig list output with multiple R versions installed]\n\n\n7.1.2 Day-to-Day Usage\nThe Installation chapter covered installing rig and adding your first R version. Here are the commands you’ll use day to day:\n# See which R versions are installed\nrig list\n\n# Install the latest stable R\nrig add release\n\n# Install a specific older version\nrig add 4.3\n\n# Set the system default\nrig default 4.4\n\n# Check which version is the default\nrig default\n\n\n\n\n\n\nNoterig add vs. CRAN installers\n\n\n\nWhen you run rig add, it downloads and installs R without removing previous versions. This is different from downloading R directly from CRAN, which typically overwrites your existing installation.\n\n\n\n\n7.1.3 Setting R Version Per Project\nFor most day-to-day work, the system default R version is fine — all your new projects will use it. But when you need a specific version for a particular project (because a collaborator uses R 4.3, or because the project depends on a specific Bioconductor release), you can lock it per project.\nIn Positron, open the Command Palette (Cmd+Shift+P on macOS, Ctrl+Shift+P on Windows) and type R: Select R Binary. You’ll see a list of the R versions rig has installed. Pick the one you want, and Positron will remember that choice for this project — every time you open the project, it uses the version you selected.\n[TODO: screenshot of Command Palette showing “R: Select R Binary” with a list of installed R versions]\nYou only need to do this once per project. If you later use the Musser Lab’s /new-project skill in Claude Code (covered in Part 3), it sets the R version automatically when scaffolding a new project. See the Positron chapter for more details.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#renv-project-package-libraries",
    "href": "part2/renv.html#renv-project-package-libraries",
    "title": "7  R: rig & renv",
    "section": "7.2 renv: Project Package Libraries",
    "text": "7.2 renv: Project Package Libraries\n\n7.2.1 What renv Actually Did in Chapter 3\nWhen you ran renv::init() in your first project, renv created several files in your project folder. At the time you probably didn’t pay much attention to them — you were focused on getting Seurat running. Here’s what each one does.\nThe renv/ folder is your project’s private package library. When you installed Seurat, ggplot2, and the other packages, they went here — not into a shared system library that all your projects use. This is the key idea: each project has its own packages, so installing something for Project A can’t break Project B.\nThe renv.lock file is a JSON snapshot of every package in your project library — names, exact versions, and where they came from (CRAN, Bioconductor, GitHub). This is what makes your analysis reproducible. When a collaborator clones your project and runs renv::restore(), renv reads this file and installs every package at the exact version you recorded.\nThe .Rprofile file runs automatically when R starts in this folder. It calls the activation script (renv/activate.R), which tells R to use the project library instead of the system library. That’s why you see Project loaded. [renv 1.0.0] in the console when you open the project in Positron — it’s renv confirming it’s active.\n[TODO: screenshot of Positron console showing “Project loaded. [renv 1.0.0]” activation message]\n\n\n7.2.2 Installing Packages\nYou already installed packages in Chapter 3 with renv::install(). Here’s what else you need to know.\nFor most packages, install.packages() still works — renv intercepts the call and installs into your project library. But renv::install() is more versatile because it understands multiple sources:\n# Install from CRAN (either method works)\ninstall.packages(\"ggplot2\")\nrenv::install(\"ggplot2\")\n\n# Install from Bioconductor (must use renv::install with bioc:: prefix)\nrenv::install(\"bioc::DESeq2\")\n\n# Install from GitHub\nrenv::install(\"satijalab/seurat\")\n\n# Install a specific version\nrenv::install(\"ggplot2@3.4.0\")\nThe bioc:: prefix is important. Bioconductor is a separate repository of R packages for bioinformatics — things like DESeq2 for differential expression, SingleCellExperiment for single-cell data structures, and hundreds of other genomics tools. These packages aren’t on CRAN, so you need the prefix to tell renv where to find them. For a guide to common R packages for genomics and single-cell analysis, see Appendix D: R Packages for Biology.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nWhen you’re starting a new type of analysis and aren’t sure which packages you need, Claude Code can recommend packages and generate the install commands.\n\nI’m starting a bulk RNA-seq analysis in my renv project. I need to import Salmon quantifications and run differential expression. What R packages do I need and how do I install them?\n\nClaude will recommend the right packages (tximport for importing quantifications, DESeq2 for differential expression, etc.), generate the correct renv::install() commands with the bioc:: prefix for Bioconductor packages, and remind you to snapshot afterward.\n\n\n\n\n7.2.3 Snapshot and Restore: The Core Loop\nAfter installing packages, the most important habit is snapshot:\nrenv::snapshot()\nThis updates renv.lock with the exact versions of everything in your project library. After snapshotting, commit the updated renv.lock to Git. This is the cycle you’ll repeat throughout a project:\n\nInstall or update a package\nRun renv::snapshot() to record the change\nCommit renv.lock to Git\n\nWhy does this matter? Imagine your collaborator clones your project from GitHub six months from now. The R code is all there, but without the right packages at the right versions, nothing runs. When they open the project and run:\nrenv::restore()\nrenv reads renv.lock and installs every package at the exact version you recorded. Your collaborator gets the same environment you had, not whatever happens to be current on CRAN that day. This is what makes the analysis reproducible — not just the code, but the exact tools that ran it.\n\n\n7.2.4 Checking Status\nBefore committing your work, it’s good practice to check whether your library and lockfile are in sync:\nrenv::status()\nThis tells you if any packages are installed but not recorded in the lockfile (you need to snapshot()), missing from your library (you need to restore()), or at different versions than the lockfile expects.\nThe most common message you’ll see is “The project is out-of-sync.” This sounds alarming but usually just means you installed something and forgot to snapshot, or you pulled changes from Git that updated the lockfile and haven’t restored yet. Run renv::status() to see the details, and it will be clear which direction to go.\n[TODO: screenshot of R console showing renv::status() output with out-of-sync packages listed]\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can interpret renv status messages and tell you whether to restore or snapshot.\n\nI’m getting “The project is out-of-sync” when I start R. Here’s the output of renv::status(): [paste output]. What should I do — restore or snapshot?\n\nClaude will read the status output, explain which packages are out of sync and why, and recommend the right command.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#bioconductor",
    "href": "part2/renv.html#bioconductor",
    "title": "7  R: rig & renv",
    "section": "7.3 How rig and renv Work Together",
    "text": "7.3 How rig and renv Work Together\nrig and renv solve different problems, but they connect in an important way. When you run renv::snapshot(), the lockfile records not just your packages but also your R version and, if you’re using Bioconductor, the Bioconductor version. This creates a complete picture of your environment.\nThe connection matters because of Bioconductor. Each Bioconductor release is built and tested against a specific R version — Bioconductor 3.19 works with R 4.4, Bioconductor 3.20 also works with R 4.4, and Bioconductor 3.21 requires R 4.5. If you change your R version, you may get a different Bioconductor release with different package versions. For a project that uses Bioconductor packages, changing R can subtly change your results even if your code doesn’t change at all. You can check which Bioconductor releases work with which R versions on the Bioconductor release history page.\nThis is why pinning R per project (using the Command Palette method described above) matters for critical analyses — especially anything heading toward publication. renv records the R and Bioconductor versions in the lockfile, and rig makes it easy to have the right R version available. Together, they ensure that renv::restore() on another machine gives you the same environment, not just the same package names.\nYou can check your current Bioconductor version at any time:\nBiocManager::version()",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#what-to-commit-to-git",
    "href": "part2/renv.html#what-to-commit-to-git",
    "title": "7  R: rig & renv",
    "section": "7.4 What to Commit to Git",
    "text": "7.4 What to Commit to Git\nYou’ve been committing renv.lock since Chapter 3, and that’s the most important file. Here’s the full list of what goes into Git and what doesn’t.\nInclude in Git:\n\nrenv.lock — the lockfile (exact package versions — the whole point)\nrenv/activate.R — the activation script\n.Rprofile — auto-activates renv when R starts\n\nExclude from Git (should be in .gitignore):\n\nrenv/library/ — the actual installed packages (too large and platform-specific)\nrenv/staging/ — temporary files during installation\n\nThe default renv setup handles the .gitignore entries automatically — when you ran renv::init(), it created a .gitignore inside the renv/ folder that excludes library/ and staging/. If you set up your project through the lab’s workflow tools (covered in later chapters), these exclusions are already in place.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#updating-packages",
    "href": "part2/renv.html#updating-packages",
    "title": "7  R: rig & renv",
    "section": "7.5 Updating Packages",
    "text": "7.5 Updating Packages\nPackages get updates — bug fixes, new features, performance improvements. To update everything in your project:\nrenv::update()\nOr update a specific package:\nrenv::update(\"ggplot2\")\nAfter updating, test that your analysis still runs correctly, then snapshot:\nrenv::snapshot()\nHere’s a useful habit: snapshot and commit before updating. That way, if an update breaks something, you can restore the previous state:\nrenv::restore()\nThis reinstalls packages at the versions in renv.lock, effectively undoing the update. Because you committed the old lockfile, you can always get back to a known-good state.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#troubleshooting",
    "href": "part2/renv.html#troubleshooting",
    "title": "7  R: rig & renv",
    "section": "7.6 Troubleshooting",
    "text": "7.6 Troubleshooting\n\n7.6.1 “The project is out-of-sync”\nThis is the most common renv message and it’s usually not a real problem. It means your installed packages don’t match what’s in renv.lock. Run renv::status() to see the details:\nrenv::status()\nIf it shows packages installed but not in the lockfile, you probably installed something and forgot to snapshot — run renv::snapshot(). If it shows packages in the lockfile but not installed, you probably pulled changes from Git — run renv::restore().\n\n\n7.6.2 Package Installation Fails\nSometimes a package won’t install, especially packages with compiled code (C or Fortran). Try rebuilding from source:\nrenv::install(\"package-name\", rebuild = TRUE)\nFor Bioconductor packages, make sure BiocManager is installed and your R version is compatible with the Bioconductor release you need. Bioconductor’s website lists which R versions work with each release.\n\n\n7.6.3 renv is Slow\nThe first time you run renv::restore() on a new machine, renv downloads and installs every package from scratch. This can take a while for projects with many packages (Seurat alone has dozens of dependencies). Be patient — subsequent operations are faster because renv maintains a global cache. Packages that are shared across projects only download once; renv links them into each project’s library.\n\n\n7.6.4 Starting Fresh\nIf things are really broken and you want to start over:\nrenv::deactivate()\nThen remove the renv files in the terminal:\nrm -rf renv renv.lock .Rprofile\nAnd reinitialize:\nrenv::init()\n\n\n\n\n\n\nWarning\n\n\n\nThis removes your lockfile, so you lose the record of which package versions you had. If you need to preserve that information, copy renv.lock somewhere safe before deleting it.\n\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code is good at diagnosing package installation errors because it can check your R version, Bioconductor version, and system dependencies all at once.\n\nI’m trying to install DESeq2 with renv::install(\"bioc::DESeq2\") but I’m getting errors about missing dependencies. Here’s the error output: [paste error]. I’m on R 4.4 with renv 1.0. Can you help me figure out what’s wrong?\n\nClaude will check whether the error is a Bioconductor version mismatch, a missing system library, or a network issue, and suggest the specific fix.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/renv.html#quick-reference",
    "href": "part2/renv.html#quick-reference",
    "title": "7  R: rig & renv",
    "section": "7.7 Quick Reference",
    "text": "7.7 Quick Reference\n\n7.7.1 rig Commands\n\n\n\nTask\nCommand\n\n\n\n\nList installed R versions\nrig list\n\n\nInstall latest R\nrig add release\n\n\nInstall specific version\nrig add 4.3\n\n\nSet default R\nrig default 4.4\n\n\nShow default R\nrig default\n\n\n\n\n\n7.7.2 renv Commands\n\n\n\nTask\nCommand\n\n\n\n\nInitialize renv\nrenv::init()\n\n\nInstall from CRAN\ninstall.packages(\"pkg\")\n\n\nInstall from Bioconductor\nrenv::install(\"bioc::pkg\")\n\n\nInstall from GitHub\nrenv::install(\"user/repo\")\n\n\nSnapshot\nrenv::snapshot()\n\n\nRestore\nrenv::restore()\n\n\nCheck status\nrenv::status()\n\n\nUpdate all packages\nrenv::update()\n\n\nUpdate one package\nrenv::update(\"pkg\")",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>R: rig & renv</span>"
    ]
  },
  {
    "objectID": "part2/conda.html",
    "href": "part2/conda.html",
    "title": "8  Conda",
    "section": "",
    "text": "8.1 Why Environments Matter\nIn Your First R Project, renv gave your project its own private library of R packages — isolated from everything else on your computer. If you installed Seurat for one project and ggplot2 for another, neither could interfere with the other. That isolation is what made your analysis reproducible.\nConda does the same thing for Python. It creates environments — self-contained spaces, each with their own Python version and their own set of packages. When you start a new Python project, you create a new conda environment for it, install the packages you need, and work inside that environment. Nothing you do in one environment affects another.\nIf you’ve never used Python before, that’s fine. This chapter assumes no prior Python experience — just the concepts you picked up from working with renv in Chapter 3. The commands are different, but the idea is the same: each project gets its own tools, and you record what you installed so others can reproduce your setup.\nImagine you’re six months into a project analyzing microscopy images. You’ve been using a Python package called scikit-image version 0.21, and everything works. Then a labmate asks for help with their project, which needs scikit-image version 0.23 — a newer version with a different API. If Python packages all live in one place (the way they do with a bare pip install), updating for their project would break yours.\nThis is exactly the problem renv solved for R, and it’s the problem conda solves for Python. Each project gets its own environment with its own packages, so updating one project can’t break another. You can even use different Python versions — one project on Python 3.11, another on 3.12 — without conflict.\nIn the lab, every project gets its own conda environment. This isn’t optional — it’s how we keep analyses reproducible and avoid the kind of subtle, hard-to-diagnose bugs that come from shared package installations.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#installing-miniforge",
    "href": "part2/conda.html#installing-miniforge",
    "title": "8  Conda",
    "section": "8.2 Installing Miniforge",
    "text": "8.2 Installing Miniforge\nConda itself is just a program — you need to install it before you can use it. We use Miniforge, a lightweight distribution that comes pre-configured with the conda-forge package channel (the community-maintained repository where most scientific Python packages live). Miniforge gives you conda without the bloat of the full Anaconda distribution.\n\nmacOSWindows\n\n\nThe easiest way to install Miniforge on macOS is with Homebrew, the macOS package manager. If you already have Homebrew installed (you can check by running brew --version in Terminal), run:\nbrew install miniforge\nIf you don’t have Homebrew, you can download the Miniforge installer directly from the Miniforge GitHub releases page. Download the macOS installer for your chip (Apple Silicon or Intel), then run it:\nbash Miniforge3-MacOSX-arm64.sh\nFollow the prompts, accepting the defaults. When the installer asks whether to initialize conda, say yes.\n\n\nDownload the Miniforge installer from the Miniforge GitHub releases page. Choose the Windows installer (.exe file), run it, and follow the prompts. Accept the default installation location (C:\\Users\\YourName\\miniforge3).\n\n\n\nAfter installation, close and reopen your terminal (Terminal on macOS, PowerShell on Windows) so the new conda command becomes available. You can verify the installation worked by running:\nconda --version\nIf you see a version number (like conda 24.7.1), you’re set. If you get “command not found,” see the Troubleshooting section at the end of this chapter.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#one-time-setup",
    "href": "part2/conda.html#one-time-setup",
    "title": "8  Conda",
    "section": "8.3 One-Time Setup",
    "text": "8.3 One-Time Setup\nBefore creating your first environment, there are a few configuration steps that make conda faster and more reliable. You only need to do these once — they apply globally to all environments you create.\n\n\n\n\n\n\nNoteWindows Users: Initialize Your Shell\n\n\n\nOn Windows, conda needs to hook into PowerShell before conda activate will work. Open PowerShell and run:\nconda init powershell\nThen close and reopen PowerShell. You only need to do this once. (If you use Command Prompt instead, run conda init cmd.exe.)\n\n\n\n8.3.1 Set conda-forge as the Default Channel\nConda downloads packages from channels — think of them as package repositories, like CRAN for R. The most important channel is conda-forge, a community-maintained collection of well-tested scientific packages. We want conda to always look here first:\nconda config --set channel_priority strict\nconda config --add channels conda-forge\nThe first command tells conda to respect channel priority strictly (no mixing versions from different sources). The second makes conda-forge the top-priority channel. This avoids subtle version mismatches that can cause hard-to-debug problems.\n\n\n8.3.2 Speed Up the Solver\nConda figures out which package versions are compatible before installing anything — this is called “solving the environment.” The default solver can be slow. The libmamba solver is much faster and is built into modern conda:\nconda config --set solver libmamba\nWith these three commands done, conda is configured for reliable, fast use. You won’t need to think about this again.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#creating-your-first-environment",
    "href": "part2/conda.html#creating-your-first-environment",
    "title": "8  Conda",
    "section": "8.4 Creating Your First Environment",
    "text": "8.4 Creating Your First Environment\nLet’s create an environment for a hypothetical data analysis project. The command looks like this:\nconda create -n my-project python=3.11 numpy pandas matplotlib ipykernel\nHere’s what each piece means:\n\nconda create — make a new environment\n-n my-project — name it “my-project” (you’ll use this name every time you activate it)\npython=3.11 — install Python 3.11 (pinning the version so it doesn’t change unexpectedly)\nnumpy pandas matplotlib ipykernel — install these packages into the environment from the start\n\nConda will show you a list of packages it plans to install (including dependencies) and ask you to confirm. Type y and hit Enter.\nThe packages in this example are a typical starting point for data science work. numpy handles numerical computing, pandas gives you dataframes (similar to R’s dataframes or tibbles), matplotlib is the core plotting library, and ipykernel is required for Quarto to execute Python .qmd files. Without ipykernel, you’ll get a kernel error when trying to render — so always include it.\nYou might also want seaborn (statistical visualization built on matplotlib) or scikit-learn (machine learning). You can add these during creation or install them later — there’s no penalty for adding packages after the environment exists.\n\n\n\n\n\n\nNoteWhat About Jupyter?\n\n\n\nYou don’t need jupyter or jupyterlab for our workflow — Quarto handles document rendering directly through ipykernel. Only install Jupyter if you receive .ipynb notebook files from collaborators and want to open them in the traditional notebook interface.\n\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nWhen you’re starting a new type of analysis and aren’t sure which Python packages you need, Claude Code can recommend packages and generate the environment creation command.\n\nI’m starting a Python project to analyze fluorescence microscopy images. I’ll need to load TIFF stacks, segment cells, and measure intensities. What packages should I include in my conda environment?\n\nClaude will suggest the right packages (scikit-image for segmentation, tifffile for TIFF loading, etc.), generate the full conda create command, and flag any packages that need to be installed via pip instead of conda.\n\n\n\n\n\n\n\n\nTipClaude Code Does This Automatically\n\n\n\nIn practice, you’ll rarely build environments from scratch. The Musser Lab’s /new-project skill in Claude Code (covered in Part 3) creates a conda environment for your project automatically, installs the packages you need, and configures Positron to use it. But understanding these commands is important for troubleshooting and for working outside the lab’s automated workflow.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#using-your-environment",
    "href": "part2/conda.html#using-your-environment",
    "title": "8  Conda",
    "section": "8.5 Using Your Environment",
    "text": "8.5 Using Your Environment\n\n8.5.1 Activating and Deactivating\nAn environment doesn’t do anything until you activate it. Activation tells your terminal to use that environment’s Python and packages instead of the system defaults:\nconda activate my-project\nWhen an environment is active, your terminal prompt changes to show the environment name in parentheses:\n\nmacOSWindows\n\n\n(my-project) $\n\n\n(my-project) PS C:\\Users\\yourname&gt;\n\n\n\nThis is your visual confirmation that the right environment is active. If you don’t see the environment name in your prompt, your code will use the wrong Python — a common source of “package not found” errors.\n[TODO: screenshot of terminal showing (my-project) in the prompt after activation]\nTo leave an environment and return to the default state, run:\nconda deactivate\n\n\n8.5.2 Installing More Packages\nOnce an environment is active, you can install additional packages into it:\nconda install seaborn scikit-learn\nConda installs packages into whichever environment is currently active, so always check your prompt before installing. If you accidentally install into the wrong environment, it’s not the end of the world — just activate the right one and install again there.\nTo see what’s installed in your current environment:\nconda list\nAnd to see all the environments you’ve created:\nconda env list\n\n\n8.5.3 Connecting to Positron\nCreating and activating an environment in the terminal is only half the story. You also need to tell Positron which environment to use, so that when you run Python code from a .qmd file, it uses the right Python with the right packages.\n\nOpen Positron and navigate to your project folder\nOpen the Command Palette (Cmd+Shift+P on macOS, Ctrl+Shift+P on Windows)\nType “Python: Select Interpreter”\nChoose your environment from the list (it will show something like Python 3.11 (my-project))\n\n[TODO: screenshot of Positron Command Palette showing “Python: Select Interpreter” with conda environments listed]\nOnce selected, Positron remembers this choice for the project — you won’t need to do it again unless you create a new environment. The status bar at the bottom of Positron shows which Python interpreter is active, so you can always verify at a glance.\n[TODO: screenshot of Positron status bar showing the active Python environment]\n\n\n\n\n\n\nNoteEnvironment Not Showing Up?\n\n\n\nIf you just created a new conda environment and it doesn’t appear in Positron’s interpreter list, try restarting Positron. It sometimes needs a fresh start to detect new environments.\n\n\nIf you use the Musser Lab’s /new-project skill in Claude Code, it configures the Positron interpreter automatically as part of project setup — one less thing to remember.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#sharing-environments",
    "href": "part2/conda.html#sharing-environments",
    "title": "8  Conda",
    "section": "8.6 Sharing Environments",
    "text": "8.6 Sharing Environments\n\n8.6.1 environment.yml\nJust as renv uses renv.lock to record your R packages, conda uses a file called environment.yml to record your Python environment. This file lists the environment name, which channels to use, and which packages are installed — everything someone else needs to recreate your setup.\nTo create this file from your current environment:\nconda env export --from-history &gt; environment.yml\nThe --from-history flag is important. It records only the packages you explicitly installed, not every transitive dependency. This makes the file portable across operating systems — a colleague on Windows can recreate an environment you built on macOS, because conda resolves platform-specific dependencies at install time.\nThe resulting file looks like this:\nname: my-project\nchannels:\n  - conda-forge\ndependencies:\n  - python=3.11\n  - numpy\n  - pandas\n  - matplotlib\n  - ipykernel\n\n\n8.6.2 Recreating an Environment from a File\nWhen a collaborator shares a project with an environment.yml, they can recreate the environment with one command:\nconda env create -f environment.yml\nThis creates the environment, installs all the packages, and sets it up so they can activate it and start working. It’s the conda equivalent of running renv::restore() in R.\n\n\n\n\n\n\nTipKeep environment.yml in Git\n\n\n\nCommit environment.yml to your Git repository alongside your code and renv.lock. When you install new packages, re-export the file and commit the update. The Claude Code /done command can help manage this as part of your session wrap-up.\n\n\n\n\n8.6.3 Full Export (When Needed)\nFor exact reproducibility on the same platform, you can do a full export:\nconda env export &gt; environment.yml\nThis includes exact version numbers and platform-specific build strings for every package, including dependencies. It’s useful for archiving a precise state or debugging, but the file won’t work on a different operating system. Use --from-history for sharing and full export for archiving.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#best-practices",
    "href": "part2/conda.html#best-practices",
    "title": "8  Conda",
    "section": "8.7 Best Practices",
    "text": "8.7 Best Practices\n\n8.7.1 One Environment Per Project\nEvery project in the lab gets its own conda environment, named after the project. This keeps things clean and avoids the situation where updating a package for one project silently breaks another. It also means environment.yml accurately reflects what that specific project needs.\nconda create -n tihkal-analysis python=3.11 numpy pandas matplotlib ipykernel\nconda create -n imaging-project python=3.11 numpy pandas scikit-image ipykernel\nName your environments after the project — short, descriptive, and easy to type. Avoid generic names like env1 or test that tell you nothing when you see them in conda env list six months later.\n\n\n8.7.2 Never Install into Base\nWhen you open a terminal with conda configured, you’ll see (base) in your prompt. This is the base environment — it’s where conda itself lives. Never install project packages into base. It’s tempting (it’s right there, already active), but packages in base affect every project on your machine. Keep base clean and always create a dedicated environment before installing anything.\n\n\n8.7.3 Pin Your Python Version\nAlways specify a Python version when creating an environment:\nconda create -n my-project python=3.11\nWithout a version, conda installs whatever Python is newest — which means your environment might get Python 3.12 today and someone recreating it might get 3.13 next year. Pinning the version ensures consistency. The specific patch version (3.11.x) will be the latest available within that minor version.\n\n\n\n\n\n\nNoteBoth Conda and renv\n\n\n\nIn the lab, every project has both an environment.yml (for Python) and an renv.lock (for R), even if the project primarily uses one language. Projects evolve — what starts as an R-only analysis might later need a Python script for preprocessing, or vice versa. Having both environment files in place from the start means you don’t have to retrofit them later when you add a second language.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#conda-vs-pip",
    "href": "part2/conda.html#conda-vs-pip",
    "title": "8  Conda",
    "section": "8.8 Conda vs pip",
    "text": "8.8 Conda vs pip\nBoth conda and pip install Python packages, and you’ll sometimes need both. The general rule is simple: use conda first, fall back to pip for packages conda doesn’t have.\n# Prefer conda for scientific packages\nconda install pandas numpy scipy\n\n# Use pip for packages not in conda\npip install session-info\nMost scientific packages (pandas, numpy, scipy, scikit-learn, matplotlib) are in conda-forge and install faster and more reliably through conda. Some specialized or newer packages are only on PyPI (Python’s main package repository) and need pip.\nWhen using both in the same environment, install all your conda packages first, then pip packages. This avoids dependency conflicts. Conda is aware of pip-installed packages but can’t manage them, so installing conda packages after pip can sometimes overwrite or break pip-installed ones.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#channels",
    "href": "part2/conda.html#channels",
    "title": "8  Conda",
    "section": "8.9 Channels and Bioconda",
    "text": "8.9 Channels and Bioconda\nFor most data science work, the default conda-forge channel (which you configured in One-Time Setup) has everything you need. But if you work with bioinformatics command-line tools — things like samtools, bedtools, bwa, or STAR — you’ll need an additional channel called bioconda.\nBioconda is a channel specifically for bioinformatics software, maintained by the bioinformatics community. To add it:\nconda config --add channels bioconda\nAfter adding bioconda, you can install bioinformatics tools directly into a conda environment:\nconda create -n genomics-tools python=3.11 samtools bedtools\nYou can also specify channels in your environment.yml so collaborators get the right packages automatically:\nname: genomics-project\nchannels:\n  - conda-forge\n  - bioconda\ndependencies:\n  - python=3.11\n  - pandas\n  - samtools\n  - bedtools\nThe order of channels matters — channels listed first have higher priority. With conda-forge first, general scientific packages come from the well-tested community repository, while bioinformatics-specific tools come from bioconda.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can diagnose environment issues by checking which environment is active, what’s installed, and where packages are missing.\n\nI’m getting ModuleNotFoundError: No module named 'pandas' when I run my Python script in Positron, but I installed pandas in my conda environment. Here’s what conda list shows: [paste output]. What’s wrong?\n\nClaude will check whether the package is installed in the right environment, whether Positron is pointing at a different Python interpreter, and suggest the specific fix — often it’s as simple as selecting the right interpreter in the Command Palette.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#troubleshooting",
    "href": "part2/conda.html#troubleshooting",
    "title": "8  Conda",
    "section": "8.10 Troubleshooting",
    "text": "8.10 Troubleshooting\n\n8.10.1 macOS: “conda: command not found”\nYour shell doesn’t know where conda is. If you installed via Miniforge, run:\nsource ~/miniforge3/etc/profile.d/conda.sh\nTo make this permanent, add that line to your shell configuration file (~/.zshrc for zsh, which is the default on modern macOS, or ~/.bashrc for bash).\n\n\n8.10.2 Windows: “conda is not recognized”\nThe Miniforge installer may not have added conda to your PATH. You have two options:\n\nUse the “Miniforge Prompt” from the Start menu — this opens a terminal with conda pre-configured\nAdd Miniforge to your PATH manually: search “Environment Variables” in Windows Settings and add C:\\Users\\YourName\\miniforge3\\Scripts to your PATH\n\n\n\n8.10.3 Windows: “conda activate” Does Nothing\nThis means conda isn’t initialized for PowerShell. Run:\nconda init powershell\nThen close and reopen your terminal completely. If you’re using Positron’s integrated terminal, close and reopen the entire application.\n\n\n8.10.4 “Solving environment” Takes Forever\nYou probably haven’t set the fast solver. Run:\nconda config --set solver libmamba\nIf you’ve already set libmamba and it’s still slow, you likely have conflicting package requirements. Try loosening version constraints or starting fresh (see below).\n\n\n8.10.5 Dependency Conflicts\nConda reports “conflict” or can’t find a compatible set of packages. Try these in order:\n\nLoosen version pins — let conda choose versions instead of specifying exact ones\nStart fresh — sometimes it’s easier to recreate the environment than to fix conflicts:\n\nconda deactivate\nconda env remove -n my-project\nconda create -n my-project python=3.11 numpy pandas matplotlib ipykernel\nThen add other packages one at a time to identify which one causes the conflict.\n\n\n8.10.6 Package Not Found\nCheck the spelling, make sure conda-forge is in your channels (conda config --show channels), and search for the package: conda search package-name. If it’s not in any conda channel, install it with pip instead.\n\n\n8.10.7 Environment Seems Corrupted\nIf an environment is behaving strangely and you can’t figure out why, remove it and recreate from your environment.yml:\nconda deactivate\nconda env remove -n my-project\nconda env create -f environment.yml\nThis is the conda equivalent of renv::restore() — it rebuilds the environment from your recorded specification. This is also why keeping environment.yml up to date and committed to Git matters: it’s your safety net.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code is good at diagnosing environment and interpreter issues because it can check your conda configuration, Positron settings, and installed packages all at once.\n\nI created a conda environment called analysis-env and it shows up in conda env list, but when I open “Python: Select Interpreter” in Positron, it’s not in the list. I’ve restarted Positron already. What else can I try?\n\nClaude will check your conda installation path, Positron’s Python discovery settings, and suggest targeted fixes — often a configuration path issue or a Positron extension that needs reloading.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/conda.html#quick-reference",
    "href": "part2/conda.html#quick-reference",
    "title": "8  Conda",
    "section": "8.11 Quick Reference",
    "text": "8.11 Quick Reference\n\n\n\n\n\n\n\nTask\nCommand\n\n\n\n\nCreate environment\nconda create -n NAME python=3.11 numpy pandas matplotlib ipykernel\n\n\nActivate\nconda activate NAME\n\n\nDeactivate\nconda deactivate\n\n\nInstall package\nconda install PACKAGE\n\n\nList packages\nconda list\n\n\nList environments\nconda env list\n\n\nExport environment\nconda env export --from-history &gt; environment.yml\n\n\nCreate from file\nconda env create -f environment.yml\n\n\nRemove environment\nconda env remove -n NAME\n\n\nSet fast solver\nconda config --set solver libmamba\n\n\nSet channel priority\nconda config --set channel_priority strict\n\n\nAdd bioconda channel\nconda config --add channels bioconda",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Conda</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html",
    "href": "part2/git-github.html",
    "title": "Git & GitHub",
    "section": "",
    "text": "What is Git?\nIn Your First R Project, you wrote an analysis script, ran it, and got results. Everything was in one session — you edited, re-ran, edited some more. But what happens tomorrow, when you want to undo a change you made this afternoon? Or next month, when a reviewer asks you to re-run the analysis the way it was before you changed the normalization method? What happens when a collaborator needs to work on the same project, or when your laptop dies?\nThese are the problems Git and GitHub solve. Git keeps a complete history of every change you make to your code, and GitHub backs it up online where others can access it. Together, they form the backbone of how we manage code in the lab — think of them as the computational equivalent of a lab notebook. This chapter walks you through installing both tools, understanding how they work, and using them in your daily workflow.\nGit is a version control system — software that tracks every change you make to your files over time. Think of it as an unlimited undo history for your entire project, with the ability to see exactly what changed, when, and why.\nWithout version control, projects tend to accumulate files like this:\nWith Git, you keep one file — analysis.R — and Git tracks every version behind the scenes. You can compare any two versions to see exactly which lines were added or removed. Every saved version (called a commit) includes a message explaining what changed, so you can look back six months later and understand the evolution of your analysis. If something breaks, you can restore any previous version. And when it’s time to collaborate, multiple people can work on the same project without overwriting each other’s changes.\nGit runs locally on your computer. Every project folder that Git tracks is called a repository (or “repo” for short). The history lives in a hidden .git folder inside your project — you’ll never need to touch it directly, but knowing it’s there helps you understand what Git is doing.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#what-is-git",
    "href": "part2/git-github.html#what-is-git",
    "title": "Git & GitHub",
    "section": "",
    "text": "analysis_v1.R\nanalysis_v2.R\nanalysis_v2_final.R\nanalysis_v2_final_FINAL.R\nanalysis_v2_final_FINAL_fixed.R",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#installing-git",
    "href": "part2/git-github.html#installing-git",
    "title": "Git & GitHub",
    "section": "Installing Git",
    "text": "Installing Git\n\nmacOSWindows\n\n\nGit comes bundled with Apple’s Xcode Command Line Tools, a collection of developer utilities. Many Macs already have this installed — you may have been prompted to install it the first time you opened Terminal or ran a developer tool. To check, open Terminal and run:\ngit --version\nIf you see a version number (like git version 2.39.5), Git is already installed and you can skip ahead to Configure Your Identity.\nIf you see a popup asking to install Xcode Command Line Tools, click Install and wait for it to finish. If you get “command not found” with no popup, install manually:\nxcode-select --install\nAlternatively, if you have Homebrew installed, you can get a newer version of Git with:\nbrew install git\nAfter installation, close and reopen Terminal, then verify:\ngit --version\n\n\nDownload Git from https://git-scm.com/downloads/win. Run the installer and accept all the default settings — the defaults are well-chosen and changing them can cause confusing problems later.\nAfter installation, close and reopen PowerShell, then verify:\ngit --version\n\n\n\n\nConfigure Your Identity\nEvery Git commit is stamped with your name and email address, so collaborators (and future you) can see who made each change. Tell Git who you are by running these commands in your terminal, replacing the name and email with your own:\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\nUse the same email address you’ll use for your GitHub account. This is a one-time setup — Git remembers this configuration for all projects on your computer.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#what-is-github",
    "href": "part2/git-github.html#what-is-github",
    "title": "Git & GitHub",
    "section": "What is GitHub?",
    "text": "What is GitHub?\nGitHub is a website that hosts Git repositories online. Git and GitHub are related but different things:\n\n\n\n\nGit\nGitHub\n\n\n\n\nWhat\nSoftware on your computer\nWebsite (github.com)\n\n\nWhere\nTracks file history locally\nStores repos in the cloud\n\n\nConnectivity\nWorks offline\nRequires internet\n\n\nCost\nFree, open-source\nFree for public and private repos\n\n\n\nYou can use Git without GitHub — your history stays on your computer. But GitHub adds capabilities that matter for research: your code is backed up in the cloud (safe from laptop failures), collaborators can access and contribute to your project, and you can share your work publicly when you’re ready. GitHub also provides project management tools — Issues for tracking tasks and bugs, pull requests for reviewing changes, and a web interface for browsing code and history.\nOther Git hosting services exist (GitLab, Bitbucket), but GitHub is the most widely used in science and the one we use in the lab.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#setting-up-github",
    "href": "part2/git-github.html#setting-up-github",
    "title": "Git & GitHub",
    "section": "Setting Up GitHub",
    "text": "Setting Up GitHub\n\nCreate a GitHub Account\nIf you don’t already have one, go to github.com and sign up. Use an email address you check regularly — GitHub sends notifications when collaborators comment on your code or request your review. A professional username is best, since this will be visible on your published work (something like jsmith or jane-smith, not xXx_data_ninja_xXx).\n\n\nInstall the GitHub CLI\nThe GitHub CLI (gh) lets you interact with GitHub from your terminal — creating repositories, authenticating, and more. You don’t strictly need it (you can do everything through the GitHub website), but it makes several common tasks much faster.\n\nmacOSWindows\n\n\nIf you have Homebrew:\nbrew install gh\nIf you don’t have Homebrew, download the installer from https://cli.github.com.\n\n\nDownload the installer from https://cli.github.com. Run it and follow the prompts. Close and reopen PowerShell after installation.\n\n\n\n\n\nAuthenticate with GitHub\nRun the following command, then follow the prompts:\ngh auth login\nWhen asked, choose:\n\nGitHub.com (not Enterprise)\nHTTPS (not SSH)\nLogin with a web browser\n\nThis opens your browser where you log in with your GitHub credentials and authorize the CLI. Once complete, both gh (the GitHub CLI) and git push/git pull (regular Git) will be authenticated — you won’t need to enter passwords for routine Git operations.\nVerify it worked:\ngh auth status\nYou should see your GitHub username and “Logged in to github.com.”\n[TODO: screenshot of terminal showing gh auth login prompts and successful authentication]\n\n\nJoin the MusserLab Organization\nAsk Jake to add you to the MusserLab organization on GitHub. Once you accept the invitation (check your email or GitHub notifications), you’ll be able to create and access repositories under the MusserLab account.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#the-musserlab-organization",
    "href": "part2/git-github.html#the-musserlab-organization",
    "title": "Git & GitHub",
    "section": "The MusserLab Organization",
    "text": "The MusserLab Organization\nOn GitHub, you have a personal account (your username) and you can also belong to organizations — shared accounts for teams. The lab uses the MusserLab organization for all research projects.\n\n\n\n\n\n\n\n\nWhere\nWhen to use\nExamples\n\n\n\n\nYour personal account\nPersonal projects, coursework, learning, side projects\njsmith/practice-git, jsmith/coursework\n\n\nMusserLab organization\nAll lab research — no exceptions\nMusserLab/tryptamine-phospho, MusserLab/sponge-rnaseq\n\n\n\n\n\n\n\n\n\nImportantLab Research Belongs on the Organization\n\n\n\nIf a project involves lab research, it goes on the MusserLab organization — not your personal account. This ensures continuity when people leave, makes collaboration straightforward, and keeps all lab work in one findable place.\n\n\n\nPublic vs. Private Repositories\nEvery repository on GitHub is either public (anyone on the internet can see it) or private (only you and people you explicitly grant access can see it). Lab research repos are typically kept private while work is in progress. You can always change a repo’s visibility later.\nWhen a paper is published, we usually create a separate, curated public repository with cleaned-up code and documentation — rather than making the messy working repo public. This approach lets you work freely during research without worrying about how your commit history looks to the outside world.\n\n\nREADME: Your Project’s Landing Page\nWhen someone visits your repository on GitHub, the first thing they see is the README — a file called README.md that GitHub renders at the bottom of the file listing. A good README tells visitors what the project is, how to set it up, and how to use it. Even for private repos, a short README helps collaborators (and future you) get oriented quickly. At minimum, include a one-paragraph description of what the project does and any setup instructions a new contributor would need.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#how-git-works-the-core-ideas",
    "href": "part2/git-github.html#how-git-works-the-core-ideas",
    "title": "Git & GitHub",
    "section": "How Git Works: The Core Ideas",
    "text": "How Git Works: The Core Ideas\nBefore diving into the daily workflow, it helps to understand a few core concepts. Don’t worry about memorizing these — you’ll internalize them through use. Think of this section as a reference you can come back to.\nA repository (repo) is just a project folder that Git is tracking. When you tell Git to start tracking a folder, it creates a hidden .git directory inside that stores the entire history. Your project files look the same — Git works invisibly in the background.\nA commit is a snapshot of your project at a moment in time. Think of it like saving a version of a document, except Git saves the state of every file in your project at once. Each commit has a unique ID (like a1b2c3d), a message you write describing what changed, and a pointer to the previous commit. Commits form a chain — your project’s timeline.\nThe staging area is a holding area for changes you want to include in your next commit. When you change a file, Git notices, but it doesn’t automatically include that change in your next commit. You first stage the changes (pick which ones to include), then commit them (save the snapshot). This two-step process lets you make many changes but commit them in logical groups — for example, committing your QC filtering changes separately from your visualization updates.\nA branch is a parallel version of your project. The default branch is called main. You can create other branches to experiment without affecting main, then merge them back when ready. We’ll come back to branches later in this chapter.\nA remote is a copy of your repository on another computer — typically GitHub. Your local repo and the remote stay in sync through pushing (uploading your commits) and pulling (downloading others’ commits).",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#your-first-commit",
    "href": "part2/git-github.html#your-first-commit",
    "title": "Git & GitHub",
    "section": "Your First Commit",
    "text": "Your First Commit\nThe best way to learn Git is to use it. This walkthrough uses Positron’s Source Control panel, which gives you a visual interface for all the common Git operations. You’ll need a project that’s a Git repository. If you worked through Your First R Project, open that my-first-analysis folder in Positron and initialize it as a Git repository by running this in Positron’s terminal (Cmd+` or Ctrl+`):\ngit init\nYou should see “Initialized empty Git repository.” Now Git is tracking that folder, and you can follow along below.\n\nOpen the Source Control Panel\nClick the branch icon in Positron’s left sidebar, or press Cmd+Shift+G (macOS) / Ctrl+Shift+G (Windows). If there are no changes since your last commit, the panel will be mostly empty — that’s normal.\n\n\nMake a Change\nOpen any file in your project and make a small edit — add a comment, fix a typo, or change a line of code. Save the file.\n\n\nSee What Changed\nSwitch back to the Source Control panel. Your edited file appears under Changes, with a letter indicating what happened:\n\nM (Modified) — an existing file was changed\nU (Untracked) — a new file Git hasn’t seen before\nD (Deleted) — a file was removed\nA (Added) — a new file that’s been staged\n\nClick the filename to see a diff view — a side-by-side comparison showing exactly which lines were added (highlighted in green) and removed (highlighted in red). This is one of Git’s most useful features: before committing, you can review exactly what you’re about to save.\n[TODO: screenshot of Positron Source Control panel showing a modified file and the diff view]\n\n\nStage Your Changes\nClick the + icon next to the file. It moves from “Changes” to “Staged Changes” — this means you’ve selected it for your next commit. You don’t have to stage everything at once. If you made unrelated changes to several files, you can commit them separately with different messages, keeping your history clean and meaningful.\n\n\nWrite a Message and Commit\nType a message in the text box at the top of the Source Control panel. Something like “Add QC filtering step” or “Fix sample labeling in metadata” — a short description of what this change does. Then click the checkmark (✓) to commit.\nThat’s it — you’ve made a commit. The Source Control panel clears, and your change is recorded in Git’s history. But right now, this commit only exists on your computer. GitHub doesn’t know about it yet.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can commit your work for you, writing descriptive commit messages based on what actually changed.\n\nI just finished filtering the dataset and updating the QC thresholds. Can you commit these changes with a good message?\n\nClaude will look at your staged changes, write a message that describes what you did, and make the commit. This is especially useful when you’ve made many changes and aren’t sure how to summarize them. The lab’s /done skill does this automatically at the end of a work session.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#pushing-to-github",
    "href": "part2/git-github.html#pushing-to-github",
    "title": "Git & GitHub",
    "section": "Pushing to GitHub",
    "text": "Pushing to GitHub\nA commit saves your changes locally. Pushing uploads those commits to GitHub, where they’re backed up and accessible to collaborators. Think of it this way: committing is saving your work, pushing is backing it up.\n\n\n\n\n\n\nNoteFirst Push Requires a Remote\n\n\n\nIf you started your project with git init (as in the walkthrough above), Git doesn’t know where on GitHub to send your code yet. You need to create a GitHub repository first — see Creating a New Repo below for how to do that. If you cloned an existing repository from GitHub, the remote is already configured and you can push right away.\n\n\nTo push from Positron, click the three-dot menu (⋯) at the top of the Source Control panel and select Push. You can also click the sync icon in the status bar at the bottom of the window — it pushes your commits and pulls any new ones from GitHub in one step.\n\nPull Before You Start\nIf you’re collaborating with someone, or if you work from multiple computers, get in the habit of pulling before you start working. Pulling downloads any new commits from GitHub that you don’t have locally. Click the three-dot menu → Pull, or use the sync icon. This avoids conflicts later — it’s much easier to integrate changes before you start editing than after.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#writing-good-commit-messages",
    "href": "part2/git-github.html#writing-good-commit-messages",
    "title": "Git & GitHub",
    "section": "Writing Good Commit Messages",
    "text": "Writing Good Commit Messages\nYour commit messages become part of your project’s history — a record of what you did and why. Good messages make that history useful; bad messages make it noise.\nBad messages:\nupdate\nfix\nchanges\nasdf\nThese tell you nothing. Six months later, you won’t remember what “update” meant.\nGood messages:\nAdd QC step to filter samples with &lt;1000 genes detected\nFix off-by-one error causing last sample to be dropped\nUpdate normalization to use SCTransform instead of LogNormalize\nRemove outlier samples identified in PCA (samples 12, 47)\nThese explain what changed and often why. When you look at the history, each message is a chapter in the story of your analysis.\n\nWhen to Commit\nCommit when you’ve completed a logical unit of work: finished a new analysis step, fixed a bug, added a figure, or made a decision you want to record. Don’t wait until the end of the day to make one giant commit. Small, focused commits are easier to understand and easier to undo if needed.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#what-to-track-and-what-to-ignore",
    "href": "part2/git-github.html#what-to-track-and-what-to-ignore",
    "title": "Git & GitHub",
    "section": "What to Track and What to Ignore",
    "text": "What to Track and What to Ignore\nNot everything in your project folder belongs in Git. Code, documentation, and configuration files should be tracked. Large data files, generated outputs, credentials, and system junk should not.\nThe .gitignore file tells Git which files and folders to skip. Place it in the root of your project and Git will ignore anything that matches the patterns inside. Here’s a simplified version for a typical lab project:\n# Generated outputs (reproducible from code)\nouts/\n\n# R artifacts\n.Rhistory\n.RData\nrenv/library/\nrenv/staging/\n\n# Python artifacts\n__pycache__/\n\n# Quarto rendering\n*_files/\n*_cache/\n.quarto/\n\n# Secrets - NEVER commit these\n.env\n*credentials*\n\n# OS and IDE files\n.DS_Store\nThumbs.db\n.positron/\nSee the Setting Up a Lab Project chapter for a more complete .gitignore template. The key principle: track things humans write, ignore things computers generate. If a file can be recreated by running your code, it probably doesn’t belong in Git.\n\n\n\n\n\n\nImportantCreate .gitignore First\n\n\n\nSet up .gitignore before your first commit. Once a file is committed, adding it to .gitignore won’t remove it from history — it’s already tracked. Getting this right from the start saves headaches later.\n\n\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can create a .gitignore tailored to your specific project setup.\n\nI’m starting a new R project that will also use Python for some preprocessing. I’m using renv for R packages and conda for Python. Can you create a .gitignore file?\n\nClaude will generate a .gitignore with the right patterns for both languages — renv cache, conda environments, data files, Quarto artifacts, and OS-specific junk files.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#getting-a-repository",
    "href": "part2/git-github.html#getting-a-repository",
    "title": "Git & GitHub",
    "section": "Getting a Repository",
    "text": "Getting a Repository\nThere are two common scenarios: joining an existing project, or starting a new one.\n\nCloning an Existing Repo\nIf a repository already exists on GitHub and you want to work on it:\n\nGo to the repo on GitHub\nClick the green Code button and copy the HTTPS URL\nIn Positron, open the Command Palette (Cmd/Ctrl+Shift+P) and type “Git: Clone”\nPaste the URL and choose where to save it\n\nPositron downloads the repository and opens it as your workspace. You can start working immediately.\n\n\nCreating a New Repo\nFor a brand new project, the easiest approach is to create the repo on GitHub first, then clone it to your computer:\n\nGo to github.com and click New repository (the + icon in the top right)\nChoose the MusserLab organization as the owner (for lab projects)\nGive it a short, descriptive name (lowercase with hyphens, like sponge-rnaseq)\nSet visibility to Private\nCheck Add a README file\nClone it to your computer using the steps above\n\nThis sets up the remote connection correctly from the start. The Setting Up a Lab Project chapter walks through the full project creation workflow, including folder structure, environments, and first commit.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#exploring-github",
    "href": "part2/git-github.html#exploring-github",
    "title": "Git & GitHub",
    "section": "Exploring GitHub",
    "text": "Exploring GitHub\nGitHub is more than just a place to store code — it’s a project management tool with a web interface that you’ll use regularly. When you visit a repository on GitHub, you’ll see several useful features.\n\nBrowsing Files and History\nThe main page of any repository shows the file listing — all files and folders in the project, just like a file explorer. Click any file to view its contents directly in the browser. This is useful for quickly checking a collaborator’s code or reading documentation without cloning the entire repository.\nAbove the file listing, you’ll see the most recent commit message and when it was made. Click Commits (or the commit count) to see the full history — every commit ever made, in reverse chronological order. Click any commit to see exactly what changed: the diff view shows added lines in green and removed lines in red, just like Positron’s Source Control panel.\n[TODO: screenshot of a GitHub repository page showing the file listing, recent commit, and README]\n\n\nIssues: Tracking Tasks and Bugs\nGitHub Issues are a lightweight way to track tasks, bugs, and questions for a project. Think of them as a shared to-do list. Each issue has a title, a description, and a discussion thread where collaborators can comment.\nTo create an issue, click the Issues tab at the top of the repository and then New issue. Give it a clear title (“QC thresholds need updating for new batch”) and describe what needs to happen. You can assign issues to specific people and add labels like “bug” or “enhancement” to organize them.\nThe real power of issues comes from linking them to commits. When you include an issue number in a commit message — like Fix normalization bug (closes #12) — GitHub automatically closes the issue when that commit reaches the main branch. This creates a traceable record: the issue describes the problem, and the linked commit shows exactly how it was fixed.\n[TODO: screenshot of a GitHub Issue showing the title, description, and a linked commit]\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can help you understand confusing Git messages and suggest safe next steps.\n\nGit is showing me this and I’m not sure what to do: Your branch and 'origin/main' have diverged, and have 2 and 3 different commits each, respectively. What does this mean and how do I fix it?\n\nClaude will explain the situation in plain language — your local and remote branches have different changes that need to be reconciled — and walk you through resolving it safely.\n\n\n\n\nOther Useful GitHub Features\nA few more things worth knowing about as you use GitHub:\nAdding collaborators. To give someone access to a private repo, go to Settings → Collaborators and invite them by GitHub username. You can choose their permission level — Write access is what active collaborators need.\nForking. If you want to experiment with someone else’s public repository without affecting the original, you can fork it — this creates a copy under your account. Any changes you make stay in your fork unless you submit a pull request back to the original.\nGitHub in your browser vs. on your computer. Anything you do on GitHub’s website (creating issues, editing files, browsing history) affects the remote repository. To get those changes on your local computer, you need to pull. Anything you do on your computer (editing code, committing) stays local until you push.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#as-your-projects-grow-branches-and-pull-requests",
    "href": "part2/git-github.html#as-your-projects-grow-branches-and-pull-requests",
    "title": "Git & GitHub",
    "section": "As Your Projects Grow: Branches and Pull Requests",
    "text": "As Your Projects Grow: Branches and Pull Requests\nFor solo analysis work, the workflow described above — edit, commit, push to main — is all you need. But as projects grow or involve more people, two features become valuable: branches and pull requests.\nA branch is a parallel version of your project. Imagine you want to try a completely different normalization approach, but you’re not sure it will work. Instead of making changes directly on main (and potentially breaking something), you create a branch — a copy where you can experiment freely. If the experiment works, you merge the branch back into main. If it doesn’t, you delete it, and main is untouched. Positron’s status bar shows which branch you’re on, and the Source Control panel lets you create and switch branches.\nA pull request (PR) is GitHub’s way of proposing changes for review before merging them into main. Instead of merging your branch yourself, you open a pull request on GitHub, where collaborators can see your changes, leave comments, and discuss before the merge happens. Pull requests are most valuable when you want another pair of eyes on your work — they create a clear, documented record of when and why a set of changes was incorporated.\nFor now, you don’t need to use branches or pull requests. But knowing they exist helps when you encounter them in collaborative projects or when Claude Code suggests using them. The Collaborating chapter covers these workflows in detail.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#best-practices",
    "href": "part2/git-github.html#best-practices",
    "title": "Git & GitHub",
    "section": "Best Practices",
    "text": "Best Practices\n\nCommit often, push regularly\n\nSmall commits are easier to understand. Pushing backs up your work. Don’t let changes pile up.\n\nPull before you start working\n\nEspecially on shared projects — get others’ changes before you start yours.\n\nWrite meaningful commit messages\n\nFuture-you will thank present-you. Describe what changed and why.\n\nUse .gitignore from the start\n\nPrevent large files and secrets from ever entering the repo.\n\nDon’t panic\n\nGit rarely loses data. Most mistakes are recoverable — if you see an error message you don’t understand, ask Claude Code before trying to fix it yourself.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "part2/git-github.html#learning-more",
    "href": "part2/git-github.html#learning-more",
    "title": "Git & GitHub",
    "section": "Learning More",
    "text": "Learning More\nThis chapter covers what you need to use Git effectively in your daily work. If you want to go deeper — learning command-line Git, understanding how Git works internally, or mastering advanced workflows — these resources are excellent:\n\nPro Git Book: The comprehensive, free reference. Covers everything from basics to internals.\nGitHub Docs: Practical guides focused on common tasks.",
    "crumbs": [
      "Core Tools",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html",
    "href": "claude-code/getting-started.html",
    "title": "10  Getting Started with Claude Code",
    "section": "",
    "text": "10.1 Before You Start\nClaude Code is an AI assistant that works directly with your project files. Unlike web-based AI chat, it can read your code, edit files, run commands, and search across your codebase, all within the context of your project.\nIf you followed the Installation chapter, you’ve already installed Claude Code, authenticated, and added the Positron extension. If you skipped that chapter or need a refresher, here’s what you need:\nIf any of those steps are unfamiliar, work through Section 2.4 first.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#before-you-start",
    "href": "claude-code/getting-started.html#before-you-start",
    "title": "10  Getting Started with Claude Code",
    "section": "",
    "text": "Node.js installed (nodejs.org)\nClaude Code CLI installed: npm install -g @anthropic-ai/claude-code\nAuthenticated: run claude in your terminal once and log in with your Anthropic account\nPositron extension: Extensions view → search “Claude Code” → Install",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#using-claude-code-in-positron",
    "href": "claude-code/getting-started.html#using-claude-code-in-positron",
    "title": "10  Getting Started with Claude Code",
    "section": "10.2 Using Claude Code in Positron",
    "text": "10.2 Using Claude Code in Positron\nThe easiest way to use Claude Code is through the Positron extension. This keeps your code, terminal, and AI assistant in one window.\nTo open Claude Code in Positron:\n\nOpen your project folder in Positron\nClick the Claude Code icon in the left sidebar (or use Cmd+Shift+P → “Claude Code: Open”)\nStart typing in the chat panel\n\nThe extension automatically knows which project you’re working in and can see your files.\nKey shortcuts:\n\n\n\nAction\nShortcut\n\n\n\n\nSubmit message\nEnter (or Cmd+Enter depending on settings)\n\n\nNew conversation\nClick “+” or Cmd+N in the Claude panel\n\n\nReference a file\nType @ and start typing the filename\n\n\n\n\n10.2.1 Terminal Alternative\nYou can also run Claude Code directly in any terminal by navigating to your project directory and typing claude. This gives you the same capabilities as the extension — reading files, editing code, running commands — but in a terminal interface rather than a sidebar panel. Some people prefer this, especially for quick one-off questions or when working outside Positron.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#what-claude-code-can-do",
    "href": "claude-code/getting-started.html#what-claude-code-can-do",
    "title": "10  Getting Started with Claude Code",
    "section": "10.3 What Claude Code Can Do",
    "text": "10.3 What Claude Code Can Do\n\n\n\n\n\n\n\nCapability\nExamples\n\n\n\n\nUnderstand code\nExplain functions, trace data flow, find patterns\n\n\nWrite code\nCreate scripts, write functions, generate boilerplate\n\n\nEdit files\nFix bugs, refactor, add features to existing files\n\n\nRun commands\nExecute R/Python scripts, git operations, quarto render\n\n\nSearch\nFind where things are defined, grep for patterns\n\n\nDebug\nTrace errors, explain stack traces, suggest fixes",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#when-to-use-claude-code",
    "href": "claude-code/getting-started.html#when-to-use-claude-code",
    "title": "10  Getting Started with Claude Code",
    "section": "10.4 When to Use Claude Code",
    "text": "10.4 When to Use Claude Code\nClaude Code is helpful for:\n\nSetting up project structure and boilerplate\nDebugging cryptic error messages\nUnderstanding unfamiliar code in a project\nWriting repetitive code (data loading, plotting templates)\nTroubleshooting environment issues (conda, renv, paths)\nExplaining what code does and how components connect\n\nClaude Code is not a replacement for:\n\nYour analytical judgment (you decide normalization methods, thresholds, interpretations)\nYour domain expertise (you know biology, Claude knows code)\nCareful code review (always verify outputs, especially for statistics)\nUnderstanding methods you’ll use repeatedly (learn them, don’t just copy-paste)\n\n\n\n\n\n\n\nNoteThe division of labor\n\n\n\nYou bring the scientific knowledge and analytical decisions. Claude Code brings coding speed and pattern recognition. The combination is powerful, but you’re always the one making the calls.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#the-mental-model",
    "href": "claude-code/getting-started.html#the-mental-model",
    "title": "10  Getting Started with Claude Code",
    "section": "10.5 The Mental Model",
    "text": "10.5 The Mental Model\nThree concepts help you work effectively with Claude Code:\n\n10.5.1 1. Capable but not omniscient\nClaude can write sophisticated code, but it doesn’t automatically know:\n\nYour specific data structures and conventions\nYour project’s history and past decisions\nWhat you’ve tried before and why it didn’t work\n\nSolution: Tell Claude what it needs to know. Be specific about your data, your goals, and any constraints.\n\n\n10.5.2 2. Context matters\nClaude only knows what’s in your project folder and what you tell it. Each new conversation starts fresh—it doesn’t remember yesterday’s session.\nSolution: Use project configuration files (covered in the next chapter) to give Claude persistent context about your project.\n\n\n10.5.3 3. Verify, then trust\nClaude often gets things right, but sometimes produces plausible-looking code with subtle bugs, especially for:\n\nStatistical methods it doesn’t fully understand\nEdge cases in your specific data\nDomain-specific conventions it guesses at\n\nSolution: Run the code and check the outputs. For analytical code, verify counts at each step and spot-check results.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#a-quick-example",
    "href": "claude-code/getting-started.html#a-quick-example",
    "title": "10  Getting Started with Claude Code",
    "section": "10.6 A Quick Example",
    "text": "10.6 A Quick Example\nHere’s what a typical interaction looks like in Positron:\nYou type: &gt; I’m getting this error when I run the script: &gt; &gt; Error in left_join(): ! by must be supplied when x and y have no common variables. &gt; &gt; The join is on line 45 of analysis.qmd\nClaude responds: - Reads the relevant section of analysis.qmd - Explains that the column names don’t match between the two dataframes - Shows you the column names in each - Proposes a fix with the correct by = argument - Asks if you want to apply the edit\nYou review the proposed change, accept it, and the file is updated.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#reviewing-changes",
    "href": "claude-code/getting-started.html#reviewing-changes",
    "title": "10  Getting Started with Claude Code",
    "section": "10.7 Reviewing Changes",
    "text": "10.7 Reviewing Changes\nClaude always shows you what it plans to do:\n\nFile edits — Shows a diff with the proposed changes highlighted\nNew files — Shows the full content before writing\nCommands — Shows the command before running it\n\nYou can:\n\nAccept the change\nAsk for modifications (“Can you also add error handling for empty files?”)\nReject and try a different approach (“Actually, let’s do this a different way”)",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/getting-started.html#next-steps",
    "href": "claude-code/getting-started.html#next-steps",
    "title": "10  Getting Started with Claude Code",
    "section": "10.8 Next Steps",
    "text": "10.8 Next Steps\nNow that you understand what Claude Code can do, the following chapters cover:\n\nConfiguring Projects — How to give Claude persistent context about your project\nSkills — Reusable instruction sets for common tasks\nWorking Effectively — Patterns for productive Claude Code sessions",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Getting Started with Claude Code</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html",
    "href": "claude-code/configuring-projects.html",
    "title": "11  Configuring Your Project for Claude",
    "section": "",
    "text": "11.1 The Two Levels of Configuration\nClaude Code reads configuration files to understand your project and work effectively. This chapter explains how to set up these files—from a simple project CLAUDE.md to plan files for tracking complex work.\nClaude reads both at session start. Project instructions take precedence when they conflict.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#the-two-levels-of-configuration",
    "href": "claude-code/configuring-projects.html#the-two-levels-of-configuration",
    "title": "11  Configuring Your Project for Claude",
    "section": "",
    "text": "Level\nLocation\nPurpose\n\n\n\n\nUser\n~/.claude/CLAUDE.md\nPreferences that apply to ALL your projects\n\n\nProject\n.claude/CLAUDE.md\nContext specific to THIS project",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#creating-your-project-claude.md",
    "href": "claude-code/configuring-projects.html#creating-your-project-claude.md",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.2 Creating Your Project CLAUDE.md",
    "text": "11.2 Creating Your Project CLAUDE.md\nCreate a .claude/ folder in your project root with a CLAUDE.md file inside. This file answers: “What does Claude need to know to work effectively here?”\n\n11.2.1 Minimal Example (Course Project)\n# Stats 101 Final Project\n\n## Overview\nAnalysis of penguin body measurements to predict species.\n\n## Data\n- Raw data: `data/penguins.csv` (from palmerpenguins package)\n- 344 observations, 8 variables\n\n## Workflows\nRender the analysis: `quarto render analysis.qmd`\n\n## Conventions\n- Use tidyverse style\n- theme_classic() for all plots\n\n\n11.2.2 Full Template (Research Project)\n# Project: [Name]\n\n## Overview\n[One paragraph: what does this project do? What's its current state?]\n\n## Environment\n- **Python**: `conda activate [env-name]`\n- **R**: Uses renv (auto-activates)\n\n## Repository Layout\nproject/ ├── data/ # External inputs (read-only) ├── scripts/ # Quarto analysis scripts (.qmd) │ └── exploratory/ # One-off analyses ├── outs/ # All script-generated outputs ├── R/ # Shared R helper functions └── python/ # Shared Python helper functions\n\n## Key Files\n- `scripts/01_analysis.qmd` — Primary analysis script\n- `data/counts.csv` — Input data (10,000 genes × 50 samples)\n- `outs/01_analysis/` — Analysis outputs (figures, tables)\n\n## Workflows\n\n### Run the analysis\n```default\nquarto render analysis/main.qmd",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#conventions",
    "href": "claude-code/configuring-projects.html#conventions",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.3 Conventions",
    "text": "11.3 Conventions\n\nFigures use the lab color palette (see scripts/theme.R)\nCommit after each logical step\nDescriptive variable names (no single letters)",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#gotchas",
    "href": "claude-code/configuring-projects.html#gotchas",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.4 Gotchas",
    "text": "11.4 Gotchas\n\nMemory error with full dataset—use subset for testing\nSample IDs in data/ are 1-indexed, in metadata/ are 0-indexed\n\n\n### What Makes a Good CLAUDE.md\n\n| Principle | Example |\n|-----------|---------|\n| **Be specific about data** | \"10,000 genes × 50 samples, raw counts\" not \"gene expression data\" |\n| **Document the non-obvious** | Quirks, conventions, known issues |\n| **Include actual commands** | `quarto render analysis.qmd` not \"run the analysis\" |\n| **Keep it current** | Update as the project evolves |\n\n## Evolving Your Project Documentation\n\nYour CLAUDE.md should grow with the project:\n\n| When | What to add |\n|------|-------------|\n| **After debugging** | Add the gotcha so future sessions don't hit it again |\n| **After decisions** | Document analytical choices and why you made them |\n| **After refactoring** | Update folder structure, rename files |\n| **After collaboration** | Note team conventions and workflows |\n\n**Good habit:** At the end of each session, ask yourself: \"What did I learn that future sessions should know?\" Then add it.\n\n## Plan Files for Complex Projects\n\nFor projects with many tasks—multiple figures, several analyses, ongoing work—use dedicated **plan files** alongside your main CLAUDE.md.\n\n### When to Use Plan Files\n\n- Tracking multiple figures or outputs\n- Managing a multi-step analysis pipeline\n- Recording decisions that affect multiple parts of the project\n- Keeping a running status of what's done and what's pending\n\n### Example: PLOTTING_PLAN.md\n\n```markdown\n# Plotting Plan\n\n## Quick Reference\n- Input data: `outs/03_differential/results.rds`\n- Output directory: `outs/04_figures/`\n- Standard dimensions: 8×6 inches (main), 4×4 (supplementary)\n\n## Technical Decisions\n\n| Decision | Resolution |\n|----------|------------|\n| Color palette | viridis for continuous, Set1 for categorical |\n| Font size | 12pt base, 10pt for legends |\n| Format | PDF for publication, PNG for presentations |\n\n## Figure Status\n\n### Figure 1: Sample Overview\n- **Status**: DONE\n- **Script**: `scripts/fig1_overview.R`\n- **Notes**: Log scale for y-axis; reviewer requested in revision\n\n### Figure 2: Differential Expression Volcano\n- **Status**: IN PROGRESS\n- **Script**: `scripts/fig2_volcano.R`\n- **Blocked**: Need to finalize FDR threshold with PI\n\n### Figure 3: Pathway Enrichment\n- **Status**: TODO\n- **Requirements**: Complete DE analysis first\n\n11.4.1 Example: DATA_NOTES.md\n# Data Documentation\n\n## Raw Data\n\n### counts.csv\n- Source: Core facility, batch 2024-01\n- Dimensions: 10,234 genes × 48 samples\n- Format: Raw counts (not normalized)\n- Known issues: Sample S23 failed QC, excluded\n\n### metadata.csv\n- Columns: sample_id, condition, batch, sex, age\n- Condition levels: control, treatment_low, treatment_high\n- Note: age is in weeks, not days\n\n## Processed Data\n\n### counts_normalized.rds\n- Created by: `analysis/01_normalization.qmd`\n- Method: TMM normalization via edgeR\n- Genes filtered: kept 8,456 with CPM &gt; 1 in at least 3 samples\n\n\n11.4.2 Why Plan Files Help\n\nClaude sees them — Claude reads your .claude/ folder and understands project status\nTrack decisions — No repeating the same discussions across sessions\nReview progress — When you return after a break, you know what’s done\nShare status — Collaborators can see what’s pending",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#multi-file-.claude-structure",
    "href": "claude-code/configuring-projects.html#multi-file-.claude-structure",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.5 Multi-File .claude/ Structure",
    "text": "11.5 Multi-File .claude/ Structure\nAs projects grow, organize your .claude/ folder:\n.claude/\n├── CLAUDE.md                  # Main project overview\n├── PLOTTING_PLAN.md           # Figure tracking\n├── DATA_NOTES.md              # Data documentation\n├── ANALYSIS_DECISIONS.md      # Analytical choices with rationale\n└── settings.local.json        # Claude Code settings (auto-generated)\nReference plan files from your main CLAUDE.md:\n## Documentation\n\nSee also:\n- `PLOTTING_PLAN.md` — Figure status and conventions\n- `DATA_NOTES.md` — Data sources and processing",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#user-level-configuration",
    "href": "claude-code/configuring-projects.html#user-level-configuration",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.6 User-Level Configuration",
    "text": "11.6 User-Level Configuration\nYour ~/.claude/CLAUDE.md contains preferences that apply across all projects:\n# User-Level Instructions\n\n## Environment\n- Conda must be sourced before activation:\n  `source ~/miniconda3/etc/profile.d/conda.sh`\n- Quarto is at `/usr/local/bin/quarto`\n\n## Preferences\n- Use tidyverse style for R code\n- Show data dimensions after loading\n- theme_classic() for all plots\n\n## Troubleshooting Notes\n- \"renv out of sync\" warnings can be ignored; run `renv::status()` if concerned\n\n## Available Skills\nSee `~/.claude/skills/` for specialized instructions.\nKeep user-level instructions general. Project-specific details go in the project file.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#checking-your-configuration",
    "href": "claude-code/configuring-projects.html#checking-your-configuration",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.7 Checking Your Configuration",
    "text": "11.7 Checking Your Configuration\nStart a new Claude Code session and ask:\nWhat do you know about this project?\nClaude will summarize what it learned from your configuration. If something’s missing or wrong, update your files.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/configuring-projects.html#what-not-to-include",
    "href": "claude-code/configuring-projects.html#what-not-to-include",
    "title": "11  Configuring Your Project for Claude",
    "section": "11.8 What NOT to Include",
    "text": "11.8 What NOT to Include\n\nSensitive data — No API keys, passwords, or private information\nObvious things — No need to explain what git commit does\nLengthy docs — Link to documentation rather than copying it in\nTemporary notes — Keep those in a separate scratch file",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Configuring Your Project for Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html",
    "href": "claude-code/skills.html",
    "title": "12  Skills",
    "section": "",
    "text": "12.1 How Skills Work\nSkills are reusable instruction sets that customize Claude Code’s behavior for specific tasks. Think of them as “expert modes”—when you’re doing git work, the git skill loads; when you’re plotting in R, the plotting skill loads.\nSkills live in folders with a SKILL.md file:\nClaude Code loads relevant skills based on:",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#how-skills-work",
    "href": "claude-code/skills.html#how-skills-work",
    "title": "12  Skills",
    "section": "",
    "text": "~/.claude/skills/\n├── data-handling/\n│   └── SKILL.md\n├── r-plotting-style/\n│   └── SKILL.md\n└── git-conventions/\n    └── SKILL.md\n\n\nThe task you’re performing (writing code, committing, plotting)\nFile types you’re working with (.qmd, .R, .py)\nKeywords in your requests",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#types-of-skills",
    "href": "claude-code/skills.html#types-of-skills",
    "title": "12  Skills",
    "section": "12.2 Types of Skills",
    "text": "12.2 Types of Skills\n\n12.2.1 Background Skills\nThese load automatically based on context—you don’t invoke them directly.\n\n\n\n\n\n\n\n\nSkill\nWhen It Activates\nWhat It Does\n\n\n\n\ndata-handling\nWriting R/Python analysis code\nShows data summaries at key steps (glimpse(), row counts); annotates analytical decisions in comments; validates joins to prevent silent data loss; asks you before making important analytical choices\n\n\nr-plotting-style\nCreating ggplot2 visualizations\nUses theme_classic() base with no grid lines; applies ggrepel for labels; keeps sizing consistent across related plots\n\n\nfile-safety\nCreating or modifying files\nPrevents overwriting collaborator outputs or raw data; creates versioned filenames instead; asks before uncertain overwrites\n\n\ngit-conventions\nGit operations (commit, push, etc.)\nAdds co-author line to commits; reviews staged changes; avoids committing secrets or large files\n\n\nconda-env\nRunning Python scripts or pip\nSources conda profile script before activating environments (required in Claude’s non-interactive shell)\n\n\nr-renv\nWorking in R projects with renv.lock\nExplains “out-of-sync” warnings; reminds about renv::snapshot() after installing packages\n\n\nquarto-docs\nRendering .qmd files\nUses quarto render CLI (not rmarkdown::render()); knows format options and common errors\n\n\n\n\n\n12.2.2 User-Invocable Skills (Slash Commands)\nThese are commands you invoke explicitly by typing /command:\n\n\n\n\n\n\n\n\nCommand\nWhen to Use\nWhat It Does\n\n\n\n\n/done\nEnd of a working session\nSummarizes accomplishments; checks if renv needs updating; offers to commit changes with descriptive message; optionally publishes Quarto sites\n\n\n/publish\nAfter changes to a Quarto book/website\nCommits current changes and runs quarto publish gh-pages\n\n\n/quarto-book-setup\nStarting a new documentation project\nCreates Quarto book structure with GitHub Pages configuration",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#anatomy-of-a-skill",
    "href": "claude-code/skills.html#anatomy-of-a-skill",
    "title": "12  Skills",
    "section": "12.3 Anatomy of a Skill",
    "text": "12.3 Anatomy of a Skill\nA skill file has two parts:\n1. Frontmatter — Metadata about the skill\n---\nname: skill-name\ndescription: When to use this skill\nuser-invocable: false  # or true for /commands\n---\n2. Instructions — The actual guidance\n# Skill Title\n\n## When This Applies\n[Conditions when Claude should follow these instructions]\n\n## Instructions\n[What Claude should do]\n\n## Examples\n[Code patterns and templates]",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#example-the-data-handling-skill",
    "href": "claude-code/skills.html#example-the-data-handling-skill",
    "title": "12  Skills",
    "section": "12.4 Example: The data-handling Skill",
    "text": "12.4 Example: The data-handling Skill\nThis skill ensures Claude shows you what’s happening to your data:\n---\nname: data-handling\ndescription: Data handling best practices for R and Python analysis scripts\nuser-invocable: false\n---\n\n# Data Handling Best Practices\n\n## Show Data at Key Steps\n\nAfter loading or transforming data, show dimensions:\n\n\\```r\ndata &lt;- read_csv(\"data.csv\")\ncat(\"Loaded\", nrow(data), \"rows,\", ncol(data), \"columns\\n\")\nglimpse(data)\n\\```\n\n## Validate Joins\n\nReport what happened after joins:\n\n\\```r\nmerged &lt;- left_join(a, b, by = \"id\")\ncat(\"Joined:\", nrow(a), \"→\", nrow(merged), \"rows\\n\")\ncat(\"Unmatched:\", sum(is.na(merged$value)), \"\\n\")\n\\```\n\n## Ask Before Analytical Decisions\n\nFor consequential choices (normalization, thresholds, tests),\npresent options and ask before proceeding.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#project-specific-skills",
    "href": "claude-code/skills.html#project-specific-skills",
    "title": "12  Skills",
    "section": "12.5 Project-Specific Skills",
    "text": "12.5 Project-Specific Skills\nFor domain knowledge that only applies to one project, create skills in the project’s .claude/ folder:\nmy-project/.claude/\n└── skills/\n    └── gene-naming/\n        └── SKILL.md\n\n12.5.1 When to Create a Project Skill\n\nConventions specific to this project’s data\nDomain knowledge Claude needs to apply correctly\nCode patterns that should be consistent across the project\n\n\n\n12.5.2 Example: Gene Naming Skill\n---\nname: gene-naming\ndescription: Gene ID conventions for this transcriptomics project\nuser-invocable: false\n---\n\n# Gene Naming Conventions\n\n## ID Formats\n- Trinity IDs: `TRINITY_DN12345_c0_g1_i1`\n- Short names: stored in `Gene.short` column\n- Official symbols: stored in `Gene.symbol` column\n\n## Joining Pattern\n\nAlways join on `trinity_gene_id`, not `Gene.short`:\n\n\\```r\n# CORRECT\ndata %&gt;% left_join(annotations, by = \"trinity_gene_id\")\n\n# WRONG - Gene.short may have duplicates\ndata %&gt;% left_join(annotations, by = \"Gene.short\")\n\\```\n\n## Common Pitfall\n\nGene names may contain apostrophes (5'→3' exonuclease).\nAlways normalize:\n\\```r\nmutate(Gene.short = str_replace_all(Gene.short, \"'\", \"'\"))\n\\```",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#creating-your-own-skills",
    "href": "claude-code/skills.html#creating-your-own-skills",
    "title": "12  Skills",
    "section": "12.6 Creating Your Own Skills",
    "text": "12.6 Creating Your Own Skills\n\n12.6.1 1. Identify the Pattern\nWhat instructions do you repeat? Common candidates:\n\nCoding style preferences\nDocumentation requirements\nDomain-specific conventions\nTesting practices\n\n\n\n12.6.2 2. Create the Skill\n# User-level (applies to all projects)\nmkdir -p ~/.claude/skills/my-skill\n\n# Project-level (applies to this project only)\nmkdir -p .claude/skills/my-skill\n\n\n12.6.3 3. Write SKILL.md\n---\nname: my-skill\ndescription: Brief description of what this skill does\nuser-invocable: false\n---\n\n# Skill Title\n\n## Instructions\n\nBe specific. Show examples.\n\n\\```r\n# Show the pattern you want\nexample_code()\n\\```\n\n\n12.6.4 4. Test It\nStart a new Claude Code session and try a task that should trigger your skill. Refine as needed.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#skill-best-practices",
    "href": "claude-code/skills.html#skill-best-practices",
    "title": "12  Skills",
    "section": "12.7 Skill Best Practices",
    "text": "12.7 Skill Best Practices\n\n\n\n\n\n\n\nPractice\nWhy\n\n\n\n\nBe specific\nVague instructions produce vague results\n\n\nShow examples\nCode examples are clearer than descriptions\n\n\nKeep skills focused\nOne skill = one concern\n\n\nInclude the “why”\nHelps Claude make good judgment calls\n\n\nUpdate as you learn\nSkills should evolve with your understanding",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/skills.html#sharing-skills",
    "href": "claude-code/skills.html#sharing-skills",
    "title": "12  Skills",
    "section": "12.8 Sharing Skills",
    "text": "12.8 Sharing Skills\nSkills are just text files. To share with lab members:\n\nCopy the skill folder\nHave them paste it into their ~/.claude/skills/\n\nOr include lab-wide skills in a shared repository that everyone clones.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Skills</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html",
    "href": "claude-code/working-effectively.html",
    "title": "13  Working Effectively with Claude",
    "section": "",
    "text": "13.1 Prompt Patterns That Work\nThis chapter covers practical patterns for productive Claude Code sessions—how to write good prompts, manage context, and iterate effectively.\nThe key to effective prompts is being specific. Compare:",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#prompt-patterns-that-work",
    "href": "claude-code/working-effectively.html#prompt-patterns-that-work",
    "title": "13  Working Effectively with Claude",
    "section": "",
    "text": "Less Effective\nMore Effective\n\n\n\n\n“Fix this error”\n“I’m getting this error when I render: [paste error]. The issue seems to be in the data loading section around line 45.”\n\n\n“Make a plot”\n“Create a volcano plot of the DE results. X-axis: log2 fold change. Y-axis: -log10 adjusted p-value. Highlight genes with adjP &lt; 0.05 and abs(log2FC) &gt; 1.”\n\n\n“Clean this up”\n“Refactor this function to: 1) separate data loading from processing, 2) add input validation, 3) return a tibble instead of a list.”\n\n\n\n\n13.1.1 What to Include in Prompts\n\n\n\n\n\n\n\nContext Type\nExample\n\n\n\n\nThe goal\n“I want to create a sample QC report”\n\n\nThe specific file/data\n“The data is in data/counts.csv, 10k genes × 48 samples”\n\n\nConstraints\n“Use ggplot2, match the style in our other figures”\n\n\nWhat you’ve tried\n“I tried using left_join but got duplicate rows”\n\n\n\n\n\n13.1.2 The Exploration-First Pattern\nFor complex tasks, explore before implementing:\nYou: What does scripts/process_data.R do? Walk me through the main steps.\n\nClaude: [explains the script]\n\nYou: I need to add a quality filter after the normalization step.\n     Before you write code, what's your approach?\n\nClaude: [describes approach]\n\nYou: That sounds right. Go ahead and implement it.\n\nClaude: [makes the edit]\n\nYou: Run the script and show me the output.\nThis catches misunderstandings before you’ve committed to an implementation.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#managing-session-context",
    "href": "claude-code/working-effectively.html#managing-session-context",
    "title": "13  Working Effectively with Claude",
    "section": "13.2 Managing Session Context",
    "text": "13.2 Managing Session Context\n\n13.2.1 When to Start a New Conversation\n\nSwitching to unrelated work — Moving from data analysis to writing documentation\nContext is cluttered — The conversation has wandered through many topics\nClaude seems confused — Stuck in a wrong direction, repeating mistakes\nAfter a natural break — Coming back to work after lunch, next day\n\n\n\n13.2.2 When to Continue the Current Conversation\n\nBuilding on recent work — “Now add error handling to that function”\nFixing issues — “That plot has overlapping labels, fix it”\nIterating on approach — “Actually, let’s use a different normalization method”\n\n\n\n13.2.3 Keep Sessions Focused\nOne main task per conversation works best. If you find yourself on a tangent that’s becoming substantial, consider starting a new session for it.\n\n\n\n\n\n\nTipUse plan files across sessions\n\n\n\nSince Claude doesn’t remember previous conversations, use plan files to track what’s done and what’s pending. Claude reads these at session start.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#reviewing-claudes-work",
    "href": "claude-code/working-effectively.html#reviewing-claudes-work",
    "title": "13  Working Effectively with Claude",
    "section": "13.3 Reviewing Claude’s Work",
    "text": "13.3 Reviewing Claude’s Work\nAlways review before accepting:\n\n\n\nWhat to Check\nWhy\n\n\n\n\nThe diff\nSee exactly what changed\n\n\nRun the code\nVerify it actually works\n\n\nCheck edge cases\nEmpty data? Missing values?\n\n\nRead the logic\nDoes the approach make sense?\n\n\n\nFor analytical code, extra scrutiny:\n\nVerify row counts at each step\nCheck that joins matched as expected\nConfirm statistical methods are what you intended\nSpot-check a few results manually",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#common-session-patterns",
    "href": "claude-code/working-effectively.html#common-session-patterns",
    "title": "13  Working Effectively with Claude",
    "section": "13.4 Common Session Patterns",
    "text": "13.4 Common Session Patterns\n\n13.4.1 Debugging\nI'm getting this error when I run the script:\n\nError in `mutate()`:\n! Problem while computing `ratio = count / total`.\nCaused by error in `count / total`:\n! non-conformable arrays\n\nThe code is around line 67 of analysis.qmd. What's wrong?\nInclude: the error message, where it happens, relevant code.\n\n\n13.4.2 Understanding Code\nExplain what the normalize_counts() function does in scripts/utils.R.\nWalk through each step.\nAsk about specific functions or sections, not “explain the whole codebase.”\n\n\n13.4.3 Building Something New\nCreate a function that:\n1. Takes a dataframe with columns 'gene_id' and 'count'\n2. Filters to genes with count &gt; 10\n3. Adds a 'log_count' column (log2 with pseudocount of 1)\n4. Returns the filtered dataframe\n\nPut it in scripts/utils.R.\nBe specific about inputs, outputs, and where to put it.\n\n\n13.4.4 Extending Existing Code\nIn analysis/02_de.qmd, add a volcano plot after the results table.\nUse the same style as the plots in 01_qc.qmd.\nReference existing patterns when you want consistency.\n\n\n13.4.5 Refactoring\nThe data loading code is duplicated in three scripts.\nExtract it into a load_counts() function in scripts/utils.R,\nthen update the scripts to use it.\nState the goal and the approach you want.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#the-done-command",
    "href": "claude-code/working-effectively.html#the-done-command",
    "title": "13  Working Effectively with Claude",
    "section": "13.5 The /done Command",
    "text": "13.5 The /done Command\nEnd productive sessions with /done:\n/done\nThis triggers the end-of-session skill which:\n\nSummarizes what was accomplished\nChecks renv — If you’re in an R project, asks about updating the lockfile\nOffers to commit — Shows changed files and suggests a commit message\nPublishes (if applicable) — For Quarto books, offers to publish to GitHub Pages\n\nThis ensures your work is saved and documented before you close the session.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#iterating-effectively",
    "href": "claude-code/working-effectively.html#iterating-effectively",
    "title": "13  Working Effectively with Claude",
    "section": "13.6 Iterating Effectively",
    "text": "13.6 Iterating Effectively\n\n13.6.1 Start Small, Build Up\nDon’t ask for an entire analysis at once. Build piece by piece:\n\n“Load the data and show me its structure”\n“Filter to high-confidence genes”\n“Calculate summary statistics by condition”\n“Create a comparison plot”\n\nEach step can be verified before moving on.\n\n\n13.6.2 Correct Mistakes Immediately\nIf something’s wrong, say so directly:\nThat's not quite right—the grouping should be by 'condition',\nnot 'sample'. Fix it.\nClaude adjusts based on feedback within the session.\n\n\n13.6.3 Ask “Why” Questions\nIf Claude makes a choice you don’t understand:\nWhy did you use median instead of mean for the normalization?\nUnderstanding the reasoning helps you decide if it’s appropriate for your use case.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#tips-for-effective-sessions",
    "href": "claude-code/working-effectively.html#tips-for-effective-sessions",
    "title": "13  Working Effectively with Claude",
    "section": "13.7 Tips for Effective Sessions",
    "text": "13.7 Tips for Effective Sessions\n\n\n\nTip\nWhy\n\n\n\n\nHave your CLAUDE.md ready\nBetter project docs = better context\n\n\nReference files by name\n“In analysis.qmd” not “in that file”\n\n\nPaste actual error messages\nDon’t paraphrase errors\n\n\nState your goal\nWhat are you trying to accomplish?\n\n\nWork incrementally\nOne step at a time\n\n\nCheck outputs\nDon’t assume it worked",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "claude-code/working-effectively.html#a-complete-session-example",
    "href": "claude-code/working-effectively.html#a-complete-session-example",
    "title": "13  Working Effectively with Claude",
    "section": "13.8 A Complete Session Example",
    "text": "13.8 A Complete Session Example\nHere’s a realistic session flow:\nYou: I have count data in data/counts.csv. What does it look like?\n\nClaude: [reads file, reports dimensions, column names, value ranges]\n\nYou: Create a Quarto script at analysis/01_qc.qmd that:\n     - Loads the data\n     - Shows a histogram of total counts per sample\n     - Flags any sample with unusually low counts\n\nClaude: [creates script, shows content]\n\nYou: [reviews, accepts]\n     Render it and show me any errors.\n\nClaude: [runs quarto render, reports success]\n\nYou: [opens HTML, notices an issue]\n     Sample_3 looks strange. Add a section that calculates\n     summary stats and explicitly flags outliers.\n\nClaude: [proposes edit]\n\nYou: [accepts]\n     Render again.\n\nClaude: [renders]\n\nYou: /done\n\nClaude: Session summary:\n        - Created analysis/01_qc.qmd with QC diagnostics\n        - Identified Sample_3 as potential outlier\n\n        Commit these changes?\n        \"Add QC analysis with sample diagnostics\"\n\nYou: [accepts commit]\nThe key pattern: explore → create → verify → refine → commit.",
    "crumbs": [
      "Claude Code",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working Effectively with Claude</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html",
    "href": "part3/setup-walkthrough.html",
    "title": "14  Setting Up a Lab Project",
    "section": "",
    "text": "14.1 Step 1: Create the Project Folder\nNow that you know how to use Positron to write and run R code, this chapter walks through setting up a complete lab project—with version control, isolated environments, proper folder structure, and a GitHub backup. This is the full infrastructure you’ll use for real analyses.\nThe steps may feel like a lot the first time, but they become second nature quickly. After a few projects, you’ll have it done in minutes. And each step exists for a reason: to keep your work reproducible, organized, and safe from data loss.\nBy the end, you’ll have:\nIn Positron (and VS Code), a project is simply a folder. When you open a folder as your workspace, all of Positron’s tools—the terminal, file browser, R console, Python interpreter—work relative to that folder.\nOpen your terminal and create a new project:\nUse lowercase with hyphens for project names—avoid spaces and special characters.\nOpen Positron and use File → Open Folder to open my-analysis.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-1-create-the-project-folder",
    "href": "part3/setup-walkthrough.html#step-1-create-the-project-folder",
    "title": "14  Setting Up a Lab Project",
    "section": "",
    "text": "# Navigate to where you keep projects\ncd ~/Documents  # or wherever you prefer\n\n# Create and enter the project folder\nmkdir my-analysis\ncd my-analysis",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-2-initialize-git",
    "href": "part3/setup-walkthrough.html#step-2-initialize-git",
    "title": "14  Setting Up a Lab Project",
    "section": "14.2 Step 2: Initialize Git",
    "text": "14.2 Step 2: Initialize Git\nWe initialize Git first so that every change from here on is tracked. In Positron’s terminal (View → Terminal), initialize a Git repository:\ngit init\nNext, create a .gitignore file to tell Git which files to skip—large data files, generated outputs, and system files don’t belong in version control. See the Git & GitHub chapter for details on what each line means.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can generate configuration files tailored to your specific project setup.\n\nI’m starting a new R project that will also use Python for some preprocessing. Can you create a .gitignore file? I’m using renv for R packages and conda for Python.\n\nClaude will create a .gitignore with the right patterns for both languages—renv cache, conda environments, data files, and OS-specific junk files.\n\n\n# Create .gitignore\ncat &gt; .gitignore &lt;&lt; 'EOF'\n# R\n.Rhistory\n.RData\n.Rproj.user/\nrenv/library/\nrenv/staging/\n\n# Python\n__pycache__/\n*.pyc\n.conda/\n.venv/\n\n# Quarto\n*_files/\n.quarto/\n\n# Generated outputs (can be reproduced from scripts)\nouts/\n\n# OS files\n.DS_Store\nThumbs.db\n\n# IDE\n.vscode/\n.positron/\nEOF",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-3-set-up-conda-environment",
    "href": "part3/setup-walkthrough.html#step-3-set-up-conda-environment",
    "title": "14  Setting Up a Lab Project",
    "section": "14.3 Step 3: Set Up Conda Environment",
    "text": "14.3 Step 3: Set Up Conda Environment\nEvery project gets its own conda environment, even if you’re primarily using R. This isolation prevents a common problem: updating a package for one project and accidentally breaking another.\nconda create -n my-analysis python=3.11 -y\nconda activate my-analysis\nSave the environment specification so collaborators (or future you) can recreate it:\nconda env export &gt; environment.yml\n\n\n\n\n\n\nTipEnvironment Activation\n\n\n\nEvery time you work on this project, activate the environment first:\nconda activate my-analysis",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-4-set-up-r-with-renv",
    "href": "part3/setup-walkthrough.html#step-4-set-up-r-with-renv",
    "title": "14  Setting Up a Lab Project",
    "section": "14.4 Step 4: Set Up R with renv",
    "text": "14.4 Step 4: Set Up R with renv\nJust as conda isolates Python packages, renv isolates R packages. Each project gets its own library, and the renv.lock file records exact package versions.\nIn Positron’s R console, initialize renv:\n# Install renv if needed\ninstall.packages(\"renv\")\n\n# Initialize renv for this project\nrenv::init()\nThis creates:\n\nrenv/ folder for the project’s package library\nrenv.lock file recording package versions\n.Rprofile to auto-activate renv when R starts\n\nInstall the packages you need for your analysis:\ninstall.packages(c(\"tidyverse\", \"here\"))\nrenv::snapshot()  # Save the state",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-5-configure-positron-for-this-project",
    "href": "part3/setup-walkthrough.html#step-5-configure-positron-for-this-project",
    "title": "14  Setting Up a Lab Project",
    "section": "14.5 Step 5: Configure Positron for This Project",
    "text": "14.5 Step 5: Configure Positron for This Project\nNow that the conda environment and R packages exist, tell Positron which interpreters to use. You only need to do this once per project.\n\n14.5.1 Select the Python Interpreter\n\nOpen the Command Palette: Cmd+Shift+P (macOS) or Ctrl+Shift+P (Windows)\nType “Python: Select Interpreter” and select it\nChoose the my-analysis conda environment from the list\n\nIf the environment doesn’t appear, restart Positron—it needs to detect newly created environments.\n\n\n14.5.2 Select the R Version\nIf you have multiple R versions installed via rig, you can set the default for this project:\n\nOpen Command Palette → “R: Select R Binary”\nChoose the version you want (usually the latest stable release)\n\n\n\n14.5.3 Restart and Verify\nRestart Positron to ensure settings take effect. Then verify:\n\nR Console: You should see [renv] in the prompt, indicating renv is active.\nPython: Open the terminal, confirm conda activate my-analysis uses the right environment.\n\n\n\n\n\n\n\nNoteOne-Time Setup\n\n\n\nYou only configure interpreters once per project. Positron remembers your choices in .vscode/settings.json, which is stored in the project folder.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-6-create-project-structure",
    "href": "part3/setup-walkthrough.html#step-6-create-project-structure",
    "title": "14  Setting Up a Lab Project",
    "section": "14.6 Step 6: Create Project Structure",
    "text": "14.6 Step 6: Create Project Structure\nCreate the lab’s standard folder structure:\nmkdir -p data scripts outs\nYour project now looks like:\nmy-analysis/\n├── .git/\n├── .gitignore\n├── data/              # External inputs only (raw data, metadata)\n├── scripts/           # Quarto analysis scripts (.qmd files)\n├── outs/              # All generated outputs (figures, tables, processed data)\n├── environment.yml    # Conda environment specification\n├── renv/              # R package library (not tracked in git)\n└── renv.lock          # R package versions (tracked in git)\nThis structure separates inputs (data/) from outputs (outs/), with scripts in the middle. Each script writes to a corresponding subfolder in outs/, making it easy to trace which script produced which files. See the Project Organization chapter for the full rationale and conventions.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-7-write-a-quarto-analysis-script",
    "href": "part3/setup-walkthrough.html#step-7-write-a-quarto-analysis-script",
    "title": "14  Setting Up a Lab Project",
    "section": "14.7 Step 7: Write a Quarto Analysis Script",
    "text": "14.7 Step 7: Write a Quarto Analysis Script\nCreate a new file at scripts/01_penguin_summary.qmd:\n---\ntitle: \"Penguin Size Summary\"\nauthor: \"Your Name\"\ndate: today\nformat:\n  html:\n    toc: true\n    code-overflow: wrap\n    self-contained: true\nexecute:\n  echo: true\n  warning: false\n---\n\n## Overview\n\nThis analysis summarizes body size measurements from the Palmer Penguins dataset.\n\n**Inputs:** `palmerpenguins` package (built-in dataset)\n\n**Outputs:** `outs/01_penguin_summary/penguin_mass.png`\n\n```{r}\n#| label: setup\n\nlibrary(palmerpenguins)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(here)\n\n# Create output directory for this script\ndir_out &lt;- here(\"outs\", \"01_penguin_summary\")\ndir.create(dir_out, recursive = TRUE, showWarnings = FALSE)\n```\n\n## Data summary\n\n```{r}\n#| label: summary\n\npenguins |&gt;\n  group_by(species) |&gt;\n  summarise(\n    n = n(),\n    mean_mass_g = mean(body_mass_g, na.rm = TRUE),\n    mean_flipper_mm = mean(flipper_length_mm, na.rm = TRUE)\n  )\n```\n\n## Body mass by species\n\n```{r}\n#| label: fig-mass\n#| fig-cap: \"Body mass distribution by penguin species\"\n\np &lt;- ggplot(penguins, aes(x = species, y = body_mass_g, fill = species)) +\n  geom_boxplot() +\n  labs(x = \"Species\", y = \"Body mass (g)\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n\nprint(p)\n\n# Save to this script's output folder\nggsave(file.path(dir_out, \"penguin_mass.png\"), p, width = 6, height = 4)\n```\n\n## Summary\n\nWe summarized body mass across three penguin species. The figure has been saved to `outs/01_penguin_summary/penguin_mass.png`.\n\n\n\n\n\n\nNoteWhat makes this a “lab-style” analysis script?\n\n\n\n\nSelf-contained — All code needed to run is in the file\nDocuments inputs and outputs — States what it reads and what it produces\nWrites outputs to a dedicated folder — outs/01_penguin_summary/ corresponds to script 01_penguin_summary.qmd\nUses here::here() — Paths are relative to the project root, not the script location",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-8-render-the-analysis",
    "href": "part3/setup-walkthrough.html#step-8-render-the-analysis",
    "title": "14  Setting Up a Lab Project",
    "section": "14.8 Step 8: Render the Analysis",
    "text": "14.8 Step 8: Render the Analysis\nIn Positron’s terminal, render the document:\nquarto render scripts/01_penguin_summary.qmd\nQuarto executes every code chunk in a fresh R session and weaves the output into an HTML report. This creates:\n\nscripts/01_penguin_summary.html — the rendered report (open in a browser to view)\nouts/01_penguin_summary/penguin_mass.png — the exported figure\n\n\n\n\n\n\n\nTipPreview Mode\n\n\n\nDuring development, use quarto preview for live updates as you edit:\nquarto preview scripts/01_penguin_summary.qmd\nThis opens a browser window that refreshes automatically when you save changes.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#step-9-commit-your-work",
    "href": "part3/setup-walkthrough.html#step-9-commit-your-work",
    "title": "14  Setting Up a Lab Project",
    "section": "14.9 Step 9: Commit Your Work",
    "text": "14.9 Step 9: Commit Your Work\nA commit is a snapshot of your project at this moment. From now on, every significant change should get its own commit.\nStage and commit your work:\n# See what's ready to commit\ngit status\n\n# Add files\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"Initial project setup with penguin analysis\"",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#sec-github-auth",
    "href": "part3/setup-walkthrough.html#sec-github-auth",
    "title": "14  Setting Up a Lab Project",
    "section": "14.10 Step 10: Push to GitHub",
    "text": "14.10 Step 10: Push to GitHub\nPushing to GitHub backs up your work in the cloud and enables collaboration.\n\n\n\n\n\n\nImportantPersonal vs. Lab GitHub\n\n\n\n\nLab organization: All analysis and coding projects for lab work go under MusserLab. This ensures continuity when people leave.\nPersonal account: Use for personal configuration folders, side projects, or practice repositories.\n\nFor this walkthrough, you can use either. For real lab projects, use the MusserLab organization.\n\n\n\n14.10.1 Authenticate with GitHub\nIf you haven’t already set up the GitHub CLI (gh), follow the installation and authentication steps in the Git & GitHub chapter. Once authenticated, you can create repositories and push code from the terminal.\n\n\n14.10.2 Create and Push to GitHub\nThe easiest way to create a repository and push in one step:\n# Create a private repo and push (on your personal account)\ngh repo create my-analysis --private --source=. --push\n\n# Or for the lab organization:\n# gh repo create MusserLab/my-analysis --private --source=. --push\nAlternatively, create the repository manually on github.com, then:\ngit remote add origin https://github.com/YOUR-USERNAME/my-analysis.git\ngit push -u origin main",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#what-youve-built",
    "href": "part3/setup-walkthrough.html#what-youve-built",
    "title": "14  Setting Up a Lab Project",
    "section": "14.11 What You’ve Built",
    "text": "14.11 What You’ve Built\nYou now have a complete project with:\n\nOrganized folder structure (data/, scripts/, outs/)\nPython environment (conda) — isolated and reproducible\nR package management (renv) — isolated and reproducible\nPositron configured for both languages\nA Quarto analysis script that renders to HTML\nExported figures in outs/01_penguin_summary/\nVersion control (Git) and cloud backup (GitHub)\n\nThis is the pattern you’ll use for every analysis in the lab.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/setup-walkthrough.html#whats-next",
    "href": "part3/setup-walkthrough.html#whats-next",
    "title": "14  Setting Up a Lab Project",
    "section": "14.12 What’s Next",
    "text": "14.12 What’s Next\n\nStarting a New Analysis Project — A quick-reference checklist and templates for project setup, including advanced topics like sectioned project layouts and Claude Code configuration.\nCollaborating — How to work with others using Git and GitHub.\nReproducibility — Ensuring your analyses can be reproduced by others (or future you).\n\nWhen you return to a project:\ncd my-analysis\nconda activate my-analysis\n# Open in Positron — renv will auto-activate when R starts",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Setting Up a Lab Project</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html",
    "href": "part3/starting-project.html",
    "title": "15  Quick Reference: Project Setup",
    "section": "",
    "text": "15.1 Standard Structure\nThis page is a concise reference for setting up a new analysis project. For a full step-by-step walkthrough with explanations, see Setting Up a Lab Project. For the rationale behind each convention, see Project Organization.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#standard-structure",
    "href": "part3/starting-project.html#standard-structure",
    "title": "15  Quick Reference: Project Setup",
    "section": "",
    "text": "15.1.1 Flat layout (single topic, &lt; 10 scripts)\nproject-name/\n├── .claude/\n│   └── CLAUDE.md         # Claude Code instructions\n├── .git/\n├── .gitignore\n├── R/                    # Shared R helper functions\n├── python/               # Shared Python helper functions\n├── scripts/\n│   └── exploratory/      # One-off analyses (no numbering)\n├── data/                 # External inputs only — scripts never write here\n├── outs/                 # All script-generated outputs\n├── environment.yml       # Conda environment (Python)\n├── renv.lock            # R package versions\n└── README.md\n\n\n15.1.2 Sectioned layout (multiple analysis threads)\nFor projects with multiple analysis sections (e.g., phosphoproteomics + transcriptomics), mirror the sections across scripts/, data/, and outs/:\nscripts/\n├── phosphoproteomics/\n│   ├── 01_qc.qmd\n│   └── 02_analysis.qmd\n├── transcriptomics/\n│   └── 01_heatmaps.qmd\n└── exploratory/\n\ndata/\n├── phosphoproteomics/\n└── transcriptomics/\n\nouts/\n├── phosphoproteomics/\n├── transcriptomics/\n└── exploratory/\nEach section has its own numbering sequence.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#setup-commands",
    "href": "part3/starting-project.html#setup-commands",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.2 Setup Commands",
    "text": "15.2 Setup Commands\n# 1. Create project\nmkdir my-analysis && cd my-analysis\n\n# 2. Git\ngit init\n# Create .gitignore (see template below)\n\n# 3. Directory structure\nmkdir -p R python scripts/exploratory data outs/exploratory .claude\n\n# 4. Python environment (if using Python)\nconda create -n my-analysis python=3.11 pandas numpy matplotlib seaborn ipykernel -y\nconda activate my-analysis\npip install session-info\nconda env export --from-history &gt; environment.yml\n\n# 5. R packages (if using R)\n# In R console: renv::init(); install.packages(c(\"tidyverse\", \"here\")); renv::snapshot()\n\n# 6. First commit\ngit add .\ngit commit -m \"Initial project setup\"\n\n# 7. Push to GitHub\ngh repo create my-analysis --private --source=. --push\n# Or for lab: gh repo create MusserLab/my-analysis --private --source=. --push",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#gitignore-template",
    "href": "part3/starting-project.html#gitignore-template",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.3 .gitignore Template",
    "text": "15.3 .gitignore Template\n# Generated outputs (reproducible from code)\nouts/\n\n# R artifacts\n.Rhistory\n.RData\n.Rproj.user/\nrenv/library/\nrenv/staging/\nrenv/local/\n*_cache/\n\n# Python artifacts\n__pycache__/\n*.py[cod]\n*.egg-info/\n.eggs/\n*.egg\n.venv/\nvenv/\n\n# Quarto rendering\n*_files/\n.quarto/\n\n# OS files\n.DS_Store\nThumbs.db\n\n# IDE settings\n.vscode/\n.positron/\n*.Rproj\n\n# Secrets\n.env\n*.pem\ncredentials.json",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#claude.md-template",
    "href": "part3/starting-project.html#claude.md-template",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.4 CLAUDE.md Template",
    "text": "15.4 CLAUDE.md Template\nCreate .claude/CLAUDE.md:\n# Project: My Analysis\n\n## Overview\n[Brief description of what this project does]\n\n## Environment\n- Python: `conda activate my-analysis`\n- R: Uses renv (auto-activates)\n\n## Key Directories\n- `data/` — External input data (read-only, scripts never write here)\n- `scripts/` — Quarto analysis scripts (.qmd)\n- `scripts/exploratory/` — One-off analyses\n- `outs/` — All script-generated outputs\n- `R/` — Shared R helper functions\n- `python/` — Shared Python helper functions\n\n## Workflows\n[How to run the analysis]\n\n## Data\n[Description of data files and their sources]\n\n## Conventions\n- Scripts use `status:` lifecycle field (development → finalized → deprecated)\n- Every script writes `BUILD_INFO.txt` to its output folder\n- Scripts communicate through files in `outs/`, not shared memory\n- Cross-language data uses Parquet format\n\n## Project Document Registry\n[Planning documents go here as the project grows]",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#readme-template",
    "href": "part3/starting-project.html#readme-template",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.5 README Template",
    "text": "15.5 README Template\n# My Analysis\n\n## Overview\n[What this project does]\n\n## Setup\n\n### Python\nconda env create -f environment.yml\nconda activate my-analysis\n\n### R\n# renv will auto-activate; run renv::restore() if needed\n\n## Running the Analysis\n[Instructions]\n\n## Data\n[Data sources and descriptions]",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#data-rules",
    "href": "part3/starting-project.html#data-rules",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.6 Data Rules",
    "text": "15.6 Data Rules\n\nPut external data files in data/. Never modify these files — treat them as read-only.\nScripts never write to data/.\nIf data files are large, don’t commit them to Git. Add them to .gitignore and document where to obtain the data in your README.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#using-claude-code",
    "href": "part3/starting-project.html#using-claude-code",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.7 Using Claude Code",
    "text": "15.7 Using Claude Code\nWith your .claude/CLAUDE.md in place:\nclaude\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can scaffold project configuration files based on your specific setup.\n\nI’m starting a new project analyzing proteomics data from cell cultures. The data is in data/, I’m using R with renv, and I’ll render with Quarto. Can you create a starter .claude/CLAUDE.md for this project?\n\nClaude will create a CLAUDE.md tailored to your project type, data location, and tooling—saving you from starting with a blank template.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/starting-project.html#checklist",
    "href": "part3/starting-project.html#checklist",
    "title": "15  Quick Reference: Project Setup",
    "section": "15.8 Checklist",
    "text": "15.8 Checklist\nBefore starting analysis:\n\nGit initialized\n.gitignore in place\nDirectory structure created (R/, python/, scripts/exploratory/, data/, outs/)\nConda environment created and exported (--from-history)\nrenv initialized (if using R)\n.claude/CLAUDE.md written\nREADME drafted\nFirst commit made\nPushed to GitHub",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Quick Reference: Project Setup</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html",
    "href": "part3/collaborating.html",
    "title": "16  Collaborating with Others",
    "section": "",
    "text": "16.1 Sharing a Project\nThis chapter covers how to work on projects with collaborators using Git and GitHub.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#sharing-a-project",
    "href": "part3/collaborating.html#sharing-a-project",
    "title": "16  Collaborating with Others",
    "section": "",
    "text": "16.1.1 Giving Access\nOn GitHub:\n\nGo to repository Settings → Collaborators\nClick Add people\nEnter collaborator’s GitHub username or email\nThey’ll receive an invitation\n\n\n\n16.1.2 Collaborator Setup\nYour collaborator clones the repo:\ngit clone https://github.com/USERNAME/project-name.git\ncd project-name\nThen sets up environments:\n# Python\nconda env create -f environment.yml\nconda activate project-name\n\n# R (in R console)\nrenv::restore()",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#the-collaboration-workflow",
    "href": "part3/collaborating.html#the-collaboration-workflow",
    "title": "16  Collaborating with Others",
    "section": "16.2 The Collaboration Workflow",
    "text": "16.2 The Collaboration Workflow\n\n16.2.1 Before Starting Work\nAlways pull the latest changes:\ngit pull\nCheck for environment updates:\n# Python - check if environment.yml changed\nconda env update -f environment.yml\n\n# R - check renv status\n# renv::status()\n# renv::restore()\n\n\n16.2.2 Making Changes\n\nPull latest changes\nDo your work\nStage and commit\nPush\n\ngit pull\n# ... make changes ...\ngit add .\ngit commit -m \"Add analysis for condition B\"\ngit push\n\n\n16.2.3 When Collaborators Push\nIf someone pushed while you were working:\ngit pull\n# May need to resolve conflicts (see below)\ngit push",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#branching-workflow",
    "href": "part3/collaborating.html#branching-workflow",
    "title": "16  Collaborating with Others",
    "section": "16.3 Branching Workflow",
    "text": "16.3 Branching Workflow\nFor larger changes, use branches:\n\n16.3.1 Create a Branch\ngit checkout -b my-feature\n\n\n16.3.2 Work on the Branch\n# Make changes, commit as usual\ngit add .\ngit commit -m \"Add new analysis\"\n\n\n16.3.3 Push the Branch\ngit push -u origin my-feature\n\n\n16.3.4 Create a Pull Request\n\nGo to the repository on GitHub\nClick Compare & pull request\nAdd description of changes\nRequest review from collaborator\nMerge when approved\n\n\n\n16.3.5 After Merging\ngit checkout main\ngit pull\ngit branch -d my-feature  # Delete local branch",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#handling-merge-conflicts",
    "href": "part3/collaborating.html#handling-merge-conflicts",
    "title": "16  Collaborating with Others",
    "section": "16.4 Handling Merge Conflicts",
    "text": "16.4 Handling Merge Conflicts\nConflicts happen when two people change the same lines.\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can explain merge conflicts and help you resolve them safely.\n\nI have a merge conflict in analysis.qmd with these conflict markers: [paste the conflicting section]. My collaborator changed the threshold. Which should I keep?\n\nShow the conflict markers and explain the context. Claude can help you understand what each version does and decide how to resolve it.\n\n\n\n16.4.1 Recognizing a Conflict\ngit pull\n# CONFLICT (content): Merge conflict in analysis.R\n# Automatic merge failed; fix conflicts and then commit.\n\n\n16.4.2 Resolving Conflicts\nOpen the conflicted file. You’ll see markers:\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n# Your version\nresult &lt;- calculate_mean(data)\n=======\n# Their version\nresult &lt;- calculate_median(data)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main\nEdit to keep what you want:\n# Keep both approaches, or choose one\nresult_mean &lt;- calculate_mean(data)\nresult_median &lt;- calculate_median(data)\nRemove the conflict markers, then:\ngit add analysis.R\ngit commit -m \"Resolve merge conflict in analysis.R\"\ngit push",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#environment-synchronization",
    "href": "part3/collaborating.html#environment-synchronization",
    "title": "16  Collaborating with Others",
    "section": "16.5 Environment Synchronization",
    "text": "16.5 Environment Synchronization\n\n16.5.1 When You Add Packages\nPython:\nconda install new-package\nconda env export &gt; environment.yml\ngit add environment.yml\ngit commit -m \"Add new-package to environment\"\ngit push\nR:\ninstall.packages(\"new-package\")\nrenv::snapshot()\ngit add renv.lock\ngit commit -m \"Add new-package to renv\"\ngit push\n\n\n16.5.2 When Collaborator Adds Packages\nAfter pulling:\nPython:\nconda env update -f environment.yml\nR:\nrenv::restore()",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#best-practices",
    "href": "part3/collaborating.html#best-practices",
    "title": "16  Collaborating with Others",
    "section": "16.6 Best Practices",
    "text": "16.6 Best Practices\n\n16.6.1 Communicate\n\nTell collaborators what you’re working on\nAvoid working on the same files simultaneously\nUse issues to track tasks\n\n\n\n16.6.2 Commit Often\nSmall, frequent commits are easier to merge than large changes.\n\n\n16.6.3 Pull Before Push\ngit pull\ngit push\nThis catches conflicts early.\n\n\n16.6.4 Use .gitignore\nEnsure everyone has the same .gitignore to avoid committing:\n\nLarge data files\nPersonal IDE settings\nSystem files\n\n\n\n16.6.5 Document Changes\nUpdate README and documentation when you change:\n\nHow to run the analysis\nEnvironment dependencies\nData requirements",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#working-with-github-issues",
    "href": "part3/collaborating.html#working-with-github-issues",
    "title": "16  Collaborating with Others",
    "section": "16.7 Working with GitHub Issues",
    "text": "16.7 Working with GitHub Issues\n\n16.7.1 Creating Issues\nUse issues to track:\n\nBugs to fix\nFeatures to add\nQuestions to resolve\n\nClick New Issue on GitHub and describe the task.\n\n\n16.7.2 Referencing Issues in Commits\nLink commits to issues:\ngit commit -m \"Fix normalization bug (closes #12)\"\nThis automatically closes the issue when merged.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#forking-for-external-collaborators",
    "href": "part3/collaborating.html#forking-for-external-collaborators",
    "title": "16  Collaborating with Others",
    "section": "16.8 Forking (For External Collaborators)",
    "text": "16.8 Forking (For External Collaborators)\nIf someone isn’t a direct collaborator:\n\nThey fork the repo (creates their copy)\nThey make changes in their fork\nThey open a pull request to your repo\nYou review and merge\n\nThis is common for open-source contributions.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/collaborating.html#checklist-for-collaboration",
    "href": "part3/collaborating.html#checklist-for-collaboration",
    "title": "16  Collaborating with Others",
    "section": "16.9 Checklist for Collaboration",
    "text": "16.9 Checklist for Collaboration\nStarting a collaborative project:\n\nRepository on GitHub with collaborators added\nClear README with setup instructions\n.gitignore preventing large/personal files\nenvironment.yml (Python) and renv.lock (R) committed\nAgreed workflow (branches vs direct commits)\nCommunication channel established\n\nDaily workflow:\n\nPull before starting work\nUpdate environments if needed\nCommit small, focused changes\nPush when done\nCommunicate about what you changed",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Collaborating with Others</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html",
    "href": "part3/reproducibility.html",
    "title": "17  Reproducible Analysis",
    "section": "",
    "text": "17.1 Why Reproducibility Matters\nReproducibility means others (including future you) can run your analysis and get the same results. This chapter covers practices that ensure reproducibility.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#why-reproducibility-matters",
    "href": "part3/reproducibility.html#why-reproducibility-matters",
    "title": "17  Reproducible Analysis",
    "section": "",
    "text": "Verification: Others can check your work\nBuilding on work: You or others can extend the analysis\nDebugging: Easier to find and fix problems\nPublication: Increasingly required by journals\nFuture you: Six months from now, you’ll thank yourself",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#the-three-pillars",
    "href": "part3/reproducibility.html#the-three-pillars",
    "title": "17  Reproducible Analysis",
    "section": "17.2 The Three Pillars",
    "text": "17.2 The Three Pillars\n\n17.2.1 1. Version Control (Git)\nTrack every change to your code:\n\nWhat changed\nWhen it changed\nWhy it changed\n\nWith Git, you can always return to a working state.\n\n\n17.2.2 2. Environment Management (Conda + renv)\nLock down exact package versions:\n# environment.yml\ndependencies:\n  - python=3.11.5\n  - pandas=2.0.3\n  - numpy=1.24.3\n// renv.lock\n\"ggplot2\": {\n  \"Version\": \"3.4.2\"\n}\nDifferent package versions can give different results.\n\n\n17.2.3 3. Documentation\nExplain:\n\nHow to set up the environment\nHow to run the analysis\nWhat the data looks like\nWhat decisions you made and why",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#reproducibility-checklist",
    "href": "part3/reproducibility.html#reproducibility-checklist",
    "title": "17  Reproducible Analysis",
    "section": "17.3 Reproducibility Checklist",
    "text": "17.3 Reproducibility Checklist\n\n\n\n\n\n\nWarningClaude Code\n\n\n\nClaude Code can audit your scripts for common reproducibility pitfalls.\n\nCan you check analysis/01_qc.qmd for reproducibility issues? Look for hardcoded paths, missing package declarations, missing seed settings, or code that might behave differently on another machine.\n\nClaude will scan the file and flag issues like absolute paths, missing library() calls, unseeded random operations, and platform-dependent code.\n\n\n\n17.3.1 Environment\n\nAll dependencies listed in environment.yml (Python) or renv.lock (R)\nSpecific versions pinned, not just package names\nInstructions for environment setup in README\n\n\n\n17.3.2 Data\n\nRaw data preserved unchanged\nData processing steps documented and scripted\nData sources documented\nIf data can’t be shared, describe format and structure\n\n\n\n17.3.3 Code\n\nAnalysis runs from start to finish without manual intervention\nFile paths are relative, not absolute\nNo hardcoded paths like /Users/myname/...\nRandom seeds set for stochastic processes\nIntermediate results can be regenerated from code\n\n\n\n17.3.4 Documentation\n\nREADME explains setup and execution\nAnalysis steps documented in code comments or notebooks\nKey decisions annotated with rationale",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#using-relative-paths",
    "href": "part3/reproducibility.html#using-relative-paths",
    "title": "17  Reproducible Analysis",
    "section": "17.4 Using Relative Paths",
    "text": "17.4 Using Relative Paths\nBad — hardcoded absolute paths:\ndata &lt;- read_csv(\"/Users/jm284/projects/analysis/data/data.csv\")\nGood — relative paths with here:\nlibrary(here)\ndata &lt;- read_csv(here(\"data\", \"data.csv\"))\nPython — use pathlib:\nfrom pathlib import Path\n\nPROJECT_ROOT = Path(__file__).parent.parent\ndata = pd.read_csv(PROJECT_ROOT / \"data\" / \"data.csv\")\nThe here package (R) and pathlib (Python) find paths relative to the project root, regardless of where scripts are run from.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#setting-random-seeds",
    "href": "part3/reproducibility.html#setting-random-seeds",
    "title": "17  Reproducible Analysis",
    "section": "17.5 Setting Random Seeds",
    "text": "17.5 Setting Random Seeds\nMany analyses involve randomness (bootstrapping, sampling, train/test splits). Set seeds for reproducibility:\nR:\nset.seed(42)\nresult &lt;- sample(data, 100)\nPython:\nimport random\nimport numpy as np\n\nrandom.seed(42)\nnp.random.seed(42)\nresult = np.random.choice(data, 100)\nDocument why you chose that seed (or just pick a number consistently).",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#documenting-data",
    "href": "part3/reproducibility.html#documenting-data",
    "title": "17  Reproducible Analysis",
    "section": "17.6 Documenting Data",
    "text": "17.6 Documenting Data\nIn your README or a separate DATA.md:\n# Data Description\n\n## Data\n\n### data/counts.csv\n- Source: GEO accession GSE12345\n- Downloaded: 2024-01-15\n- Format: CSV, 20,000 genes × 12 samples\n- Columns: gene_id, sample1, sample2, ...\n\n### data/metadata.csv\n- Source: Provided by collaborator\n- Format: CSV, 12 rows\n- Columns: sample_id, condition, batch, replicate",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#running-the-full-analysis",
    "href": "part3/reproducibility.html#running-the-full-analysis",
    "title": "17  Reproducible Analysis",
    "section": "17.7 Running the Full Analysis",
    "text": "17.7 Running the Full Analysis\nCreate a master script or Makefile that runs everything:\nShell script (run_analysis.sh):\n#!/bin/bash\nset -e  # Exit on error\n\necho \"Setting up environment...\"\nconda activate my-analysis\n\necho \"Step 1: Cleaning data...\"\nRscript scripts/01_clean_data.R\n\necho \"Step 2: Analysis...\"\npython scripts/02_analyze.py\n\necho \"Step 3: Figures...\"\nRscript scripts/03_figures.R\n\necho \"Done!\"\nQuarto (analysis.qmd):\nA Quarto document that runs all code chunks in order is inherently reproducible — rendering the document runs the full analysis.\nMake (Makefile):\nall: outs/03_figures/figure1.pdf outs/02_analysis/results.csv\n\nouts/03_figures/figure1.pdf: scripts/03_figures.qmd outs/01_clean_data/clean.csv\n    quarto render scripts/03_figures.qmd\n\nouts/01_clean_data/clean.csv: scripts/01_clean_data.qmd data/data.csv\n    quarto render scripts/01_clean_data.qmd",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#testing-reproducibility",
    "href": "part3/reproducibility.html#testing-reproducibility",
    "title": "17  Reproducible Analysis",
    "section": "17.8 Testing Reproducibility",
    "text": "17.8 Testing Reproducibility\n\n17.8.1 Fresh Environment Test\n\nClone your repo to a new location\nCreate environment from scratch\nRun the full analysis\nCompare results\n\n# In a temporary directory\ngit clone https://github.com/user/project.git test-project\ncd test-project\nconda env create -f environment.yml\nconda activate project-name\n./run_analysis.sh\n\n\n17.8.2 Docker (Advanced)\nFor maximum reproducibility, package everything in a Docker container:\nFROM rocker/tidyverse:4.3.1\n\nCOPY . /analysis\nWORKDIR /analysis\n\nRUN R -e \"renv::restore()\"\n\nCMD [\"Rscript\", \"run_all.R\"]\nThis captures:\n\nOperating system\nR version\nAll packages",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#common-reproducibility-problems",
    "href": "part3/reproducibility.html#common-reproducibility-problems",
    "title": "17  Reproducible Analysis",
    "section": "17.9 Common Reproducibility Problems",
    "text": "17.9 Common Reproducibility Problems\n\n17.9.1 “It works on my machine”\nCause: Different package versions, OS differences, or missing dependencies.\nSolution: Use conda/renv, test in fresh environment.\n\n\n17.9.2 Missing files\nCause: Data files not included or paths are wrong.\nSolution: Document data sources, use relative paths.\n\n\n17.9.3 Different results each run\nCause: Unseeded random number generation.\nSolution: Set random seeds.\n\n\n17.9.4 Manual steps\nCause: Analysis requires clicking buttons or manual edits.\nSolution: Script everything. If you must have manual steps, document them precisely.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#tools-that-help",
    "href": "part3/reproducibility.html#tools-that-help",
    "title": "17  Reproducible Analysis",
    "section": "17.10 Tools That Help",
    "text": "17.10 Tools That Help\n\n\n\nTool\nPurpose\n\n\n\n\nhere (R)\nReliable relative paths\n\n\npathlib (Python)\nPath handling\n\n\nrenv\nR package management\n\n\nconda\nPython environment management\n\n\nQuarto\nLiterate programming\n\n\nGit\nVersion control\n\n\nDocker\nFull environment capture",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/reproducibility.html#quick-reference",
    "href": "part3/reproducibility.html#quick-reference",
    "title": "17  Reproducible Analysis",
    "section": "17.11 Quick Reference",
    "text": "17.11 Quick Reference\nFor every project:\n\nUse Git for version control\nLock environments with conda/renv\nUse relative paths\nSet random seeds\nDocument everything\nTest in a fresh environment before sharing",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Reproducible Analysis</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html",
    "href": "part3/troubleshooting.html",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "",
    "text": "18.1 Conda\nThis chapter covers frequently asked questions and common problems.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#conda",
    "href": "part3/troubleshooting.html#conda",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "",
    "text": "18.1.1 “command not found: conda”\nmacOS/Linux: Conda isn’t initialized in this shell session.\nsource ~/miniforge3/etc/profile.d/conda.sh\n# Or for miniconda:\nsource ~/miniconda3/etc/profile.d/conda.sh\nAdd this to your ~/.zshrc or ~/.bashrc to make it permanent.\nWindows: Open “Anaconda Prompt” or “Miniforge Prompt” instead of regular Command Prompt.\n\n\n18.1.2 “Solving environment” is very slow\nConda’s dependency resolver can be slow with complex environments.\nSolutions:\n\nUse mamba (faster drop-in replacement):\nconda install mamba -n base\nmamba install package-name\nCreate minimal environments:\nconda create -n project python=3.11 pandas numpy\n# Instead of installing everything at once\nUse conda-forge channel consistently:\nconda config --add channels conda-forge\nconda config --set channel_priority strict\n\n\n\n18.1.3 Environment not activating in Positron\n\nOpen Positron’s integrated terminal\nManually activate: conda activate my-env\nUse Command Palette: “Python: Select Interpreter” → choose the environment\n\n\n\n18.1.4 Recreating a broken environment\nconda deactivate\nconda env remove -n broken-env\nconda env create -f environment.yml",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#renv",
    "href": "part3/troubleshooting.html#renv",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.2 renv",
    "text": "18.2 renv\n\n18.2.1 “The project is out-of-sync”\nThis warning means packages in your library don’t match renv.lock.\nTo see what’s different:\nrenv::status()\nTo sync library to lockfile (recommended):\nrenv::restore()\nTo update lockfile to match library:\nrenv::snapshot()\n\n\n18.2.2 Package installation fails\nTry clearing the cache and rebuilding:\nrenv::install(\"package-name\", rebuild = TRUE)\nFor persistent issues:\n# Check for system dependencies\nrenv::diagnostics()\n\n# Install from a different repository\nrenv::install(\"package-name\", repos = \"https://cloud.r-project.org\")\n\n\n18.2.3 Starting fresh with renv\nrenv::deactivate()\nrm -rf renv renv.lock .Rprofile\nrenv::init()",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#git",
    "href": "part3/troubleshooting.html#git",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.3 Git",
    "text": "18.3 Git\n\n18.3.1 “Updates were rejected because the remote contains work…”\nSomeone pushed while you were working.\ngit pull\n# Resolve any conflicts if needed\ngit push\n\n\n18.3.2 Accidentally committed large files\nRemove from history (if not yet pushed):\ngit reset --soft HEAD~1\n# Edit .gitignore to exclude the file\ngit add .gitignore\ngit commit -m \"Fix gitignore\"\nIf already pushed, use BFG or git-filter-branch (more complex).\n\n\n18.3.3 Undo the last commit (keep changes)\ngit reset --soft HEAD~1\n\n\n18.3.4 See what changed in a file\ngit log -p filename.R\n\n\n18.3.5 Discard all uncommitted changes\ngit checkout -- .\n# Or for all files including untracked:\ngit clean -fd\n⚠️ This permanently deletes uncommitted work!",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#claude-code",
    "href": "part3/troubleshooting.html#claude-code",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.4 Claude Code",
    "text": "18.4 Claude Code\n\n18.4.1 “Command not found” for conda in Claude Code\nClaude Code runs in a non-interactive shell. Always source conda first:\nsource ~/miniforge3/etc/profile.d/conda.sh && conda activate my-env && python script.py\nDocument this pattern in your .claude/CLAUDE.md.\n\n\n18.4.2 Claude doesn’t understand my project\nEnsure .claude/CLAUDE.md exists and contains:\n\nProject overview\nEnvironment setup commands\nKey file locations\nCommon workflows\n\n\n\n18.4.3 Responses are generic or unhelpful\nProvide more context:\n\nShow the specific file or code\nExplain what you’re trying to accomplish\nShare error messages in full\n\nInstead of: “Fix the bug”\nTry: “In analysis.R line 45, I get ‘object x not found’. Here’s the relevant code: [paste code]. The data is loaded from data/data.csv.”",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#positron",
    "href": "part3/troubleshooting.html#positron",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.5 Positron",
    "text": "18.5 Positron\n\n18.5.1 R not detected\n\nCheck R is installed: R --version in terminal\nIn Positron settings, search for “R Path” and set it explicitly\nRestart Positron\n\n\n\n18.5.2 Python interpreter not showing\n\nActivate conda environment in terminal\nCommand Palette → “Python: Select Interpreter”\nClick “Enter interpreter path” and navigate to the environment’s Python\n\n\n\n18.5.3 Slow or unresponsive\n\nClose unused tabs\nRestart Positron\nCheck if large objects are in memory (clear R/Python session)\nCheck system memory usage",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#quarto",
    "href": "part3/troubleshooting.html#quarto",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.6 Quarto",
    "text": "18.6 Quarto\n\n18.6.1 “quarto: command not found”\nmacOS:\nbrew install quarto\n# Or use full path:\n/usr/local/bin/quarto render document.qmd\nWindows: Ensure Quarto installer added it to PATH. Restart terminal.\n\n\n18.6.2 Render fails with R errors\n\nRun the R code chunks manually to find the error\nCheck that all packages are installed\nEnsure working directory is correct (use here package)\n\n\n\n18.6.3 Render fails with Python errors\n\nEnsure correct conda environment is active\nCheck Python interpreter in document YAML:\njupyter: python3",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#general-workflow",
    "href": "part3/troubleshooting.html#general-workflow",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.7 General Workflow",
    "text": "18.7 General Workflow\n\n18.7.1 How do I start working on a project?\ncd project-directory\nconda activate project-env  # if Python\npositron .\n# R activates renv automatically via .Rprofile\n\n\n18.7.2 How do I end a work session?\ngit status                    # See what changed\ngit add .                     # Stage changes\ngit commit -m \"Description\"   # Commit\ngit push                      # Push to GitHub\n\n\n18.7.3 How do I update all packages?\nPython:\nconda update --all\nconda env export &gt; environment.yml\ngit add environment.yml && git commit -m \"Update packages\"\nR:\nrenv::update()\nrenv::snapshot()\ngit add renv.lock && git commit -m \"Update R packages\"\n\n\n18.7.4 How do I share my project?\n\nEnsure environment.yml and renv.lock are up to date\nWrite clear README with setup instructions\nPush to GitHub\nShare the repository URL\n\nThe collaborator then:\ngit clone https://github.com/user/project.git\ncd project\nconda env create -f environment.yml\n# In R: renv::restore()",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "part3/troubleshooting.html#getting-help",
    "href": "part3/troubleshooting.html#getting-help",
    "title": "18  Common Tasks & Troubleshooting",
    "section": "18.8 Getting Help",
    "text": "18.8 Getting Help\n\n18.8.1 For tool-specific issues:\n\nConda: docs.conda.io\nrenv: rstudio.github.io/renv\nGit: git-scm.com/doc\nPositron: positron.posit.co\nClaude Code: claude.com/claude-code\nQuarto: quarto.org\n\n\n\n18.8.2 In Claude Code:\nJust ask! Describe your problem with as much detail as possible.",
    "crumbs": [
      "Workflows",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Common Tasks & Troubleshooting</span>"
    ]
  },
  {
    "objectID": "appendices/shortcuts.html",
    "href": "appendices/shortcuts.html",
    "title": "Appendix A — Keyboard Shortcuts",
    "section": "",
    "text": "A.1 Positron / VS Code\nQuick reference for frequently used keyboard shortcuts.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Keyboard Shortcuts</span>"
    ]
  },
  {
    "objectID": "appendices/shortcuts.html#positron-vs-code",
    "href": "appendices/shortcuts.html#positron-vs-code",
    "title": "Appendix A — Keyboard Shortcuts",
    "section": "",
    "text": "A.1.1 General\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nCommand Palette\nCmd+Shift+P\nCtrl+Shift+P\n\n\nQuick Open (files)\nCmd+P\nCtrl+P\n\n\nSettings\nCmd+,\nCtrl+,\n\n\nToggle Sidebar\nCmd+B\nCtrl+B\n\n\nToggle Terminal\nCmd+`\nCtrl+`\n\n\nNew Window\nCmd+Shift+N\nCtrl+Shift+N\n\n\nClose Window\nCmd+W\nCtrl+W\n\n\n\n\n\nA.1.2 Editing\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nSave\nCmd+S\nCtrl+S\n\n\nSave All\nCmd+Option+S\nCtrl+K S\n\n\nUndo\nCmd+Z\nCtrl+Z\n\n\nRedo\nCmd+Shift+Z\nCtrl+Y\n\n\nCut Line\nCmd+X\nCtrl+X\n\n\nCopy Line\nCmd+C\nCtrl+C\n\n\nMove Line Up/Down\nOption+↑/↓\nAlt+↑/↓\n\n\nDuplicate Line\nShift+Option+↓\nShift+Alt+↓\n\n\nDelete Line\nCmd+Shift+K\nCtrl+Shift+K\n\n\nToggle Comment\nCmd+/\nCtrl+/\n\n\n\n\n\nA.1.3 Navigation\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nGo to Line\nCtrl+G\nCtrl+G\n\n\nGo to Symbol\nCmd+Shift+O\nCtrl+Shift+O\n\n\nGo to Definition\nF12\nF12\n\n\nGo Back\nCtrl+-\nAlt+←\n\n\nGo Forward\nCtrl+Shift+-\nAlt+→\n\n\n\n\n\nA.1.4 Multi-Cursor\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nAdd Cursor\nOption+Click\nAlt+Click\n\n\nAdd Cursor Above\nCmd+Option+↑\nCtrl+Alt+↑\n\n\nAdd Cursor Below\nCmd+Option+↓\nCtrl+Alt+↓\n\n\nSelect All Occurrences\nCmd+Shift+L\nCtrl+Shift+L\n\n\n\n\n\nA.1.5 Code Execution (R/Python)\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nRun Selection/Line\nCmd+Enter\nCtrl+Enter\n\n\nRun Cell\nShift+Enter\nShift+Enter\n\n\nRun All Above\nCmd+Shift+Enter\nCtrl+Shift+Enter\n\n\n\n\n\nA.1.6 Search\n\n\n\nAction\nmacOS\nWindows\n\n\n\n\nFind in File\nCmd+F\nCtrl+F\n\n\nFind and Replace\nCmd+Option+F\nCtrl+H\n\n\nFind in Files\nCmd+Shift+F\nCtrl+Shift+F",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Keyboard Shortcuts</span>"
    ]
  },
  {
    "objectID": "appendices/shortcuts.html#terminal-bash",
    "href": "appendices/shortcuts.html#terminal-bash",
    "title": "Appendix A — Keyboard Shortcuts",
    "section": "A.2 Terminal / Bash",
    "text": "A.2 Terminal / Bash\n\n\n\nAction\nShortcut\n\n\n\n\nClear screen\nCtrl+L\n\n\nCancel command\nCtrl+C\n\n\nEnd of input\nCtrl+D\n\n\nMove to line start\nCtrl+A\n\n\nMove to line end\nCtrl+E\n\n\nDelete to line start\nCtrl+U\n\n\nDelete to line end\nCtrl+K\n\n\nPrevious command\n↑\n\n\nSearch history\nCtrl+R",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Keyboard Shortcuts</span>"
    ]
  },
  {
    "objectID": "appendices/shortcuts.html#git",
    "href": "appendices/shortcuts.html#git",
    "title": "Appendix A — Keyboard Shortcuts",
    "section": "A.3 Git",
    "text": "A.3 Git\nCommon Git commands (not shortcuts, but frequently used):\n\n\n\nAction\nCommand\n\n\n\n\nStatus\ngit status\n\n\nStage all\ngit add .\n\n\nCommit\ngit commit -m \"message\"\n\n\nPush\ngit push\n\n\nPull\ngit pull\n\n\nLog (compact)\ngit log --oneline\n\n\nDiff\ngit diff\n\n\nBranch list\ngit branch\n\n\nSwitch branch\ngit checkout branch-name",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Keyboard Shortcuts</span>"
    ]
  },
  {
    "objectID": "appendices/shortcuts.html#claude-code",
    "href": "appendices/shortcuts.html#claude-code",
    "title": "Appendix A — Keyboard Shortcuts",
    "section": "A.4 Claude Code",
    "text": "A.4 Claude Code\n\n\n\nAction\nCommand\n\n\n\n\nExit session\n/exit or Ctrl+C\n\n\nClear screen\n/clear\n\n\nHelp\n/help\n\n\nEnd session with summary\n/done",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Keyboard Shortcuts</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html",
    "href": "appendices/commands.html",
    "title": "Appendix B — Command Reference",
    "section": "",
    "text": "B.1 Conda\nQuick reference for essential commands.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#conda",
    "href": "appendices/commands.html#conda",
    "title": "Appendix B — Command Reference",
    "section": "",
    "text": "B.1.1 Environment Management\n# Create environment\nconda create -n ENV_NAME python=3.11\n\n# Create with packages\nconda create -n ENV_NAME python=3.11 pandas numpy\n\n# Activate\nconda activate ENV_NAME\n\n# Deactivate\nconda deactivate\n\n# List environments\nconda env list\n\n# Remove environment\nconda env remove -n ENV_NAME\n\n# Export environment\nconda env export &gt; environment.yml\n\n# Create from file\nconda env create -f environment.yml\n\n# Update from file\nconda env update -f environment.yml\n\n\nB.1.2 Package Management\n# Install package\nconda install PACKAGE\n\n# Install specific version\nconda install PACKAGE=1.2.3\n\n# Update package\nconda update PACKAGE\n\n# Update all\nconda update --all\n\n# List installed\nconda list\n\n# Search for package\nconda search PACKAGE",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#renv-r",
    "href": "appendices/commands.html#renv-r",
    "title": "Appendix B — Command Reference",
    "section": "B.2 renv (R)",
    "text": "B.2 renv (R)\n# Initialize renv\nrenv::init()\n\n# Install package\ninstall.packages(\"package\")\nrenv::install(\"package\")\n\n# Snapshot (save state)\nrenv::snapshot()\n\n# Restore (load state)\nrenv::restore()\n\n# Check status\nrenv::status()\n\n# Update packages\nrenv::update()\nrenv::update(\"package\")\n\n# Deactivate renv\nrenv::deactivate()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#git",
    "href": "appendices/commands.html#git",
    "title": "Appendix B — Command Reference",
    "section": "B.3 Git",
    "text": "B.3 Git\n\nB.3.1 Setup\n# Initialize repo\ngit init\n\n# Clone repo\ngit clone URL\n\n# Configure identity\ngit config --global user.name \"Name\"\ngit config --global user.email \"email@example.com\"\n\n# Add remote\ngit remote add origin URL\n\n\nB.3.2 Daily Workflow\n# Check status\ngit status\n\n# View changes\ngit diff\ngit diff --staged\n\n# Stage files\ngit add FILE\ngit add .\n\n# Commit\ngit commit -m \"message\"\n\n# Push\ngit push\n\n# Pull\ngit pull\n\n\nB.3.3 Branches\n# List branches\ngit branch\n\n# Create and switch\ngit checkout -b BRANCH\n\n# Switch branch\ngit checkout BRANCH\n\n# Merge branch\ngit merge BRANCH\n\n# Delete branch\ngit branch -d BRANCH\n\n\nB.3.4 History\n# View log\ngit log\ngit log --oneline\ngit log --oneline -n 10\n\n# View specific commit\ngit show COMMIT_HASH\n\n# View file history\ngit log -p FILE\n\n\nB.3.5 Undoing\n# Unstage file\ngit reset HEAD FILE\n\n# Discard changes to file\ngit checkout -- FILE\n\n# Undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Amend last commit\ngit commit --amend",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#github-cli-gh",
    "href": "appendices/commands.html#github-cli-gh",
    "title": "Appendix B — Command Reference",
    "section": "B.4 GitHub CLI (gh)",
    "text": "B.4 GitHub CLI (gh)\n# Authenticate\ngh auth login\n\n# Create repo\ngh repo create NAME --private\n\n# Clone repo\ngh repo clone OWNER/REPO\n\n# Create PR\ngh pr create --title \"Title\" --body \"Description\"\n\n# View PR\ngh pr view NUMBER\n\n# List issues\ngh issue list\n\n# Create issue\ngh issue create --title \"Title\" --body \"Description\"",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#quarto",
    "href": "appendices/commands.html#quarto",
    "title": "Appendix B — Command Reference",
    "section": "B.5 Quarto",
    "text": "B.5 Quarto\n# Create project\nquarto create project book NAME\n\n# Render document\nquarto render FILE.qmd\n\n# Render project\nquarto render\n\n# Preview (live reload)\nquarto preview\n\n# Publish to GitHub Pages\nquarto publish gh-pages",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#file-operations-bash",
    "href": "appendices/commands.html#file-operations-bash",
    "title": "Appendix B — Command Reference",
    "section": "B.6 File Operations (Bash)",
    "text": "B.6 File Operations (Bash)\n# Create directory\nmkdir DIRNAME\nmkdir -p path/to/nested/dir\n\n# List files\nls\nls -la\n\n# Change directory\ncd DIRNAME\ncd ..\ncd ~\n\n# Copy file\ncp SOURCE DEST\n\n# Move/rename\nmv SOURCE DEST\n\n# Remove file\nrm FILE\n\n# Remove directory\nrm -r DIRNAME\n\n# View file\ncat FILE\nless FILE\nhead FILE\ntail FILE",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#python-quick-reference",
    "href": "appendices/commands.html#python-quick-reference",
    "title": "Appendix B — Command Reference",
    "section": "B.7 Python Quick Reference",
    "text": "B.7 Python Quick Reference\n# Virtual environment (alternative to conda)\npython -m venv .venv\nsource .venv/bin/activate  # macOS/Linux\n.venv\\Scripts\\activate     # Windows\n\n# Install from requirements\npip install -r requirements.txt\n\n# Save requirements\npip freeze &gt; requirements.txt\n\n# Run script\npython script.py\n\n# Run module\npython -m module_name\n\n# Interactive Python\npython\nipython",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/commands.html#r-quick-reference",
    "href": "appendices/commands.html#r-quick-reference",
    "title": "Appendix B — Command Reference",
    "section": "B.8 R Quick Reference",
    "text": "B.8 R Quick Reference\n# Run script from command line\nRscript script.R\n\n# Install package\ninstall.packages(\"package\")\n\n# Load package\nlibrary(package)\n\n# Get help\n?function\nhelp(function)\n\n# Set working directory\nsetwd(\"path\")\n\n# Get working directory\ngetwd()\n\n# List objects\nls()\n\n# Remove object\nrm(object)\n\n# Clear environment\nrm(list = ls())",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Command Reference</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html",
    "href": "appendices/templates.html",
    "title": "Appendix C — Templates",
    "section": "",
    "text": "C.1 .gitignore\nCopy-paste templates for common project files.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#gitignore",
    "href": "appendices/templates.html#gitignore",
    "title": "Appendix C — Templates",
    "section": "",
    "text": ".gitignore\n\n# Generated outputs (reproducible from code)\nouts/\n\n# R artifacts\n.Rhistory\n.RData\n.Rproj.user/\nrenv/library/\nrenv/staging/\nrenv/local/\n*_cache/\n\n# Python artifacts\n__pycache__/\n*.py[cod]\n*.egg-info/\n.eggs/\n*.egg\n.venv/\nvenv/\n\n# Quarto rendering\n*_files/\n.quarto/\n\n# OS files\n.DS_Store\nThumbs.db\n\n# IDE settings\n.vscode/\n.positron/\n*.Rproj\n\n# Secrets\n.env\n*.pem\ncredentials.json",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#environment.yml-conda",
    "href": "appendices/templates.html#environment.yml-conda",
    "title": "Appendix C — Templates",
    "section": "C.2 environment.yml (Conda)",
    "text": "C.2 environment.yml (Conda)\n\n\nenvironment.yml\n\nname: project-name\nchannels:\n  - conda-forge\n  - defaults\ndependencies:\n  - python=3.11\n  - pandas\n  - numpy\n  - matplotlib\n  - seaborn\n  - ipykernel\n  - pip\n  - pip:\n    - session-info\n\nGenerate with conda env export --from-history &gt; environment.yml for a portable file containing only explicitly installed packages.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#readme.md",
    "href": "appendices/templates.html#readme.md",
    "title": "Appendix C — Templates",
    "section": "C.3 README.md",
    "text": "C.3 README.md\n\n\nREADME.md\n\n# Project Name\n\nBrief description of what this project does.\n\n## Setup\n\n### Prerequisites\n- [Positron](https://positron.posit.co/) (recommended) or VS Code\n- [rig](https://github.com/r-lib/rig) for R installation\n- [Conda](https://github.com/conda-forge/miniforge) (Miniforge recommended)\n- [Git](https://git-scm.com/)\n\n### Installation\n\n1. Clone the repository:\n   ```bash\n   git clone https://github.com/username/project-name.git\n   cd project-name\n\n\nCreate conda environment (Python):\nconda env create -f environment.yml\nconda activate project-name\nInstall R packages (if using R):\nrenv::restore()\nConfigure Positron interpreters via Command Palette (Cmd+Shift+P / Ctrl+Shift+P):\n\nR: “R: Select Interpreter” → select R 4.x\nPython: “Python: Select Interpreter” → select project-name conda env",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#project-structure",
    "href": "appendices/templates.html#project-structure",
    "title": "Appendix C — Templates",
    "section": "C.4 Project Structure",
    "text": "C.4 Project Structure\nproject-name/\n├── data/            # External inputs (read-only)\n├── scripts/         # Quarto analysis scripts (.qmd)\n│   └── exploratory/ # One-off analyses\n├── outs/            # All script-generated outputs\n├── R/               # Shared R helper functions\n├── python/          # Shared Python helper functions\n├── environment.yml  # Python dependencies\n└── renv.lock        # R dependencies",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#data",
    "href": "appendices/templates.html#data",
    "title": "Appendix C — Templates",
    "section": "C.5 Data",
    "text": "C.5 Data\nDescribe data sources: - data/file.csv: Description, source, date obtained",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#authors",
    "href": "appendices/templates.html#authors",
    "title": "Appendix C — Templates",
    "section": "C.6 Authors",
    "text": "C.6 Authors\n\nYour Name (@github-username)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#license",
    "href": "appendices/templates.html#license",
    "title": "Appendix C — Templates",
    "section": "C.7 License",
    "text": "C.7 License\n[Choose appropriate license]\n\n## .claude/CLAUDE.md\n\n```{.markdown filename=\".claude/CLAUDE.md\"}\n# Project: Project Name\n\n## Overview\nBrief description of the project and its goals.\n\n## Environment\n\n### Python\n```bash\nconda activate project-name\n\nC.7.1 R\nUses renv. Activates automatically via .Rprofile.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#key-files-and-directories",
    "href": "appendices/templates.html#key-files-and-directories",
    "title": "Appendix C — Templates",
    "section": "C.8 Key Files and Directories",
    "text": "C.8 Key Files and Directories\n\ndata/ — External input data (read-only, scripts never write here)\nscripts/ — Quarto analysis scripts (.qmd)\nscripts/exploratory/ — One-off analyses\nouts/ — All script-generated outputs\nR/ — Shared R helper functions\npython/ — Shared Python helper functions",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#workflows",
    "href": "appendices/templates.html#workflows",
    "title": "Appendix C — Templates",
    "section": "C.9 Workflows",
    "text": "C.9 Workflows\n\nC.9.1 Running the full analysis\nquarto render scripts/\n\n\nC.9.2 Rendering a single script\n# R scripts\nquarto render scripts/01_analysis.qmd\n\n# Python scripts (conda must be active)\nsource ~/miniconda3/etc/profile.d/conda.sh && conda activate project-name && quarto render scripts/02_plots.qmd",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#data-1",
    "href": "appendices/templates.html#data-1",
    "title": "Appendix C — Templates",
    "section": "C.10 Data",
    "text": "C.10 Data\n\nC.10.1 Input data\n\ndata/counts.csv — Gene expression counts, 20000 genes × 12 samples\ndata/metadata.csv — Sample metadata",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#conventions",
    "href": "appendices/templates.html#conventions",
    "title": "Appendix C — Templates",
    "section": "C.11 Conventions",
    "text": "C.11 Conventions\n\nScripts use status: lifecycle field (development → finalized → deprecated)\nEvery script writes BUILD_INFO.txt to its output folder\nScripts communicate through files in outs/, not shared memory\nCross-language data uses Parquet format\nUse tidyverse style for R code\nCommit after completing each logical unit of work",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#project-document-registry",
    "href": "appendices/templates.html#project-document-registry",
    "title": "Appendix C — Templates",
    "section": "C.12 Project Document Registry",
    "text": "C.12 Project Document Registry\n[Planning documents go here as the project grows]\n\n## R QMD Template\n\n```{.markdown filename=\"scripts/01_analysis.qmd\"}\n---\ntitle: \"Analysis Title\"\nsubtitle: \"Brief description\"\nauthor: \"Your Name\"\ndate: today\nstatus: development\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    code-overflow: wrap\n    code-fold: false\n    code-tools: true\n    highlight-style: github\n    theme: cosmo\n    fontsize: 1rem\n    linestretch: 1.5\n    self-contained: true\nexecute:\n  echo: true\n  message: false\n  warning: false\n  cache: false\n---\n\n## Introduction\n\nBrief description of the analysis.\n\n## Setup\n\n```{r}\n#| label: setup\n#| include: false\n\n# ---- Libraries ----\nsuppressPackageStartupMessages({\n  library(tidyverse)\n  library(here)\n})\n\n# ---- Paths ----\ndir_data &lt;- here::here(\"data\")\ndir_out &lt;- here::here(\"outs\", \"01_analysis\")\ndir.create(dir_out, recursive = TRUE, showWarnings = FALSE)\n\n# ---- Options ----\noptions(stringsAsFactors = FALSE)\nset.seed(42)\n\n# ---- Provenance ----\ngit_hash &lt;- system(\"git rev-parse --short HEAD\", intern = TRUE)\ncat(\"Rendered from commit:\", git_hash, \"\\n\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#inputs",
    "href": "appendices/templates.html#inputs",
    "title": "Appendix C — Templates",
    "section": "C.13 Inputs",
    "text": "C.13 Inputs\n```{r}\n#| label: inputs\n\n# --- Inputs (external data) ---\ndata &lt;- read_csv(here(\"data\", \"data.csv\"))\ncat(\"Loaded\", nrow(data), \"rows\\n\")\n```",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#analysis",
    "href": "appendices/templates.html#analysis",
    "title": "Appendix C — Templates",
    "section": "C.14 Analysis",
    "text": "C.14 Analysis\nYour analysis code here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#results",
    "href": "appendices/templates.html#results",
    "title": "Appendix C — Templates",
    "section": "C.15 Results",
    "text": "C.15 Results\nSummary of results.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#build-info",
    "href": "appendices/templates.html#build-info",
    "title": "Appendix C — Templates",
    "section": "C.16 Build Info",
    "text": "C.16 Build Info\n```{r}\n#| label: build-info\n\nwriteLines(\n  c(\n    paste(\"script:\", \"01_analysis.qmd\"),\n    paste(\"commit:\", git_hash),\n    paste(\"date:\", format(Sys.time(), \"%Y-%m-%d %H:%M:%S\"))\n  ),\n  file.path(dir_out, \"BUILD_INFO.txt\")\n)\n\nsessionInfo()\n```\n\n## Python QMD Template\n\n```{.markdown filename=\"scripts/01_analysis.qmd\"}\n---\ntitle: \"Analysis Title\"\nsubtitle: \"Brief description\"\nauthor: \"Your Name\"\ndate: today\nstatus: development\njupyter: python3\nformat:\n  html:\n    toc: true\n    toc-depth: 2\n    number-sections: true\n    code-overflow: wrap\n    code-fold: false\n    code-tools: true\n    highlight-style: github\n    theme: cosmo\n    fontsize: 1rem\n    linestretch: 1.5\n    self-contained: true\nexecute:\n  echo: true\n  warning: false\n  cache: false\n---\n\n## Introduction\n\nBrief description of the analysis.\n\n## Setup\n\n```{python}\n#| label: setup\n\nimport subprocess\nimport sys\nimport random\nfrom pathlib import Path\nfrom datetime import datetime\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nPROJECT_ROOT = Path(subprocess.check_output(\n    [\"git\", \"rev-parse\", \"--show-toplevel\"]\n).decode().strip())\nsys.path.insert(0, str(PROJECT_ROOT / \"python\"))\n\n# ---- Options ----\nrandom.seed(42)\nnp.random.seed(42)\npd.set_option(\"display.max_columns\", None)\nsns.set_theme(style=\"whitegrid\")\n\n# ---- Paths ----\nout_dir = PROJECT_ROOT / \"outs/01_analysis\"\nout_dir.mkdir(parents=True, exist_ok=True)\n\ngit_hash = subprocess.check_output(\n    [\"git\", \"rev-parse\", \"--short\", \"HEAD\"]\n).decode().strip()\nprint(f\"Rendered from commit: {git_hash}\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#inputs-1",
    "href": "appendices/templates.html#inputs-1",
    "title": "Appendix C — Templates",
    "section": "C.17 Inputs",
    "text": "C.17 Inputs\n```{python}\n#| label: inputs\n\n# --- Inputs (external data) ---\ndata = pd.read_csv(PROJECT_ROOT / \"data/data.csv\")\nprint(f\"Loaded {len(data)} rows\")\n```",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#analysis-1",
    "href": "appendices/templates.html#analysis-1",
    "title": "Appendix C — Templates",
    "section": "C.18 Analysis",
    "text": "C.18 Analysis\nYour analysis code here.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#results-1",
    "href": "appendices/templates.html#results-1",
    "title": "Appendix C — Templates",
    "section": "C.19 Results",
    "text": "C.19 Results\nSummary of results.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#build-info-1",
    "href": "appendices/templates.html#build-info-1",
    "title": "Appendix C — Templates",
    "section": "C.20 Build Info",
    "text": "C.20 Build Info\n```{python}\n#| label: build-info\n\n(out_dir / \"BUILD_INFO.txt\").write_text(\n    f\"script: 01_analysis.qmd\\n\"\n    f\"commit: {git_hash}\\n\"\n    f\"date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n)\n\nimport session_info\nsession_info.show()\n```\n\n## Python Script Template (.py)\n\nFor standalone utilities, CLI tools, and library code (not for data analysis — use QMD for that):\n\n```{.python filename=\"python/helpers.py\"}\n\"\"\"\nShared helper functions for this project.\n\"\"\"\n\nfrom pathlib import Path\nimport pandas as pd\n\n\ndef load_data(filename: str) -&gt; pd.DataFrame:\n    \"\"\"Load a data file from the project data/ directory.\"\"\"\n    project_root = Path(__file__).parent.parent\n    return pd.read_csv(project_root / \"data\" / filename)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/templates.html#r-script-template-.r",
    "href": "appendices/templates.html#r-script-template-.r",
    "title": "Appendix C — Templates",
    "section": "C.21 R Script Template (.R)",
    "text": "C.21 R Script Template (.R)\nFor shared helper functions (not for data analysis — use QMD for that):\n\n\nR/helpers.R\n\n# Shared helper functions for this project.\n\n#' Load and validate a data file\n#'\n#' @param filename Name of file in data/ directory\n#' @return A tibble\nload_data &lt;- function(filename) {\n  path &lt;- here::here(\"data\", filename)\n  stopifnot(file.exists(path))\n  readr::read_csv(path, show_col_types = FALSE)\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Templates</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html",
    "href": "appendices/r-packages.html",
    "title": "Appendix D — R Packages for Biology",
    "section": "",
    "text": "D.1 The Tidyverse\nThis appendix lists the R packages you’re most likely to use for biological data analysis in the lab. It’s a reference, not a tutorial — you don’t need to install all of these upfront. Install them as you need them for specific projects, using the methods described in the R: rig & renv chapter.\nThe tidyverse is a collection of R packages that share a common design philosophy centered on “tidy data” — rectangular data where each variable is a column, each observation is a row, and each value is a cell. This simple principle, combined with a consistent and expressive syntax, has made the tidyverse the standard toolkit for data analysis in R.\nWhat makes the tidyverse practical is that it provides a unified grammar for the entire data analysis pipeline: importing data, reshaping it, transforming it, visualizing it, and communicating results. The packages are designed to work together, with consistent naming conventions and compatible data structures. Code written in tidyverse style tends to be readable — you can often understand what a pipeline does just by reading it.\nThe tidyverse occupies the same role in R that pandas does in Python: both represent the modern, dataframe-centric approach to data manipulation. If you learn one well, the concepts transfer to the other.\nThe core packages:\nLoading the tidyverse meta-package loads all of these at once:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html#tidyverse",
    "href": "appendices/r-packages.html#tidyverse",
    "title": "Appendix D — R Packages for Biology",
    "section": "",
    "text": "Package\nPurpose\n\n\n\n\ndplyr\nData manipulation: filter rows, select columns, create new variables, summarize, join tables\n\n\nggplot2\nVisualization using the grammar of graphics\n\n\ntidyr\nReshape data: pivot between wide and long formats\n\n\nreadr\nFast, consistent data import (read_csv, read_tsv, etc.)\n\n\npurrr\nFunctional programming: apply functions across lists and vectors\n\n\nstringr\nString manipulation with consistent syntax\n\n\n\n\nlibrary(tidyverse)\n\n\n\n\n\n\nTipLearning the Tidyverse\n\n\n\nIf you’re new to R or transitioning from base R, work through R for Data Science by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. It’s the definitive resource for learning modern R workflows.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html#other-essential-packages",
    "href": "appendices/r-packages.html#other-essential-packages",
    "title": "Appendix D — R Packages for Biology",
    "section": "D.2 Other Essential Packages",
    "text": "D.2 Other Essential Packages\n\n\n\n\n\n\n\nPackage\nPurpose\n\n\n\n\nhere\nBuild file paths relative to the project root — essential for reproducible scripts\n\n\nknitr\nRequired for rendering Quarto documents with R code",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html#bioconductor-appendix",
    "href": "appendices/r-packages.html#bioconductor-appendix",
    "title": "Appendix D — R Packages for Biology",
    "section": "D.3 Bioconductor",
    "text": "D.3 Bioconductor\nBioconductor is a specialized repository of R packages for bioinformatics and computational biology. It’s separate from CRAN and has its own installation system, release schedule, and quality standards. If you’re doing genomics, transcriptomics, or single-cell analysis in R, you’ll use Bioconductor packages extensively.\n\nD.3.1 What Makes Bioconductor Different\nCurated and reviewed. Packages undergo technical review before acceptance and must meet documentation and testing standards.\nCoordinated releases. All Bioconductor packages are released together twice per year, tested against each other for compatibility.\nSpecialized data structures. Bioconductor defines standard classes for genomic data (SummarizedExperiment, SingleCellExperiment, etc.) that packages use consistently.\nTied to R versions. Each Bioconductor release requires a specific R version. This is important for reproducibility — see the rig & renv chapter for details.\n\n\nD.3.2 Installing Bioconductor Packages\nBioconductor packages are installed via BiocManager:\n# First, install BiocManager (only once per R installation)\ninstall.packages(\"BiocManager\")\n\n# Then install Bioconductor packages\nBiocManager::install(\"DESeq2\")\nBiocManager::install(c(\"limma\", \"edgeR\", \"tximport\"))\nIn an renv project, you can also use the bioc:: prefix:\nrenv::install(\"bioc::DESeq2\")\nAlways run renv::snapshot() after installing Bioconductor packages.\n\n\nD.3.3 Bioconductor Version Synchronization\nBioconductor versions are tied to R versions:\n\n\n\nBioconductor\nR Version\nRelease Date\n\n\n\n\n3.18\nR 4.3.x\nOct 2023\n\n\n3.19\nR 4.4.x\nMay 2024\n\n\n3.20\nR 4.4.x\nOct 2024\n\n\n3.21\nR 4.5.x\nMay 2025\n\n\n\nCheck your current Bioconductor version:\nBiocManager::version()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html#rna-seq-analysis-packages",
    "href": "appendices/r-packages.html#rna-seq-analysis-packages",
    "title": "Appendix D — R Packages for Biology",
    "section": "D.4 RNA-seq Analysis Packages",
    "text": "D.4 RNA-seq Analysis Packages\nThese packages form the core toolkit for bulk RNA-seq differential expression analysis:\n\n\n\n\n\n\n\nPackage\nPurpose\n\n\n\n\nDESeq2\nDifferential expression using negative binomial generalized linear models. The most widely used method.\n\n\nlimma\nLinear models for differential expression. Includes voom for RNA-seq count data. Fast and flexible.\n\n\nedgeR\nDifferential expression using empirical Bayes estimation. Similar approach to DESeq2.\n\n\ntximport\nImport transcript-level quantifications from Salmon, kallisto, or RSEM into gene-level counts.\n\n\ntximeta\nLike tximport but automatically attaches metadata about the reference transcriptome.\n\n\ngoseq\nGene Ontology enrichment analysis that accounts for gene length bias in RNA-seq data.\n\n\n\nA typical RNA-seq analysis workflow uses tximport or tximeta to import quantifications, then DESeq2 (or limma/edgeR) for differential expression, then goseq for pathway analysis.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  },
  {
    "objectID": "appendices/r-packages.html#single-cell-analysis-packages",
    "href": "appendices/r-packages.html#single-cell-analysis-packages",
    "title": "Appendix D — R Packages for Biology",
    "section": "D.5 Single-Cell Analysis Packages",
    "text": "D.5 Single-Cell Analysis Packages\nSingle-cell RNA-seq requires specialized methods. These are the main packages:\n\n\n\n\n\n\n\nPackage\nPurpose\n\n\n\n\nSeurat\nComprehensive toolkit for single-cell analysis: QC, normalization, clustering, visualization, integration across datasets. The most popular choice.\n\n\nSingleCellExperiment\nBioconductor’s standard data structure for single-cell data. Many packages use this format.\n\n\nscran\nNormalization (pooling-based), feature selection, and clustering methods from the Bioconductor ecosystem.\n\n\nscater\nQuality control, visualization, and preprocessing. Works with SingleCellExperiment objects.\n\n\nMonocle3\nTrajectory analysis and pseudotime inference — modeling how cells transition between states.\n\n\n\n\n\n\n\n\n\nNoteSeurat vs. Bioconductor Ecosystem\n\n\n\nSeurat is the most popular single-cell package but isn’t part of Bioconductor — it’s on CRAN (and GitHub). The Bioconductor single-cell packages (SingleCellExperiment, scran, scater) form an alternative ecosystem. Many workflows use both: Seurat for analysis and visualization, with conversion to SingleCellExperiment when needed for specific Bioconductor tools.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>R Packages for Biology</span>"
    ]
  }
]